<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-container-Container'>/**
</span> * Base class for any Ext.Component that may contain other Components. Containers handle the basic behavior of
 * containing items, namely adding, inserting and removing items.
 *
 * The most commonly used Container classes are Ext.panel.Panel, Ext.window.Window and
 * Ext.tab.Panel. If you do not need the capabilities offered by the aforementioned classes you can create a
 * lightweight Container to be encapsulated by an HTML element to your specifications by using the
 * {@link Ext.Component#autoEl autoEl} config option.
 *
 * The code below illustrates how to explicitly create a Container:
 *
 *     @example
 *     // Explicitly create a Container
 *     Ext.create(&#39;Ext.container.Container&#39;, {
 *         layout: {
 *             type: &#39;hbox&#39;
 *         },
 *         width: 400,
 *         renderTo: Ext.getBody(),
 *         border: 1,
 *         style: {borderColor:&#39;#000000&#39;, borderStyle:&#39;solid&#39;, borderWidth:&#39;1px&#39;},
 *         defaults: {
 *             labelWidth: 80,
 *             // implicitly create Container by specifying xtype
 *             xtype: &#39;datefield&#39;,
 *             flex: 1,
 *             style: {
 *                 padding: &#39;10px&#39;
 *             }
 *         },
 *         items: [{
 *             xtype: &#39;datefield&#39;,
 *             name: &#39;startDate&#39;,
 *             fieldLabel: &#39;Start date&#39;
 *         },{
 *             xtype: &#39;datefield&#39;,
 *             name: &#39;endDate&#39;,
 *             fieldLabel: &#39;End date&#39;
 *         }]
 *     });
 *
 * ## Layout
 *
 * Container classes delegate the rendering of child Components to a layout manager class which must be configured into
 * the Container using the `{@link #layout}` configuration property.
 *
 * When either specifying child `{@link #cfg-items}` of a Container, or dynamically {@link #method-add adding} Components to a
 * Container, remember to consider how you wish the Container to arrange those child elements, and whether those child
 * elements need to be sized using one of Ext&#39;s built-in `{@link #layout}` schemes. By default, Containers use the
 * {@link Ext.layout.container.Auto Auto} scheme which only renders child components, appending them one after the other
 * inside the Container, and **does not apply any sizing** at all.
 *
 * A common mistake is when a developer neglects to specify a `{@link #layout}` (e.g. GridPanels or
 * TreePanels are added to Containers for which no `{@link #layout}` has been specified). If a Container is left to
 * use the default {@link Ext.layout.container.Auto Auto} scheme, none of its child components will be resized, or changed in
 * any way when the Container is resized.
 *
 * Certain layout managers allow dynamic addition of child components. Those that do include
 * Ext.layout.container.Card, Ext.layout.container.Anchor, Ext.layout.container.VBox,
 * Ext.layout.container.HBox, and Ext.layout.container.Table. For example:
 *
 *     //  Create the GridPanel.
 *     var myNewGrid = Ext.create(&#39;Ext.grid.Panel&#39;, {
 *         store: myStore,
 *         headers: myHeaders,
 *         title: &#39;Results&#39;, // the title becomes the title of the tab
 *     });
 *
 *     myTabPanel.add(myNewGrid); // {@link Ext.tab.Panel} implicitly uses {@link Ext.layout.container.Card Card}
 *     myTabPanel.{@link Ext.tab.Panel#setActiveTab setActiveTab}(myNewGrid);
 *
 * The example above adds a newly created GridPanel to a TabPanel. Note that a TabPanel uses {@link
 * Ext.layout.container.Card} as its layout manager which means all its child items are sized to {@link
 * Ext.layout.container.Fit fit} exactly into its client area.
 *
 * **_Overnesting is a common problem_**. An example of overnesting occurs when a GridPanel is added to a TabPanel by
 * wrapping the GridPanel _inside_ a wrapping Panel (that has no `{@link #layout}` specified) and then add that
 * wrapping Panel to the TabPanel. The point to realize is that a GridPanel **is** a Component which can be added
 * directly to a Container. If the wrapping Panel has no `{@link #layout}` configuration, then the overnested
 * GridPanel will not be sized as expected.
 * 
 * ## {@link Ext.Component#reference References} and {@link #referenceHolder Reference Holders}
 * 
 * Reference holders are used to keep references to child components inside a hierarchy.
 * 
 * This functionality allows the connection of encapsulated references between containers
 * and their child components declaratively. Simple usage:
 * 
 *     Ext.define(&#39;Login&#39;, {
 *         extend: &#39;Ext.window.Window&#39;,
 *
 *         // This config is not compatible with the more common &quot;controller&quot; config
 *         // used to specify a ViewController for the view. When a ViewController is
 *         // specified it effectively acts as the &quot;reference holder&quot; for the view. In
 *         // this example we simply mark this container as the reference holder for
 *         // demonstration purposes.
 *         referenceHolder: true,
 *
 *         title: &#39;Login&#39;,
 *         items: [{
 *             xtype: &#39;form&#39;,
 *             items: [{
 *                 xtype: &#39;textfield&#39;,
 *                 reference: &#39;username&#39;, // A named reference to be held on the referenceHolder
 *                 name: &#39;username&#39;,
 *                 fieldLabel: &#39;Username&#39;
 *             }, {
 *                 xtype: &#39;textfield&#39;,
 *                 reference: &#39;password&#39;, // A named reference to be held on the referenceHolder
 *                 name: &#39;password&#39;,
 *                 fieldLabel: &#39;Password&#39;
 *             }] 
 *         }] 
 *     });
 *     var w = new Login();
 *     console.log(w.lookupReference(&#39;password&#39;)); // The password field
 * 
 * Reference holders are also encapsulated, so a reference will only be put on the closest
 * reference holder above it in the component hierarchy:
 * 
 *     var ct = new Ext.container.Container({
 *         referenceHolder: true,
 *         items: [{
 *             xtype: &#39;container&#39;,
 *             referenceHolder: true,
 *             reference: &#39;innerCt1&#39;,
 *             items: [{
 *                 xtype: &#39;component&#39;,
 *                 reference: &#39;a&#39;,
 *                 id: &#39;a1&#39;
 *             }, {
 *                 xtype: &#39;component&#39;,
 *                 reference: &#39;b&#39;,
 *                 id: &#39;b1&#39;
 *             }]
 *         }, {
 *             xtype: &#39;container&#39;,
 *             referenceHolder: true,
 *             reference: &#39;innerCt2&#39;,
 *             items: [{
 *                 xtype: &#39;component&#39;,
 *                 reference: &#39;a&#39;,
 *                 id: &#39;a2&#39;
 *             }, {
 *                 xtype: &#39;component&#39;,
 *                 reference: &#39;b&#39;,
 *                 id: &#39;b2&#39;
 *             }]
 *         }]
 *     });
 *     // The main container will not have references to a/b, each innerCt will
 *     console.log(ct.lookupReference(&#39;a&#39;), ct.lookupReference(&#39;b&#39;));
 *     var inner1 = ct.lookupReference(&#39;innerCt1&#39;);
 *     var inner2 = ct.lookupReference(&#39;innerCt2&#39;);
 * 
 *     console.log(inner1.lookupReference(&#39;a&#39;).id, inner1.lookupReference(&#39;b&#39;).id);
 *     console.log(inner2.lookupReference(&#39;a&#39;).id, inner2.lookupReference(&#39;b&#39;).id);
 *     
 * If the view has a controller attached, it will automatically become a {@link #referenceHolder}.
 * References will be available in both the view and the controller:
 * 
 *     Ext.define(&#39;ProfileController&#39;, {
 *         extend: &#39;Ext.app.ViewController&#39;,
 *         alias: &#39;controller.profile&#39;,
 *   
 *         init: function() {
 *             console.log(this.lookupReference(&#39;firstName&#39;));
 *         }
 *     });
 *
 *     Ext.define(&#39;Profile&#39;, {
 *         extend: &#39;Ext.form.Panel&#39;,
 *         controller: &#39;profile&#39;,
 *         items: [{
 *             xtype: &#39;textfield&#39;,
 *             reference: &#39;firstName&#39;,
 *             fieldLabel: &#39;First Name&#39;
 *         }]
 *     });
 * 
 *     new Profile(); 
 * 
 * ## Events &amp; {@link #defaultListenerScope} ##
 * 
 * Events can use the default listener scope to determine at runtime the appropriate place
 * to fire. This allows for declarative binding of events in a useful way:
 * 
 *     Ext.define(&#39;MyView&#39;, {
 *         extend: &#39;Ext.container.Container&#39;,
 *         defaultListenerScope: true,
 *         referenceHolder: true,
 *         items: [{
 *             xtype: &#39;textfield&#39;,
 *             reference: &#39;myfield&#39;
 *         }, {
 *             xtype: &#39;button&#39;,
 *             text: &#39;Set to A&#39;,
 *             listeners: {
 *                 click: &#39;onButtonAClick&#39;
 *             }
 *         }, {
 *             xtype: &#39;button&#39;,
 *             text: &#39;Set to B&#39;,
 *             listeners: {
 *                 click: &#39;onButtonBClick&#39;
 *             }
 *         }],
 * 
 *         onButtonAClick: function() {
 *             this.lookupReference(&#39;myfield&#39;).setValue(&#39;A&#39;);
 *         },
 * 
 *         onButtonBClick: function() {
 *             this.lookupReference(&#39;myfield&#39;).setValue(&#39;B&#39;);
 *         }
 *     });
 *     
 * Like {@link #referenceHolder}, the {@link #defaultListenerScope} is encapsulated, the scope will
 * be resolved at the closest {@link #defaultListenerScope} above it in the component hierarchy:
 * 
 *     var ct = new Ext.container.Container({
 *         defaultListenerScope: true,
 *         onCustomEvent: function() {
 *             console.log(&#39;Outer called&#39;); // Will NOT be called
 *         },
 *         items: [{
 *             xtype: &#39;container&#39;,
 *             defaultListenerScope: true,
 *             onCustomEvent: function() {
 *                 console.log(&#39;Inner called&#39;); // Will be called
 *             },
 *             items: [{
 *                 xtype: &#39;component&#39;,
 *                 itemId: &#39;child&#39;,
 *                 listeners: {
 *                     customevent: &#39;onCustomEvent&#39;
 *                 }
 *             }]
 *         }]
 *     });
 *     // The main container will not have references to a/b, each innerCt will
 *     console.log(ct.lookupReference(&#39;a&#39;), ct.lookupReference(&#39;b&#39;));
 *     var inner1 = ct.lookupReference(&#39;innerCt1&#39;);
 *     var inner2 = ct.lookupReference(&#39;innerCt2&#39;);
 * 
 *     console.log(inner1.lookupReference(&#39;a&#39;).id, inner1.lookupReference(&#39;b&#39;).id);
 *     console.log(inner2.lookupReference(&#39;a&#39;).id, inner2.lookupReference(&#39;b&#39;).id);
 * 
 * Similar to references, if a {@link Ext.app.ViewController} is attached to this view, it becomes
 * the {@link #defaultListenerScope}, which means un-scoped, late bound events will be directed to the
 * controller. This is powerful as it allows views to be totally declarative:
 * 
 *     Ext.define(&#39;MyApp.controller.Login&#39;, {
 *         extend : &#39;Ext.app.ViewController&#39;,
 *         alias : &#39;controller.login&#39;,
 *   
 *         init: function() {
 *             this.sendCount = 0;    
 *         },
 *
 *         onLoginClick : function(btn) {
 *             this.login();
 *         },
 *
 *         onFieldSpecialKey : function(field, e) {
 *             if (e.getKey() === e.ENTER) {
 *                this.login();
 *             }
 *         },
 *
 *         login : function() {
 *            var form = this.lookupReference(&#39;form&#39;);
 *             this.lookupReference(&#39;error&#39;).hide();
 *             if (form.isValid()) {
 *                 console.log(&#39;Do the login!&#39;);
 *                 // Server responded...
 *                 if (++this.sendCount % 2 === 0) {
 *                     this.onServerSuccess();
 *                 } else {
 *                     this.onServerFailure();
 *                 }
 *             }
 *         },
 *   
 *         onServerSuccess: function() {
 *             // Proceed   
 *             console.log(&#39;All good&#39;);
 *         },
 *   
 *         onServerFailure: function() {
 *             var error = this.lookupReference(&#39;error&#39;);
 *             error.update(&#39;Invalid username/password&#39;);
 *             error.show();
 *         }
 *     });
 *
 *     Ext.define(&#39;MyApp.view.Login&#39;, {
 *         extend : &#39;Ext.window.Window&#39;,
 *         controller : &#39;login&#39;,
 *         referenceHolder: true,
 *
 *         title : &#39;Login&#39;,
 *         width : 400,
 *
 *         items : [{
 *             xtype : &#39;form&#39;,
 *             reference : &#39;form&#39;,
 *             border : false,
 *             bodyPadding : 10,
 *             defaultType : &#39;textfield&#39;,
 *             defaults : {
 *                 anchor : &#39;90%&#39;,
 *                 allowBlank : false,
 *                 enableKeyEvents : true
 *             },
 *             items : [{
 *                 xtype: &#39;component&#39;,
 *                 reference: &#39;error&#39;,
 *                 hidden: true,
 *                 margin: &#39;0 0 10 0&#39;,
 *                 style: &#39;color: red;&#39;
 *             }, {
 *                 name : &#39;username&#39;,
 *                 fieldLabel : &#39;Username&#39;,
 *                 reference : &#39;username&#39;,
 *                 listeners : {
 *                     specialkey : &#39;onFieldSpecialKey&#39;
 *                 }
 *             }, {
 *                 name : &#39;password&#39;,
 *                 fieldLabel : &#39;Password&#39;,
 *                 reference : &#39;password&#39;,
 *                 inputType : &#39;password&#39;,
 *                 listeners : {
 *                     specialkey : &#39;onFieldSpecialKey&#39;
 *                 }
 *             }]
 *         }],
 *         buttons : [&#39;-&gt;&#39;, {
 *            text : &#39;Login&#39;,
 *             listeners : {
 *                 click : &#39;onLoginClick&#39;
 *             }
 *         }]
 *     });
 *
 * ## Adding via remote configuration
 *
 * A server side script can be used to add Components which are generated dynamically on the server. An example of
 * adding a GridPanel to a TabPanel where the GridPanel is generated by the server based on certain parameters:
 *
 *     // execute an Ajax request to invoke server side script:
 *     Ext.Ajax.request({
 *         url: &#39;gen-invoice-grid.php&#39;,
 *         // send additional parameters to instruct server script
 *         params: {
 *             startDate: Ext.getCmp(&#39;start-date&#39;).getValue(),
 *             endDate: Ext.getCmp(&#39;end-date&#39;).getValue()
 *         },
 *         // process the response object to add it to the TabPanel:
 *         success: function(xhr) {
 *             var newComponent = eval(xhr.responseText); // see discussion below
 *             myTabPanel.add(newComponent); // add the component to the TabPanel
 *             myTabPanel.setActiveTab(newComponent);
 *         },
 *         failure: function() {
 *             Ext.Msg.alert(&quot;Grid create failed&quot;, &quot;Server communication failure&quot;);
 *         }
 *     });
 *
 * The server script needs to return a JSON representation of a configuration object, which, when decoded will return a
 * config object with an {@link Ext.Component#xtype xtype}. The server might return the following JSON:
 *
 *     {
 *         &quot;xtype&quot;: &#39;grid&#39;,
 *         &quot;title&quot;: &#39;Invoice Report&#39;,
 *         &quot;store&quot;: {
 *             &quot;model&quot;: &#39;Invoice&#39;,
 *             &quot;proxy&quot;: {
 *                 &quot;type&quot;: &#39;ajax&#39;,
 *                 &quot;url&quot;: &#39;get-invoice-data.php&#39;,
 *                 &quot;reader&quot;: {
 *                     &quot;type&quot;: &#39;json&#39;
 *                     &quot;record&quot;: &#39;transaction&#39;,
 *                     &quot;idProperty&quot;: &#39;id&#39;,
 *                     &quot;totalRecords&quot;: &#39;total&#39;
 *                 })
 *             },
 *             &quot;autoLoad&quot;: {
 *                 &quot;params&quot;: {
 *                     &quot;startDate&quot;: &#39;01/01/2008&#39;,
 *                     &quot;endDate&quot;: &#39;01/31/2008&#39;
 *                 }
 *             }
 *         },
 *         &quot;headers&quot;: [
 *             {&quot;header&quot;: &quot;Customer&quot;, &quot;width&quot;: 250, &quot;dataIndex&quot;: &#39;customer&#39;, &quot;sortable&quot;: true},
 *             {&quot;header&quot;: &quot;Invoice Number&quot;, &quot;width&quot;: 120, &quot;dataIndex&quot;: &#39;invNo&#39;, &quot;sortable&quot;: true},
 *             {&quot;header&quot;: &quot;Invoice Date&quot;, &quot;width&quot;: 100, &quot;dataIndex&quot;: &#39;date&#39;, &quot;renderer&quot;: Ext.util.Format.dateRenderer(&#39;M d, y&#39;), &quot;sortable&quot;: true},
 *             {&quot;header&quot;: &quot;Value&quot;, &quot;width&quot;: 120, &quot;dataIndex&quot;: &#39;value&#39;, &quot;renderer&quot;: &#39;usMoney&#39;, &quot;sortable&quot;: true}
 *         ]
 *     }
 *
 * When the above code fragment is passed through the `eval` function in the success handler of the Ajax request, the
 * result will be a config object which, when added to a Container, will cause instantiation of a GridPanel. **Be sure
 * that the Container is configured with a layout which sizes and positions the child items to your requirements.**
 *
 * **Note:** since the code above is _generated_ by a server script, the `autoLoad` params for the Store, the user&#39;s
 * preferred date format, the metadata to allow generation of the Model layout, and the ColumnModel can all be generated
 * into the code since these are all known on the server.
 */
Ext.define(&#39;Ext.container.Container&#39;, {
    extend: &#39;Ext.Component&#39;,

    xtype: &#39;container&#39;,

    alternateClassName: [
        &#39;Ext.Container&#39;,
        &#39;Ext.AbstractContainer&#39;
    ],

    requires: [
        &#39;Ext.util.MixedCollection&#39;,
        &#39;Ext.layout.container.Auto&#39;,
        &#39;Ext.ZIndexManager&#39;
    ],

    mixins: [
        &#39;Ext.mixin.Queryable&#39;
    ],

<span id='Ext-container-Container-cfg-renderTpl'>    renderTpl: &#39;{%this.renderContainer(out,values)%}&#39;,
</span>
<span id='Ext-container-Container-property-isContainer'>    /*
</span>     * @property {Boolean} isContainer
     * `true` in this class to identify an object as an instantiated Container, or subclass thereof.
     */
    isContainer: true,

    // &lt;editor-fold desc=&quot;Config&quot;&gt;
    // ***********************************************************************************
    // Begin Config
    // ***********************************************************************************

<span id='Ext-container-Container-cfg-activeItem'>    /**
</span>     * @cfg {String/Number} activeItem
     * A string component id or the numeric index of the component that should be
     * initially activated within the container&#39;s layout on render.  For example,
     * activeItem: &#39;item-1&#39; or activeItem: 0 (index 0 = the first item in the
     * container&#39;s collection).  activeItem only applies to layout styles that can
     * display items one at a time (like {@link Ext.layout.container.Card} and
     * {@link Ext.layout.container.Fit}).
     *
     * @since 2.3.0
     */

<span id='Ext-container-Container-cfg-autoDestroy'>    /**
</span>     * @cfg {Boolean} [autoDestroy=true]
     * If true the container will automatically destroy any contained component that is removed
     * from it, else destruction must be handled manually.
     * @since 2.3.0
     */
    autoDestroy: true,

<span id='Ext-container-Container-cfg-bubbleEvents'>    /**
</span>     * @cfg {String[]} bubbleEvents
     * An array of events that, when fired, should be bubbled to any parent container.
     * See {@link Ext.util.Observable#enableBubble}.
     * @since 3.4.0
     */

<span id='Ext-container-Container-cfg-defaults'>    /**
</span>     * @cfg {Object/Function} defaults
     * This option is a means of applying default settings to all added items whether added
     * through the {@link #cfg-items} config or via the {@link #method-add} or {@link #insert} methods.
     *
     * Defaults are applied to both config objects and instantiated components conditionally
     * so as not to override existing properties in the item (see {@link Ext#applyIf}).
     *
     * If the defaults option is specified as a function, then the function will be called
     * using this Container as the scope (`this` reference) and passing the added item as
     * the first parameter. Any resulting object from that call is then applied to the item
     * as default properties.
     *
     * For example, to automatically apply padding to the body of each of a set of
     * contained {@link Ext.panel.Panel} items, you could pass:
     * `defaults: {bodyStyle:&#39;padding:15px&#39;}`.
     *
     * Usage:
     *
     *     defaults: { // defaults are applied to items, not the container
     *         autoScroll: true
     *     },
     *     items: [
     *         // default will not be applied here, panel1 will be autoScroll: false
     *         {
     *             xtype: &#39;panel&#39;,
     *             id: &#39;panel1&#39;,
     *             autoScroll: false
     *         },
     *         // this component will have autoScroll: true
     *         new Ext.panel.Panel({
     *             id: &#39;panel2&#39;
     *         })
     *     ]
     *
     * @since 2.3.0
     */

<span id='Ext-container-Container-cfg-defaultType'>     /**
</span>      * @cfg {String} [defaultType=&quot;panel&quot;]
      * The default {@link Ext.Component xtype} of child Components to create in this Container when
      * a child item is specified as a raw configuration object, rather than as an instantiated Component.
      * @since 2.3.0
      */
    defaultType: &#39;panel&#39;,

<span id='Ext-container-Container-cfg-detachOnRemove'>    /**
</span>     * @cfg {Boolean} [detachOnRemove=true]
     * True to move any component to the {@link Ext#getDetachedBody detachedBody} when the component is
     * removed from this container. This option is only applicable when the component is not destroyed while
     * being removed, see {@link #autoDestroy} and {@link #method-remove}. If this option is set to false, the DOM
     * of the component will remain in the current place until it is explicitly moved.
     */
    detachOnRemove: true,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultTypeProperty: &quot;defaultType&quot;, defaultsProperty: &quot;defaults&quot;}
<span id='Ext-container-Container-cfg-items'>    /**
</span>     * @cfg {Object/Object[]} items
     * A single item, or an array of child Components to be added to this container
     *
     * **Unless configured with a {@link #layout}, a Container simply renders child
     * Components serially into its encapsulating element and performs no sizing or
     * positioning upon them.**
     *
     * Example:
     *
     *     // specifying a single item
     *     items: {...},
     *     layout: &#39;fit&#39;,    // The single items is sized to fit
     *
     *     // specifying multiple items
     *     items: [{...}, {...}],
     *     layout: &#39;hbox&#39;, // The items are arranged horizontally
     *
     * Each item may be:
     *
     * - A {@link Ext.Component Component}
     * - A Component configuration object
     *
     * If a configuration object is specified, the actual type of Component to be
     * instantiated my be indicated by using the {@link Ext.Component#xtype xtype} option.
     *
     * Every Component class has its own {@link Ext.Component#xtype xtype}.
     *
     * If an {@link Ext.Component#xtype xtype} is not explicitly specified, the
     * {@link #defaultType} for the Container is used, which by default is usually `panel`.
     *
     * # Notes:
     *
     * Ext uses lazy rendering. Child Components will only be rendered
     * should it become necessary. Items are automatically laid out when they are first
     * shown (no sizing is done while hidden), or in response to a {@link #doLayout} call.
     *
     * Do not specify {@link Ext.panel.Panel#contentEl contentEl} or
     * {@link Ext.panel.Panel#html html} with `items`.
     *
     * @since 2.3.0
     */
    items: undefined,  // Not &quot;null&quot; so that Ext.applyIf(this, {items: []}) works

    // @cmd-auto-dependency { aliasPrefix : &quot;layout.&quot; }
<span id='Ext-container-Container-cfg-layout'>    /**
</span>     * @cfg {Ext.enums.Layout/Object} layout
     * **Important**: In order for child items to be correctly sized and
     * positioned, typically a layout manager **must** be specified through
     * the `layout` configuration option.
     *
     * The sizing and positioning of child {@link #cfg-items} is the responsibility of
     * the Container&#39;s layout manager which creates and manages the type of layout
     * you have in mind.  For example:
     *
     * If the layout configuration is not explicitly specified for
     * a general purpose container (e.g. Container or Panel) the
     * {@link Ext.layout.container.Auto default layout manager} will be used
     * which does nothing but render child components sequentially into the
     * Container (no sizing or positioning will be performed in this situation).
     *
     * **layout** may be specified as either as an Object or as a String:
     *
     * ## Specify as an Object
     *
     * Example usage:
     *
     *     layout: {
     *         type: &#39;vbox&#39;,
     *         align: &#39;left&#39;
     *     }
     *
     *   - **type**
     *
     *     The layout type to be used for this container.  If not specified,
     *     a default {@link Ext.layout.container.Auto} will be created and used.
     *
     *     Valid layout &lt;code&gt;type&lt;/code&gt; values are listed in {@link Ext.enums.Layout}.
     *
     *   - Layout specific configuration properties
     *
     *     Additional layout specific configuration properties may also be
     *     specified. For complete details regarding the valid config options for
     *     each layout type, see the layout class corresponding to the `type`
     *     specified.
     *
     * ## Specify as a String
     *
     * Example usage:
     *
     *     layout: &#39;vbox&#39;
     *
     *   - **layout**
     *
     *     The layout `type` to be used for this container (see {@link Ext.enums.Layout}
     *     for list of valid values).
     *
     *     Additional layout specific configuration properties. For complete
     *     details regarding the valid config options for each layout type, see the
     *     layout class corresponding to the `layout` specified.
     *
     * ## Configuring the default layout type
     *
     * If a certain Container class has a default layout (For example a {@link Ext.toolbar.Toolbar Toolbar}
     * with a default `Box` layout), then to simply configure the default layout,
     * use an object, but without the `type` property:
     *
     *
     *     xtype: &#39;toolbar&#39;,
     *     layout: {
     *         pack: &#39;center&#39;
     *     }
     *
     * @since 2.3.0
     * 
     */
    layout: &#39;auto&#39;,

<span id='Ext-container-Container-cfg-suspendLayout'>    /**
</span>     * @cfg {Boolean} suspendLayout
     * If true, suspend calls to doLayout. Useful when batching multiple adds to a container
     * and not passing them as multiple arguments or an array.
     */
    suspendLayout: false,

<span id='Ext-container-Container-cfg-referenceHolder'>    /**
</span>     * @cfg {Boolean} referenceHolder
     * If `true`, this container will be marked as being a point in the hierarchy where
     * references to items with a specified `reference` config will be held. The container
     * will automatically become a referenceHolder if a {@link #controller} is specified.
     *
     * See the introductory docs for {@link Ext.container.Container} for more information
     * about references &amp; reference holders.
     */

    // ***********************************************************************************
    // End Config
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    // &lt;editor-fold desc=&quot;Properties&quot;&gt;
    // ***********************************************************************************
    // Begin Properties
    // ***********************************************************************************

<span id='Ext-container-Container-property-_applyDefaultsOptions'>    // private
</span>    _applyDefaultsOptions: {
        defaults: true,
        strict: false
    },

<span id='Ext-container-Container-property-ariaRole'>    ariaRole: &#39;presentation&#39;,
</span>
<span id='Ext-container-Container-cfg-baseCls'>    baseCls: Ext.baseCSSPrefix + &#39;container&#39;,
</span>
<span id='Ext-container-Container-property-layoutCounter'>    /**
</span>     * @property {Number} layoutCounter
     * The number of container layout calls made on this object.
     * @private
     */
    layoutCounter: 0,
    
    // ***********************************************************************************
    // End Properties
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    // &lt;editor-fold desc=&quot;Events&quot;&gt;
    // ***********************************************************************************
    // Begin Events
    // ***********************************************************************************

<span id='Ext-container-Container-event-add'>    /**
</span>     * @event add
     * Fires after any {@link Ext.Component} is added or inserted into the container.
     * 
     * **This event bubbles:** &#39;add&#39; will also be fired when Component is added to any of
     * the child containers or their childern or ...
     * @param {Ext.container.Container} this
     * @param {Ext.Component} component The component that was added
     * @param {Number} index The index at which the component was added to the container&#39;s items collection
     * @since 2.3.0
     */

<span id='Ext-container-Container-event-afterlayout'>    /**
</span>     * @event afterlayout
     * Fires when the components in this container are arranged by the associated layout manager.
     * @param {Ext.container.Container} this
     * @param {Ext.layout.container.Container} layout The ContainerLayout implementation for this container
     * @since 2.3.0
     */

<span id='Ext-container-Container-event-beforeadd'>    /**
</span>     * @event beforeadd
     * Fires before any {@link Ext.Component} is added or inserted into the container.
     * A handler can return false to cancel the add.
     * @param {Ext.container.Container} this
     * @param {Ext.Component} component The component being added
     * @param {Number} index The index at which the component will be added to the container&#39;s items collection
     * @since 2.3.0
     */

<span id='Ext-container-Container-event-beforeremove'>    /**
</span>     * @event beforeremove
     * Fires before any {@link Ext.Component} is removed from the container.  A handler can return
     * false to cancel the remove.
     * @param {Ext.container.Container} this
     * @param {Ext.Component} component The component being removed
     * @since 2.3.0
     */

<span id='Ext-container-Container-event-remove'>    /**
</span>     * @event remove
     * Fires after any {@link Ext.Component} is removed from the container.
     *
     * **This event bubbles:** &#39;remove&#39; will also be fired when Component is removed from any of
     * the child containers or their children or ...
     * @param {Ext.container.Container} this
     * @param {Ext.Component} component The component that was removed
     * @since 2.3.0
     */

<span id='Ext-container-Container-event-move'>    /**
</span>     * @event move
     * Fires after any {@link Ext.Component} has changed its ordinal position within the container.
     *
     * **This event bubbles:** &#39;move&#39; will also be fired when Component is removed from any of
     * the child containers or their children or ...
     * @param {Ext.container.Container} this
     * @param {Ext.Component} component The component that was moved
     * @param {Ext.Component} prevIndex The previous ordinal position of the Component
     * @param {Ext.Component} newIndex The new ordinal position of the Component
     */

    // ***********************************************************************************
    // End Events
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    // &lt;editor-fold desc=&quot;Methods&quot;&gt;
    // ***********************************************************************************
    // Begin Methods
    // ***********************************************************************************

<span id='Ext-container-Container-method-add'>    /**
</span>     * Adds {@link Ext.Component Component}(s) to this Container.
     *
     * ## Description:
     *
     * - Fires the {@link #beforeadd} event before adding.
     * - The Container&#39;s {@link #defaults default config values} will be applied
     *   accordingly (see `{@link #defaults}` for details).
     * - Fires the `{@link #event-add}` event after the component has been added.
     *
     * ## Notes:
     *
     * If the Container is __already rendered__ when `add`
     * is called, it will render the newly added Component into its content area.
     *
     * **If** the Container was configured with a size-managing {@link #layout} manager,
     * the Container will recalculate its internal layout at this time too.
     *
     * Note that the default layout manager simply renders child Components sequentially
     * into the content area and thereafter performs no sizing.
     *
     * If adding multiple new child Components, pass them as an array to the `add` method,
     * so that only one layout recalculation is performed.
     *
     *     tb = new {@link Ext.toolbar.Toolbar}({
     *         renderTo: document.body
     *     });  // toolbar is rendered
     *     // add multiple items.
     *     // ({@link #defaultType} for {@link Ext.toolbar.Toolbar Toolbar} is &#39;button&#39;)
     *     tb.add([{text:&#39;Button 1&#39;}, {text:&#39;Button 2&#39;}]);
     *
     * To inject components between existing ones, use the {@link #insert} method.
     *
     * ## Warning:
     *
     * Components directly managed by the BorderLayout layout manager may not be removed
     * or added.  See the Notes for {@link Ext.layout.container.Border BorderLayout} for
     * more details.
     *
     * @param {Ext.Component[]|Object[]/Ext.Component.../Object...} component
     * Either one or more Components to add or an Array of Components to add.
     * See `{@link #cfg-items}` for additional information.
     *
     * @return {Ext.Component[]/Ext.Component} The Components that were added.
     *
     * @since 2.3.0
     */
    add: function() {
        var me = this,
            args = Ext.Array.slice(arguments),
            index = (typeof args[0] == &#39;number&#39;) ? args.shift() : -1,
            layout = me.getLayout(),
            needsLayout = false,
            addingArray, items, i, length, item, pos, ret,
            instanced;
            

        if (args.length == 1 &amp;&amp; Ext.isArray(args[0])) {
            items = args[0];
            addingArray = true;
        } else {
            items = args;
        }

        if (me.rendered) {
            Ext.suspendLayouts(); // suspend layouts while adding items...
        }

        ret = items = me.prepareItems(items, true);
        length = items.length;

        if (!addingArray &amp;&amp; length == 1) { // an array of 1 should still return an array...
            ret = items[0];
        }

        // loop
        for (i = 0; i &lt; length; i++) {
            item = items[i];
            //&lt;debug&gt;
            if (!item) {
                Ext.Error.raise(&quot;Cannot add null item to Container with itemId/id: &quot; + me.getItemId());
            }

            if (item.isDestroyed) {
                Ext.Error.raise(&quot;Cannot add destroyed item &#39;&quot; + item.getId() + &quot;&#39; to Container &#39;&quot; + me.getId() + &quot;&#39;&quot;);
            }
            //&lt;/debug&gt;

            pos = (index &lt; 0) ? me.items.length : (index + i);
            instanced = !!item.instancedCmp;
            delete item.instancedCmp;
            // Floating Components are not added into the items collection, but to a separate floatingItems collection
            if (item.floating) {
                me.floatingItems.add(item);
                item.onAdded(me, pos, instanced);
                delete item.initOwnerCt;
                if (me.hasListeners.add) {
                    me.fireEvent(&#39;add&#39;, me, item, pos);
                }
            } else if ((!me.hasListeners.beforeadd || me.fireEvent(&#39;beforeadd&#39;, me, item, pos) !== false) &amp;&amp; me.onBeforeAdd(item) !== false) {
                me.items.insert(pos, item);
                item.onAdded(me, pos, instanced);
                delete item.initOwnerCt;
                me.onAdd(item, pos);
                layout.onAdd(item, pos);

                needsLayout = true;
                if (me.hasListeners.add) {
                    me.fireEvent(&#39;add&#39;, me, item, pos);
                }
            }
        }

        // We need to update our layout after adding all passed items
        // Unless we only added floating items.
        if (needsLayout) {
            me.updateLayout();
        }
        if (me.rendered) {
            Ext.resumeLayouts(true);
        }

        return ret;
    },
    
<span id='Ext-container-Container-method-onAdded'>    onAdded: function(container, pos, instanced) { 
</span>        this.callParent(arguments); 
        // We have been added to a container, we may have child references
        // or be a reference ourself. At this point we have no way of knowing if 
        // our references are correct, so trigger a fix.
        if (instanced) {
            Ext.ComponentManager.markReferencesDirty();
        }     
    },
    
<span id='Ext-container-Container-method-onRemoved'>    onRemoved: function(destroying) {
</span>        var refHolder;
        
        // If we&#39;re destroying this will get cleaned up anyway
        if (!destroying) {
            refHolder = this.lookupReferenceHolder();
            if (refHolder) {
                // Clear any references here, they will be reset after the 
                // next call to lookupReference after being marked dirty.
                // It&#39;s easier to wipe &amp; re-establish them than attempt to 
                // track what changed and prune the collection
                
                Ext.ComponentManager.markReferencesDirty();
                refHolder.clearReferences();
            }
        }
        this.callParent(arguments);
    },

<span id='Ext-container-Container-method-afterComponentLayout'>    afterComponentLayout: function() {
</span>        var floaters = this.floatingItems.items,
            floaterCount = floaters.length,
            i, floater;

        this.callParent(arguments);

        // Contained, unrendered, autoShow items must be shown upon next layout of the Container
        for (i = 0; i &lt; floaterCount; i++) {
            floater = floaters[i];
            if (!floater.rendered &amp;&amp; floater.autoShow) {
                floater.show();
            }
        }
    },

<span id='Ext-container-Container-method-afterLayout'>    /**
</span>     * Invoked after the Container has laid out (and rendered if necessary)
     * its child Components.
     *
     * @param {Ext.layout.container.Container} layout
     *
     * @template
     * @protected
     */
    afterLayout: function(layout) {
        var me = this,
            scrollManager = me.scrollManager;

        ++me.layoutCounter;

        if (scrollManager &amp;&amp; me.layoutCounter &gt; 1) {
            scrollManager.refresh();
        }

        if (me.hasListeners.afterlayout) {
            me.fireEvent(&#39;afterlayout&#39;, me, layout);
        }
    },

<span id='Ext-container-Container-method-onDestroy'>    onDestroy: function() {
</span>        this.callParent();
        this.refs = null;
    },

<span id='Ext-container-Container-method-beforeDestroy'>    beforeDestroy: function() {
</span>        var me = this,
            items = me.items,
            floatingItems = me.floatingItems,
            c;

        if (items) {
            while ((c = items.first())) {
                me.doRemove(c, true);
            }
        }

        if (floatingItems) {
            while ((c = floatingItems.first())) {
                me.doRemove(c, true);
            }
        }

        Ext.destroy(
            me.layout
        );
        me.callParent();
    },

<span id='Ext-container-Container-method-beforeRender'>    beforeRender: function () {
</span>        var me = this,
            layout = me.getLayout(),
            targetCls;

        me.callParent();

        if (!layout.initialized) {
            layout.initLayout();
        }

        targetCls = layout.targetCls;

        if (targetCls) {
            me.applyTargetCls(targetCls);
        }
    },

<span id='Ext-container-Container-method-cascade'>    /**
</span>     * Cascades down the component/container heirarchy from this component (passed in
     * the first call), calling the specified function with each component. The scope
     * (this reference) of the function call will be the scope provided or the current
     * component. The arguments to the function will be the args provided or the current
     * component. If the function returns false at any point, the cascade is stopped on
     * that branch.
     * @param {Function} fn The function to call
     * @param {Object} [scope] The scope of the function (defaults to current component)
     * @param {Array} [args] The args to call the function with. The current component
     * always passed as the last argument.
     * @return {Ext.Container} this
     * @since 2.3.0
     */
    cascade: function(fn, scope, origArgs){
        var me = this,
            cs = me.items ? me.items.items : [],
            len = cs.length,
            i = 0,
            c,
            args = origArgs ? origArgs.concat(me) : [me],
            componentIndex = args.length - 1;

        if (fn.apply(scope || me, args) !== false) {
            for (; i &lt; len; i++){
                c = cs[i];
                if (c.cascade) {
                    c.cascade(fn, scope, origArgs);
                } else {
                    args[componentIndex] = c;
                    fn.apply(scope || c, args);
                }
            }
        }
        return this;
    },

<span id='Ext-container-Container-method-contains'>    /**
</span>     * Determines whether the passed Component is either an immediate child of this Container,
     * or whether it is a descendant.
     *
     * @param {Ext.Component} comp The Component to test.
     * @param {Boolean} [deep=false] Pass `true` to test for the Component being a descendant at any level.
     * @return {Boolean} `true` if the passed Component is contained at the specified level.
     */
    contains: function(comp, deep) {
        var result = false;
        if (deep) {
            this.cascade(function(c) {
                // Only test if the item is a container
                if (c.contains &amp;&amp; c.contains(comp)) {
                    result = true;
                    return false;
                }
            });
            return result;
        } else {
            return this.items.contains(comp) || this.floatingItems.contains(comp);
        }
    },

<span id='Ext-container-Container-method-disable'>    /**
</span>     * @override
     * Disables all child input fields and buttons.
     */
    disable: function() {
        this.callParent(arguments);

        var itemsToDisable = this.getChildItemsToDisable(),
            length         = itemsToDisable.length,
            item, i;

        for (i = 0; i &lt; length; i++) {
            item = itemsToDisable[i];

            if (item.resetDisable !== false &amp;&amp; !item.disabled) {
                item.disable();
                item.resetDisable = true;
            }
        }

        return this;
    },

<span id='Ext-container-Container-method-doLayout'>    /**
</span>     * Manually force this container&#39;s layout to be recalculated.
     * @return {Ext.container.Container} this
     * @since 2.3.0
     * @deprecated 4.1 Use `{@link #updateLayout}` instead.
     */
    doLayout: function() {
        this.updateLayout();
        return this;
    },

<span id='Ext-container-Container-method-enable'>    /**
</span>     * @override
     * Enables all child input fields and buttons.
     */
    enable: function() {
        this.callParent(arguments);

        var itemsToDisable = this.getChildItemsToDisable(),
            length         = itemsToDisable.length,
            item, i;

        for (i = 0; i &lt; length; i++) {
            item = itemsToDisable[i];

            if (item.resetDisable) {
                item.enable();
            }
        }

        return this;
    },

<span id='Ext-container-Container-method-getChildByElement'>    /**
</span>     * Return the immediate child Component in which the passed element is located.
     * @param {Ext.dom.Element/HTMLElement/String} el The element to test (or ID of element).
     * @param {Boolean} deep If `true`, returns the deepest descendant Component which contains the passed element.
     * @return {Ext.Component} The child item which contains the passed element.
     */
    getChildByElement: function(el, deep) {
        var item,
            itemEl,
            i = 0,
            it = this.getRefItems(),
            ln = it.length;

        el = Ext.getDom(el);
        for (; i &lt; ln; i++) {
            item = it[i];
            itemEl = item.getEl();
            if (itemEl &amp;&amp; ((itemEl.dom === el) || itemEl.contains(el))) {
                return (deep &amp;&amp; item.getChildByElement) ? item.getChildByElement(el, deep) : item;
            }
        }
        return null;
    },

<span id='Ext-container-Container-method-getComponent'>    /**
</span>     * Examines this container&#39;s {@link #property-items} **property** and gets a direct child
     * component of this container.
     *
     * @param {String/Number} comp This parameter may be any of the following:
     *
     * - a **String** : representing the {@link Ext.Component#itemId itemId}
     *   or {@link Ext.Component#id id} of the child component.
     * - a **Number** : representing the position of the child component
     *   within the {@link #property-items} **property**
     *
     * For additional information see {@link Ext.util.MixedCollection#get}.
     *
     * @return {Ext.Component} The component (if found).
     *
     * @since 2.3.0
     */
    getComponent: function(comp) {
        if (Ext.isObject(comp)) {
            comp = comp.getItemId();
        }

        var c = this.items.get(comp);

        // Only allow finding by index on the main items container
        if (!c &amp;&amp; typeof comp != &#39;number&#39;) {
            c = this.floatingItems.get(comp);
        }

        return c;
    },

<span id='Ext-container-Container-method-getLayout'>    /**
</span>     * Returns the {@link Ext.layout.container.Container layout} instance currently associated with this Container.
     * If a layout has not been instantiated yet, that is done first
     * @return {Ext.layout.container.Container} The layout
     */
    getLayout: function() {
        var me = this,
            layout = me.layout;

        if (!layout || !layout.isLayout) {
            me.setLayout(layout);
        }

        return me.layout;
    },

<span id='Ext-container-Container-method-getRefItems'>    /**
</span>     * @protected
     * Used by {@link Ext.ComponentQuery ComponentQuery}, {@link #child} and {@link #down} to retrieve all of the items
     * which can potentially be considered a child of this Container.
     *
     * This may be overriden by Components which have ownership of Components
     * that are not contained in the {@link #property-items} collection.
     *
     * NOTE: IMPORTANT note for maintainers:
     * Items are returned in tree traversal order. Each item is appended to the result array
     * followed by the results of that child&#39;s getRefItems call.
     * Floating child items are appended after internal child items.
     */
    getRefItems: function(deep) {
        var me = this,
            items = me.items.items,
            len = items.length,
            i = 0,
            item,
            result = [];

        for (; i &lt; len; i++) {
            item = items[i];
            result[result.length] = item;
            if (deep &amp;&amp; item.getRefItems) {
                result.push.apply(result, item.getRefItems(true));
            }
        }

        // Append floating items to the list.
        items = me.floatingItems.items;
        len = items.length;
        for (i = 0; i &lt; len; i++) {
            item = items[i];
            result[result.length] = item;
            if (deep &amp;&amp; item.getRefItems) {
                result.push.apply(result, item.getRefItems(true));
            }
        }

        return result;
    },

<span id='Ext-container-Container-method-initComponent'>    initComponent: function(){
</span>        var me = this;

        me.callParent();

        me.getLayout();
        // Set a flag to say we&#39;re constructing children, can be useful
        // to know during construction time to save work
        me.constructing = true;

        me.initItems();

        delete me.constructing;
    },

<span id='Ext-container-Container-method-getReferences'>    /**
</span>     * Returns an object holding the descendants of this view keyed by their
     * `{@link Ext.Component#cfg-reference reference}`. This object should not be held
     * past the scope of the function calling this method. It will not be valid if items
     * are added or removed from this or any sub-container.
     *
     * The intended usage is shown here (assume there are 3 components with reference
     * values of &quot;foo&quot;, &quot;bar&quot; and &quot;baz&quot; at some level below this container):
     *
     *      onClick: function () {
     *          var refs = this.getReferences();
     *
     *          // using &quot;refs&quot; we can access any descendant by its &quot;reference&quot;
     *
     *          refs.foo.getValue() + refs.bar.getValue() + refs.baz.getValue();
     *      }
     *
     * If `this` component has a `{@link Ext.Component#cfg-reference reference}` assigned
     * to it, that is **not** included in this object. That reference is understood to
     * belong to the ancestor container configured as the `referenceHolder`.
     *
     * @return {Object} An object with each child reference. This will be `null` if this
     * container has no descendants with a `{@link Ext.Component#cfg-reference reference}`
     * specified.
     * @since 5.0.0
     */
    getReferences: function () {
        var ComponentManager = Ext.ComponentManager;

        if (ComponentManager.referencesDirty) {
            ComponentManager.fixReferences();
        }

        return this.refs || null;
    },

<span id='Ext-container-Container-method-lookupReference'>    /**
</span>     * Gets a reference to a child specified using the {@link #reference} configuration.
     *
     * @param {String} key The name of the reference.
     * @return {Ext.Component} The referenced component or `null` if it is not found.
     */
    lookupReference: function (key) {
        var refs = this.getReferences();

        return (refs &amp;&amp; refs[key]) || null;
    },

<span id='Ext-container-Container-method-initItems'>    /**
</span>     * This method is called to initialize the `items` collection. A derived class can
     * override this method to do any last minute manipulation of `items` and then call
     * this method using `callParent`. Upon return, the `items` will no longer be a simple
     * array.
     * @protected
     */
    initItems: function() {
        var me = this,
            items = me.items;

        if (!items || !items.isMixedCollection) {
            // allow the items collection to be pre-initialized.
            // (used by Ext.draw.ComponentBase)
<span id='Ext-container-Container-property-items'>            /**
</span>             * The MixedCollection containing all the child items of this container.
             * @property items
             * @type Ext.util.AbstractMixedCollection
             * @since 2.3.0
             */
            me.items = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
            me.floatingItems = new Ext.util.MixedCollection(false, me.getComponentId);

            if (items) {
                if (!Ext.isArray(items)) {
                    items = [items];
                }

                me.add(items);
            }
        }
    },

<span id='Ext-container-Container-method-initInheritedState'>    /**
</span>     * Called by `getInherited` to initialize the inheritedState the first time it is
     * requested.
     * @protected
     */
    initInheritedState: function (inheritedState, inheritedStateInner) {
        var me = this,
            controller = me.controller,
            layout = me.layout,
            session = me.session,
            // Don&#39;t instantiate it here, we just want to know whether we
            // were configured with a VM
            viewModel = me.viewModel,
            reference = me.reference,
            referenceHolder = me.referenceHolder;

        me.callParent([ inheritedState, inheritedStateInner ]);
        
        if (me.collapsed) {
            inheritedState.collapsed = true;
        }

        if (controller) {
            inheritedState.referenceHolder = controller;
            referenceHolder = true;
        } else if (referenceHolder) {
            inheritedState.referenceHolder = me;
        }

        if (referenceHolder) {
            inheritedState.referencePath = &#39;&#39;;
        } else if (reference &amp;&amp; me.isParentReference) {
            inheritedState.referencePath = me.referenceKey + &#39;.&#39;;
        }

        if (session) {
            inheritedState.session = session;
        }

        if (viewModel) {
            inheritedState.viewModelPath = &#39;&#39;;
        } else if (reference &amp;&amp; me.isParentReference) {
            inheritedState.viewModelPath = me.viewModelKey + &#39;.&#39;;
        }

        if (layout &amp;&amp; layout.initInheritedState) {
            layout.initInheritedState(inheritedState, inheritedStateInner);
        }
    },

<span id='Ext-container-Container-method-insert'>    /**
</span>     * Inserts a Component into this Container at a specified index. Fires the
     * {@link #beforeadd} event before inserting, then fires the {@link #event-add}
     * event after the Component has been inserted.
     *
     * @param {Number} index The index at which the Component will be inserted
     * into the Container&#39;s items collection
     *
     * @param {Ext.Component/Object/Ext.Component[]/Object[]} component The child Component or config object to insert.
     *
     * Ext uses lazy rendering, and will only render the inserted Component should
     * it become necessary.
     *
     * A Component config object may be passed in order to avoid the overhead of
     * constructing a real Component object if lazy rendering might mean that the
     * inserted Component will not be rendered immediately. To take advantage of
     * this &#39;lazy instantiation&#39;, set the {@link Ext.Component#xtype} config
     * property to the registered type of the Component wanted.
     *
     * You can pass an array of Component instances and config objects.
     *
     * For a list of all available xtypes, see {@link Ext.enums.Widget}.
     *
     * @return {Ext.Component} component The Component (or config object) that was
     * inserted with the Container&#39;s default config values applied.
     *
     * @since 2.3.0
     */
    insert: function(index, component) {
        var compIdx;
        if (component &amp;&amp; component.isComponent) {
            compIdx = this.items.indexOf(component);
            if (compIdx !== -1) {
                return this.move(compIdx, index);
            }
        }
        return this.add(index, component);
    },

<span id='Ext-container-Container-method-isAncestor'>    /**
</span>     * Determines whether **this Container** is an ancestor of the passed Component.
     * This will return `true` if the passed Component is anywhere within the subtree
     * beneath this Container.
     * @param {Ext.Component} possibleDescendant The Component to test for presence
     * within this Container&#39;s subtree.
     */
    isAncestor: function(possibleDescendant) {
        while (possibleDescendant) {
            if (possibleDescendant.ownerCt === this) {
                return true;
            }
            possibleDescendant = possibleDescendant.ownerCt;
        }
    },

<span id='Ext-container-Container-method-lookupComponent'>    // @private
</span>    lookupComponent: function(comp) {
        if (!comp.isComponent) {
            if (typeof comp === &#39;string&#39;) {
                comp = Ext.ComponentManager.get(comp);
            } else {
                comp = Ext.ComponentManager.create(comp, this.defaultType);       
            }
        }
        return comp;
    },

<span id='Ext-container-Container-method-move'>    /**
</span>     * Moves a Component within the Container. This method does **not** account for things
     * like splitter components added by a layout. To better handle these situations, it
     * is recommended to use `{@link #moveBefore}` or `{@link moveAfter}` instead.
     *
     * @param {Number/Ext.Component} fromIdx The index/component to move.
     * @param {Number} toIdx The new index for the Component.
     * @return {Ext.Component} component The Component that was moved.
     * @deprecated 5.0 Use `{@link #moveBefore}` or `{@link moveAfter}` instead.
     */
    move: function(fromIdx, toIdx) {
        var me = this,
            items = me.items,
            item;

        if (fromIdx.isComponent) {
            fromIdx = items.indexOf(fromIdx);
        }
        item = items.getAt(fromIdx);
        if (fromIdx !== toIdx) {
            item = items.removeAt(fromIdx);
            if (item === false) {
                return false;
            }
            items.insert(toIdx, item);
            me.onMove(item, fromIdx, toIdx);
            if (me.hasListeners.move) {
                me.fireEvent(&#39;move&#39;, me, item, fromIdx, toIdx);
            }
            me.updateLayout();
        }
        return item;
    },

<span id='Ext-container-Container-method-moveBefore'>    /**
</span>     * Moves the given `item` into this container in front of `before`. This method will
     * account for layout-generated components like splitters and should be used instead
     * of index based `{@link #move}`. If `before` is `null` then the `item` will be the
     * last item in this container.
     * @param {Object/Ext.Component} item The item to move. May be a component configuration object.
     * @param {Ext.Component} before The reference component. May be `null`.
     * @return {Ext.Component} The moved item.
     * @since 5.0.0
     */
    moveBefore: function (item, before) {
        return this.layout.moveItemBefore(item, before);
    },

<span id='Ext-container-Container-method-moveAfter'>    /**
</span>     * Moves the given `item` into this container following `after`. This method will
     * account for layout-generated components like splitters and should be used instead
     * of index based `{@link #move}`. If `after` is `null` then the `item` will be the
     * first item in this container.
     * @param {Ext.Component} item The item to move. May be a component configuration object.
     * @param {Ext.Component} after The reference component. May be `null`.
     * @return {Ext.Component} The moved item.
     * @since 5.0.0
     */
    moveAfter: function (item, after) {
        var me = this,
            items = me.items,
            layout = me.layout,
            index = after ? layout.getMoveAfterIndex(after) : 0,
            before = items.getAt(index);
        
        return layout.moveItemBefore(item, before);
    },

<span id='Ext-container-Container-method-nextChild'>    /**
</span>     * A method to find a child component after the passed child parameter. If a selector is also provided,
     * the first child component matching the selector will be returned.
     *
     * @param {Ext.Component} child The child to use as a starting point to find the next child.
     * @param {String} [selector] A {@link Ext.ComponentQuery} selector to find the next child. This will return the next child matching this selector. This parameter is optional.
     * @returns {Ext.Component} The next child found, `null` if no child found.
     */
    nextChild: function(child, selector) {
        var me = this,
            items = me.items,
            childIndex = items.indexOf(child),
            i = 0,
            len = items.length,
            result;

        if (childIndex !== -1) {
            if (selector) {
                for (; i &lt; len; i++) {
                    result = items.getAt(childIndex + i);

                    if (!result || Ext.ComponentQuery.is(result, selector)) {
                        break;
                    }
                }
            } else {
                result = items.getAt(childIndex + 1);
            }

            if (!result &amp;&amp; me.ownerCt) {
                result = me.ownerCt.nextChild(me, selector);
            }
        }
        return result;
    },

<span id='Ext-container-Container-method-onAdd'>    /**
</span>     * This method is invoked after a new Component has been added. It
     * is passed the Component which has been added. This method may
     * be used to update any internal structure which may depend upon
     * the state of the child items.
     *
     * @param {Ext.Component} component
     * @param {Number} position
     *
     * @template
     * @protected
     */
    onAdd: Ext.emptyFn,

<span id='Ext-container-Container-method-onBeforeAdd'>    /**
</span>     * This method is invoked before adding a new child Component. It
     * is passed the new Component, and may be used to modify the
     * Component, or prepare the Container in some way. Returning
     * false aborts the add operation.
     *
     * @param {Ext.Component} item
     *
     * @template
     * @protected
     */
    onBeforeAdd: function(item) {
        // Remove from current container if it&#39;s not us.
        var owner = item.ownerCt;
        if (owner &amp;&amp; owner !== this) {
            owner.remove(item, false);
        }
    },

<span id='Ext-container-Container-method-onMove'>    onMove: Ext.emptyFn,
</span>
<span id='Ext-container-Container-method-onRemove'>    /**
</span>     * This method is invoked after a new Component has been
     * removed. It is passed the Component which has been
     * removed. This method may be used to update any internal
     * structure which may depend upon the state of the child items.
     *
     * @param {Ext.Component} component
     * @param {Boolean} autoDestroy
     *
     * @template
     * @protected
     */
    onRemove: Ext.emptyFn,

<span id='Ext-container-Container-method-onPosition'>    onPosition: function() {
</span>        this.callParent(arguments);
        this.repositionFloatingItems();
    },

<span id='Ext-container-Container-method-onResize'>    onResize: function() {
</span>        this.callParent(arguments);
        this.repositionFloatingItems();
    },

<span id='Ext-container-Container-method-prevChild'>    /**
</span>     * A method to find a child component before the passed child parameter. If a selector is also provided,
     * the first child component matching the selector will be returned.
     *
     * @param {Ext.Component} child The child to use as a starting point to find the previous child.
     * @param {String} [selector] A {@link Ext.ComponentQuery} selector to find the previous child. This will return the first child matching this selector. This parameter is optional.
     * @returns {Ext.Component} The previous child found, `null` if no child found.
     */
    prevChild: function(child, selector) {
        var me = this,
            items = me.items,
            childIndex = items.indexOf(child),
            i = 0,
            len = items.length,
            result;

        if (childIndex !== -1) {
            if (selector) {
                for (; i &lt; len; i++) {
                    result = items.getAt(childIndex - i);

                    if (!result || Ext.ComponentQuery.is(result, selector)) {
                        break;
                    }
                }
            } else {
                result = items.getAt(childIndex - 1);
            }

            if (!result &amp;&amp; me.ownerCt) {
                result = me.ownerCt.nextChild(me, selector);
            }
        }
        return result;
    },

<span id='Ext-container-Container-method-remove'>    /**
</span>     * Removes a component from this container.  Fires the {@link #beforeremove} event
     * before removing, then fires the {@link #event-remove} event after the component has
     * been removed.
     *
     * @param {Ext.Component/String} component The component reference or id to remove.
     *
     * @param {Boolean} [autoDestroy] True to automatically invoke the removed Component&#39;s
     * {@link Ext.Component#method-destroy} function.
     *
     * Defaults to the value of this Container&#39;s {@link #autoDestroy} config.
     *
     * @return {Ext.Component} component The Component that was removed.
     * @since 2.3.0
     */
    remove: function(component, autoDestroy) {
        var me = this,
            c = me.getComponent(component);

        //&lt;debug&gt;
        if (!arguments.length) {
            Ext.log.warn(&quot;Ext.container.Container: remove takes an argument of the component to remove. cmp.remove() is incorrect usage.&quot;);
        }
        //&lt;/debug&gt;

        if (c &amp;&amp; (!me.hasListeners.beforeremove || me.fireEvent(&#39;beforeremove&#39;, me, c) !== false)) {
            me.doRemove(c, autoDestroy);
            if (me.hasListeners.remove) {
                me.fireEvent(&#39;remove&#39;, me, c);
            }

            if (!me.destroying &amp;&amp; !c.floating) {
                me.updateLayout();
            }
        }

        return c;
    },

<span id='Ext-container-Container-method-removeAll'>    /**
</span>     * Removes all components from this container.
     * @param {Boolean} [autoDestroy] True to automatically invoke the removed
     * Component&#39;s {@link Ext.Component#method-destroy} function.
     * Defaults to the value of this Container&#39;s {@link #autoDestroy} config.
     * @return {Ext.Component[]} Array of the removed components
     * @since 2.3.0
     */
    removeAll: function(autoDestroy) {
        var me = this,
            removeItems = me.items.items.slice().concat(me.floatingItems.items),
            items = [],
            i = 0,
            len = removeItems.length,
            item;

        // Suspend Layouts while we remove multiple items from the container
        Ext.suspendLayouts();
        me.removingAll = true;
        for (; i &lt; len; i++) {
            item = removeItems[i];
            me.remove(item, autoDestroy);

            if (item.ownerCt !== me) {
                items.push(item);
            }
        }
        me.removingAll = false;
        // Resume Layouts now that all items have been removed and do a single layout (if we removed anything!)
        Ext.resumeLayouts(!!len);
        return items;
    },

<span id='Ext-container-Container-method-setLayout'>    /**
</span>     * Reconfigures the initially configured {@link #layout}.
     *
     * NOTE: this method cannot be used to change the &quot;type&quot; of layout after the component
     * has been rendered to the DOM. After rendering, this method can only modify the
     * existing layout&#39;s configuration properties. The reason for this restriction is that
     * many container layouts insert special wrapping elements into the dom, and the
     * framework does not currently support dynamically changing these elements once
     * rendered.
     * @param {Object} configuration object for the layout
     */
    setLayout: function(layout) {
        var me = this,
            currentLayout = me.layout,
            currentIsLayout = currentLayout &amp;&amp; currentLayout.isLayout,
            protoLayout, type;

        if (typeof layout === &#39;string&#39;) {
            layout = {
                type: layout
            };
        }

        type = layout.type;

        if (currentIsLayout &amp;&amp; (!type || (type === currentLayout.type))) {
            // no type passed, or same type as existing layout - reconfigure current layout
            delete layout.type;
            currentLayout.setConfig(layout);
        } else {
            // no current layout, or different type passed - create new layout
            if (currentIsLayout) {
                currentLayout.setOwner(null);
            }

            protoLayout = me.self.prototype.layout;

            if (typeof protoLayout === &#39;string&#39;) {
                layout.type = type || protoLayout;
            } else {
                // use protoLayout as default values
                Ext.merge(Ext.merge({}, protoLayout), layout);
            }

            layout = this.layout = Ext.Factory.layout(layout);
            layout.setOwner(this);
        }

        if (me.rendered) {
            me.updateLayout();
        }
    },

<span id='Ext-container-Container-method-setActiveItem'>    /**
</span>     * Sets a component as the active layout item. This only applies when using
     * a {@link Ext.layout.container.Card} layout.
     *
     *     var card1 = Ext.create(&#39;Ext.panel.Panel&#39;, {itemId: &#39;card-1&#39;});
     *     var card2 = Ext.create(&#39;Ext.panel.Panel&#39;, {itemId: &#39;card-2&#39;});
     *     var panel = Ext.create(&#39;Ext.panel.Panel&#39;, {
     *         layout: &#39;card&#39;,
     *         items: [card1, card2]
     *     });
     *     // These are all equivalent
     *     panel.getLayout().setActiveItem(card2);
     *     panel.getLayout().setActiveItem(&#39;card-2&#39;);
     *     panel.getLayout().setActiveItem(1);
     *
     * @param {Ext.Component/Number/String} item  The component, component {@link Ext.Component#id id},
     * {@link Ext.Component#itemId itemId}, or index of component.
     * @return {Ext.Component} the activated component or false when nothing activated.
     * False is returned also when trying to activate an already active item.
     */
    setActiveItem: function(item) {
        return this.getLayout().setActiveItem(item);
    },

<span id='Ext-container-Container-property-privates'>    // ***********************************************************************************
</span>    // End Methods
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    privates: {
        // @private
        applyDefaults: function(config) {
            var me = this,
                defaults = me.defaults;

            if (defaults) {
                if (Ext.isFunction(defaults)) {
                    defaults = defaults.call(me, config);
                }

                if (Ext.isString(config)) {
                    config = Ext.ComponentManager.get(config);
                }

                if (config.isComponent) {
                    // If we already have a component instance the best we can do is
                    // conditionally set all the configs in defaults if they have not
                    // yet been set on the component instance.
                    config.setConfig(defaults, null, me._applyDefaultsOptions);
                } else {
                    // If we have a config object (not a component instance) we can do a
                    // full (deep) merge of the config with the defaults object.
                    // Fork the defaults object first so that we don&#39;t modify the original
                    config = me.getConfigurator().merge(me, Ext.Object.fork(defaults), config);
                }
            }
            return config;
        },

        applyReference: function (reference) {
            var len;

            if (reference &amp;&amp; reference.charAt(len = reference.length - 1) === &#39;&gt;&#39;) {
                this.isParentReference = true;
                reference = reference.substring(0, len);
            }

            //&lt;debug&gt;
            if (reference &amp;&amp; !this.validIdRe.test(reference)) {
                Ext.Error.raise(&#39;Invalid reference &quot;&#39; + reference + &#39;&quot; for &#39; + this.getId() +
                    &#39; - not a valid identifier&#39;);
            }
            //&lt;/debug&gt;

            return reference;
        },

        // The targetCls is a CSS class that the layout needs added to the targetEl. The targetEl is where the container&#39;s
        // children are rendered and is usually just the main el. Some containers (e.g. panels) use a body instead.
        //
        // In general, if a class overrides getTargetEl it will also need to override this method. This is necessary to
        // avoid a post-render step to add the targetCls.
        applyTargetCls: function(targetCls) {
            this.addCls(targetCls);
        },

<span id='Ext-container-Container-method-attachReference'>        /**
</span>         * Sets up a component reference.
         * @param {Ext.Component} component The component to reference.
         * @private
         */
        attachReference: function (component) {
            var me = this,
                key, refs;

            // Cleaning all this up later anyway
            if (me.destroying || me.isDestroyed) {
                return;
            }

            refs = me.refs || (me.refs = {});
            key = component.referenceKey;
            //&lt;debug&gt;
            if (refs[key] &amp;&amp; refs[key] !== component) {
                Ext.log.warn(&#39;Duplicate reference: &quot;&#39; + key + &#39;&quot; on &#39; + me.id);
            }
            //&lt;/debug&gt;
            refs[key] = component;
        },

<span id='Ext-container-Container-method-clearReference'>        /**
</span>         * Clear a component reference.
         * @param {Ext.Component} component The component to remove.
         * @private
         */
        clearReference: function (component) {
            var refs = this.refs,
                key = component.referenceKey;

            if (refs &amp;&amp; key) {
                // viewModelKey would be better placed in app.Container however
                // it&#39;s not really worth introducing a second method call to clear
                // a single property.
                component.viewModelKey = component.referenceKey = refs[key] = null;
            }
        },

<span id='Ext-container-Container-method-clearReferences'>        /**
</span>         * Invalidates the references collection. Typically called when
         * removing a container from this container, since it&#39;s difficult
         * to know what references got removed.
         *
         * @private
         */
        clearReferences: function () {
            this.refs = null;
        },

        // Detach a component from the DOM
        detachComponent: function(component){
            Ext.getDetachedBody().appendChild(component.getEl());
        },

        // @private
        doRemove: function(component, doDestroy) {
            // Ensure the flag is set correctly
            doDestroy = doDestroy === true || (doDestroy !== false &amp;&amp; this.autoDestroy);

            var me = this,
                layout = me.layout,
                hasLayout = layout &amp;&amp; me.rendered,

            // isDestroying flag is true if the removal is taking place as part of destruction, OR if removal is intended to *cause* destruction
                isDestroying = component.destroying || doDestroy,
                floating = component.floating;

            if (floating) {
                me.floatingItems.remove(component);
            } else {
                me.items.remove(component);
            }

            // Inform ownerLayout of removal before deleting the ownerLayout &amp; ownerCt references in the onRemoved call
            if (hasLayout &amp;&amp; !floating) {
                // Removing a component from a running layout has to cancel the layout
                if (layout.running) {
                    Ext.Component.cancelLayout(component, isDestroying);
                }
                layout.onRemove(component, isDestroying);
            }

            component.onRemoved(isDestroying);

            me.onRemove(component, isDestroying);

            // Destroy if we were explicitly told to, or we&#39;re defaulting to our autoDestroy configuration
            if (doDestroy) {
                component.destroy();
            }
            // Only have the layout perform remove postprocessing if the Component is not being destroyed
            else {
                if (hasLayout &amp;&amp; !floating) {
                    layout.afterRemove(component);
                }
                if (me.detachOnRemove &amp;&amp; component.rendered) {
                    me.detachComponent(component);
                }
            }
        },

        finishRenderChildren: function () {
            this.callParent();

            var layout = this.getLayout();

            if (layout) {
                layout.finishRender();
            }
        },

<span id='Ext-container-Container-method-getChildItemsToDisable'>        /**
</span>         * Gets a list of child components to enable/disable when the container is
         * enabled/disabled
         * @private
         * @return {Ext.Component[]} Items to be enabled/disabled
         */
        getChildItemsToDisable: function(){
            return this.query(&#39;[isFormField],button&#39;);
        },

        // @private - used as the key lookup function for the items collection
        getComponentId: function(comp) {
            return comp.getItemId &amp;&amp; comp.getItemId();
        },

        // @private
        getContentTarget: function(){
            return this.getLayout().getContentTarget();
        },

        // @private
        getDefaultContentTarget: function() {
            return this.el;
        },

<span id='Ext-container-Container-method-getFocusEl'>        /**
</span>         * @private
         * Returns the focus holder element associated with this Container. By default, this is the Container&#39;s target
         * element. Subclasses which use embedded focusable elements (such as Window and Button) should override this for use
         * by the {@link #method-focus} method.
         * @returns {Ext.dom.Element} the focus holding element.
         */
        getFocusEl: function() {
            return this.getTargetEl();
        },

        getScrollerEl: function() {
            return this.layout.getScrollerEl() || this.callParent();
        },

        // @private
        prepareItems: function(items, applyDefaults) {
            // Create an Array which does not refer to the passed array.
            // The passed array is a reference to a user&#39;s config object and MUST NOT be mutated.
            if (Ext.isArray(items)) {
                items = items.slice();
            } else {
                items = [items];
            }

            // Make sure defaults are applied and item is initialized
            var me = this,
                i = 0,
                len = items.length,
                item;

            for (; i &lt; len; i++) {
                item = items[i];
                if (item == null) {
                    Ext.Array.erase(items, i, 1);
                    --i;
                    --len;
                } else {
                    if (applyDefaults) {
                        item = this.applyDefaults(item);
                    }

                    // Tell the item we&#39;re in a container during construction
                    item.initOwnerCt = me;
                    if (item.isComponent) {
                        // When this was passed to us, it&#39;s an already constructed component
                        // This is useful to know because we can make decisions regarding the
                        // state of the component if it&#39;s newly created
                        item.instancedCmp = true;
                    }
                    items[i] = me.lookupComponent(item);
                    // delete here because item may have been a config, so we don&#39;t
                    // want to mutate it
                    delete item.initOwnerCt;
                }
            }

            return items;
        },

        repositionFloatingItems: function() {
            var floaters = this.floatingItems.items,
                floaterCount = floaters.length,
                i, floater;

            // Ensure correct positioning of floated children before calling superclass
            for (i = 0; i &lt; floaterCount; i++) {
                floater = floaters[i];
                if (floater.el &amp;&amp; !floater.hidden) {
                    floater.setPosition(floater.x, floater.y);
                }
            }
        },

        _noMargin: {
            &#39;margin-top&#39;: &#39;&#39;,
            &#39;margin-right&#39;: &#39;&#39;,
            &#39;margin-bottom&#39;: &#39;&#39;,
            &#39;margin-left&#39;: &#39;&#39;
        },

        // Removes inline margins set by the layout system (see ContextItem#getMarginInfo)
        // TODO: fix EXTJS-13359 and remove this method
        resetItemMargins: function() {
            var items = this.items.items,
                i = items.length,
                noMargin = this._noMargin,
                item;

            while (i--) {
                item = items[i];
                item.margin$ = null;
                item.el.setStyle(noMargin);
            }
        },

        setupRenderTpl: function (renderTpl) {
            this.callParent(arguments);
            this.getLayout().setupRenderTpl(renderTpl);
        }
    } // private
});
</pre>
</body>
</html>
