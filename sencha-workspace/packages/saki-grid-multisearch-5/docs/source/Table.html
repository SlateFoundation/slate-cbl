<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-panel-Table'>/**
</span> * This class is the base class for both {@link Ext.tree.Panel TreePanel} and
 * {@link Ext.grid.Panel GridPanel}.
 *
 * TablePanel aggregates:
 *
 *  - a Selection Model
 *  - a View
 *  - a Store
 *  - Ext.grid.header.Container
 */
Ext.define(&#39;Ext.panel.Table&#39;, {
    extend: &#39;Ext.panel.Panel&#39;,

    alias: &#39;widget.tablepanel&#39;,
    
    requires: [
        &#39;Ext.layout.container.Fit&#39;
    ],

    uses: [
        &#39;Ext.selection.RowModel&#39;,
        &#39;Ext.selection.CellModel&#39;,
        &#39;Ext.selection.CheckboxModel&#39;,
        &#39;Ext.grid.plugin.BufferedRenderer&#39;,
        &#39;Ext.grid.header.Container&#39;,
        &#39;Ext.grid.locking.Lockable&#39;,
        &#39;Ext.grid.NavigationModel&#39;
    ],

<span id='Ext-panel-Table-property-extraBaseCls'>    extraBaseCls: Ext.baseCSSPrefix + &#39;grid&#39;,
</span><span id='Ext-panel-Table-property-extraBodyCls'>    extraBodyCls: Ext.baseCSSPrefix + &#39;grid-body&#39;,
</span>
<span id='Ext-panel-Table-property-defaultBindProperty'>    defaultBindProperty: &#39;store&#39;,
</span>
<span id='Ext-panel-Table-property-layout'>    layout: &#39;fit&#39;,
</span>    
<span id='Ext-panel-Table-property-ariaRole'>    ariaRole: &#39;grid&#39;,
</span>
    config: {
<span id='Ext-panel-Table-cfg-selection'>        selection: null
</span>    },

<span id='Ext-panel-Table-property-publishes'>    publishes: [&#39;selection&#39;],
</span><span id='Ext-panel-Table-property-twoWayBindable'>    twoWayBindable: [&#39;selection&#39;],
</span>
<span id='Ext-panel-Table-cfg-autoLoad'>    /**
</span>     * @cfg [autoLoad=false]
     * Use `true` to load the store as soon as this component is fully constructed. It is
     * best to initiate the store load this way to allow this component and potentially
     * its plugins (such as `{@link Ext.grid.filters.Filters}` to be ready to load.
     */
    autoLoad: false,

<span id='Ext-panel-Table-cfg-variableRowHeight'>    /**
</span>     * @cfg {Boolean} [variableRowHeight=false]
     * @deprecated 5.0.0 Use {@link Ext.grid.column.Column#variableRowHeight} instead.
     * Configure as `true` if the row heights are not all the same height as the first row.
     */
    variableRowHeight: false,

<span id='Ext-panel-Table-cfg-numFromEdge'>    /**
</span>     * @cfg {Number}
     * This configures the zone which causes new rows to be appended to the view. As soon as the edge
     * of the rendered grid is this number of rows from the edge of the viewport, the view is moved.
     */
    numFromEdge: 2,

<span id='Ext-panel-Table-cfg-trailingBufferZone'>    /**
</span>     * @cfg {Number}
     * TableViews are buffer rendered in 5.x which means that only the visible subset of data rows
     * are rendered into the DOM. These are removed and added as scrolling demands.
     *
     * This configures the number of extra rows to render on the trailing side of scrolling
     * **outside the {@link #numFromEdge}** buffer as scrolling proceeds.
     */
    trailingBufferZone: 10,

<span id='Ext-panel-Table-cfg-leadingBufferZone'>    /**
</span>     * @cfg {Number}
     * TableViews are buffer rendered in 5.x which means that only the visible subset of data rows
     * are rendered into the DOM. These are removed and added as scrolling demands.
     *
     * This configures the number of extra rows to render on the leading side of scrolling
     * **outside the {@link #numFromEdge}** buffer as scrolling proceeds.
     */
    leadingBufferZone: 20,

<span id='Ext-panel-Table-property-hasView'>    /**
</span>     * @property {Boolean} hasView
     * True to indicate that a view has been injected into the panel.
     */
    hasView: false,

    // each panel should dictate what viewType and selType to use
<span id='Ext-panel-Table-cfg-viewType'>    /**
</span>     * @cfg {String} viewType
     * An xtype of view to use. This is automatically set to &#39;gridview&#39; by {@link Ext.grid.Panel Grid}
     * and to &#39;treeview&#39; by {@link Ext.tree.Panel Tree}.
     * @protected
     */
    viewType: null,

<span id='Ext-panel-Table-cfg-viewConfig'>    /**
</span>     * @cfg {Object} viewConfig
     * A config object that will be applied to the grid&#39;s UI view. Any of the config options available for
     * {@link Ext.view.Table} can be specified here. This option is ignored if {@link #view} is specified.
     */

<span id='Ext-panel-Table-cfg-view'>    /**
</span>     * @cfg {Ext.view.Table} view
     * The {@link Ext.view.Table} used by the grid. Use {@link #viewConfig} to just supply some config options to
     * view (instead of creating an entire View instance).
     */

<span id='Ext-panel-Table-cfg-selType'>    /**
</span>     * @cfg {String} [selType]
     * An xtype of selection model to use. This is used to create selection model if just
     * a config object or nothing at all given in {@link #selModel} config.
     */
    selType: &#39;rowmodel&#39;,

<span id='Ext-panel-Table-cfg-selModel'>    /**
</span>     * @cfg {Ext.selection.Model/Object} selModel
     * A {@link Ext.selection.Model selection model} instance or config object.  In latter case the {@link #selType}
     * config option determines to which type of selection model this config is applied.
     */

<span id='Ext-panel-Table-cfg-multiSelect'>    /**
</span>     * @cfg {Boolean} [multiSelect=false]
     * True to enable &#39;MULTI&#39; selection mode on selection model.
     * @deprecated 4.1.1 Use {@link Ext.selection.Model#mode} &#39;MULTI&#39; instead.
     */

<span id='Ext-panel-Table-cfg-simpleSelect'>    /**
</span>     * @cfg {Boolean} [simpleSelect=false]
     * True to enable &#39;SIMPLE&#39; selection mode on selection model.
     * @deprecated 4.1.1 Use {@link Ext.selection.Model#mode} &#39;SIMPLE&#39; instead.
     */

<span id='Ext-panel-Table-cfg-store'>    /**
</span>     * @cfg {Ext.data.Store} store (required)
     * The {@link Ext.data.Store Store} the grid should use as its data source.
     */

<span id='Ext-panel-Table-cfg-scroll'>    /**
</span>     * @cfg {String/Boolean} scroll
     * Scrollers configuration. Valid values are &#39;both&#39;, &#39;horizontal&#39; or &#39;vertical&#39;.
     * True implies &#39;both&#39;. False implies &#39;none&#39;.
     */
    scroll: true,

<span id='Ext-panel-Table-cfg-reserveScrollbar'>    /**
</span>     * @cfg {Boolean} [reserveScrollbar=false]
     * Set this to true to **always** leave a scrollbar sized space at the end of the grid content when
     * fitting content into the width of the grid.
     *
     * If the grid&#39;s record count fluctuates enough to hide and show the scrollbar regularly, this setting
     * avoids the multiple layouts associated with switching from scrollbar present to scrollbar not present.
     */

<span id='Ext-panel-Table-cfg-columns'>    /**
</span>     * @cfg {Ext.grid.column.Column[]/Object} columns (required)
     * An array of {@link Ext.grid.column.Column column} definition objects which define all columns that appear in this
     * grid. Each column definition provides the header text for the column, and a definition of where the data for that
     * column comes from.
     *
     * This can also be a configuration object for a {@link Ext.grid.header.Container HeaderContainer} which may override
     * certain default configurations if necessary. For example, the special layout may be overridden to use a simpler
     * layout, or one can set default values shared by all columns:
     * 
     *     columns: {
     *         items: [
     *             {
     *                 text: &quot;Column A&quot;,
     *                 dataIndex: &quot;field_A&quot;
     *             },{
     *                 text: &quot;Column B&quot;,
     *                 dataIndex: &quot;field_B&quot;
     *             }, 
     *             ...
     *         ],
     *         defaults: {
     *             flex: 1
     *         }
     *     }
     */

<span id='Ext-panel-Table-cfg-forceFit'>    /**
</span>     * @cfg {Boolean} forceFit
     * True to force the columns to fit into the available width. Headers are first sized according to configuration,
     * whether that be a specific width, or flex. Then they are all proportionally changed in width so that the entire
     * content width is used. For more accurate control, it is more optimal to specify a flex setting on the columns
     * that are to be stretched &amp; explicit widths on columns that are not.
     */

<span id='Ext-panel-Table-cfg-features'>    /**
</span>     * @cfg {Ext.grid.feature.Feature[]/Object[]/Ext.enums.Feature[]} features
     * An array of grid Features to be added to this grid. Can also be just a single feature instead of array.
     *
     * Features config behaves much like {@link #plugins}.
     * A feature can be added by either directly referencing the instance:
     *
     *     features: [Ext.create(&#39;Ext.grid.feature.GroupingSummary&#39;, {groupHeaderTpl: &#39;Subject: {name}&#39;})],
     *
     * By using config object with ftype:
     *
     *     features: [{ftype: &#39;groupingsummary&#39;, groupHeaderTpl: &#39;Subject: {name}&#39;}],
     *
     * Or with just a ftype:
     *
     *     features: [&#39;grouping&#39;, &#39;groupingsummary&#39;],
     *
     * See {@link Ext.enums.Feature} for list of all ftypes.
     */

<span id='Ext-panel-Table-cfg-hideHeaders'>    /**
</span>     * @cfg {Boolean} [hideHeaders=false]
     * True to hide column headers.
     */

<span id='Ext-panel-Table-cfg-deferRowRender'>    /**
</span>     * @cfg {Boolean} [deferRowRender=false]
     * Configure as `true` to enable deferred row rendering.
     *
     * This allows the View to execute a refresh quickly, with the update of the row structure deferred so
     * that layouts with GridPanels appear, and lay out more quickly.
     */
    deferRowRender: false,
     
<span id='Ext-panel-Table-cfg-sortableColumns'>    /**
</span>     * @cfg {Boolean} [sortableColumns=true]
     * False to disable column sorting via clicking the header and via the Sorting menu items.
     */
    sortableColumns: true,

<span id='Ext-panel-Table-cfg-multiColumnSort'>    /**
</span>     * @cfg {Boolean} [multiColumnSort=false]
     * Configure as `true` to have columns remember their sorted state after other columns have been clicked upon to sort.
     *
     * As subsequent columns are clicked upon, they become the new primary sort key.
     *
     * The maximum number of sorters allowed in a Store is configurable via its underlying data collection. See {@link Ext.util.Collection#multiSortLimit}
     */
    multiColumnSort: false,

<span id='Ext-panel-Table-cfg-enableLocking'>    /**
</span>     * @cfg {Boolean} [enableLocking=false]
     * Configure as `true` to enable locking support for this grid. Alternatively, locking will also be automatically
     * enabled if any of the columns in the {@link #columns columns} configuration contain a {@link Ext.grid.column.Column#locked locked} config option.
     * 
     * A locking grid is processed in a special way. The configuration options are cloned and *two* grids are created to be the locked (left) side
     * and the normal (right) side. This Panel becomes merely a {@link Ext.container.Container container} which arranges both in an {@link Ext.layout.container.HBox HBox} layout.
     * 
     * {@link #plugins Plugins} may be targeted at either locked, or unlocked grid, or, both, in which case the plugin is cloned and used on both sides.
     * 
     * Plugins may also be targeted at the containing locking Panel.
     * 
     * This is configured by specifying a `lockableScope` property in your plugin which may have the following values:
     * 
     *  * `&quot;both&quot;` (the default) - The plugin is added to both grids
     *  * `&quot;top&quot;` - The plugin is added to the containing Panel
     *  * `&quot;locked&quot;` - The plugin is added to the locked (left) grid
     *  * `&quot;normal&quot;` - The plugin is added to the normal (right) grid
     *
     * If `both` is specified, then each copy of the plugin gains a property `lockingPartner` which references its sibling on the other side so that they
     * can synchronize operations is necessary.
     * 
     * {@link #features Features} may also be configured with `lockableScope` and may target the locked grid, the normal grid or both grids. Features
     * also get a `lockingPartner` reference injected.
     */
    enableLocking: false,

<span id='Ext-panel-Table-property-scrollerOwner'>    // private property used to determine where to go down to find views
</span>    // this is here to support locking.
    scrollerOwner: true,

<span id='Ext-panel-Table-cfg-enableColumnMove'>    /**
</span>     * @cfg {Boolean} [enableColumnMove=true]
     * False to disable column dragging within this grid.
     */
    enableColumnMove: true,
    
<span id='Ext-panel-Table-cfg-sealedColumns'>    /**
</span>     * @cfg {Boolean} [sealedColumns=false]
     * True to constrain column dragging so that a column cannot be dragged in or out of it&#39;s
     * current group. Only relevant while {@link #enableColumnMove} is enabled.
     */
    sealedColumns: false,

<span id='Ext-panel-Table-cfg-enableColumnResize'>    /**
</span>     * @cfg {Boolean} [enableColumnResize=true]
     * False to disable column resizing within this grid.
     */
    enableColumnResize: true,

<span id='Ext-panel-Table-cfg-enableColumnHide'>    /**
</span>     * @cfg {Boolean} [enableColumnHide=true]
     * False to disable column hiding within this grid.
     */

<span id='Ext-panel-Table-cfg-columnLines'>    /**
</span>     * @cfg {Boolean} columnLines Adds column line styling
     */

<span id='Ext-panel-Table-cfg-rowLines'>    /**
</span>     * @cfg {Boolean} [rowLines=true] Adds row line styling
     */
    rowLines: true,

<span id='Ext-panel-Table-cfg-disableSelection'>    /**
</span>     * @cfg {Boolean} [disableSelection=false]
     * True to disable selection model.
     */

<span id='Ext-panel-Table-cfg-emptyText'>    /**
</span>     * @cfg {String} emptyText Default text (HTML tags are accepted) to display in the 
     * Panel body when the Store is empty. When specified, and the Store is empty, the 
     * text will be rendered inside a DIV with the CSS class &quot;x-grid-empty&quot;. The emptyText 
     * will not display until the first load of the associated store by default. If you 
     * want the text to be displayed prior to the first store load use the 
     * {@link Ext.view.Table#deferEmptyText deferEmptyText} config in the {@link #viewConfig} config.
     */
    
<span id='Ext-panel-Table-cfg-allowDeselect'>    /**
</span>     * @cfg {Boolean} [allowDeselect=false]
     * True to allow deselecting a record. This config is forwarded to {@link Ext.selection.Model#allowDeselect}.
     */
    
<span id='Ext-panel-Table-cfg-bufferedRenderer'>    /**
</span>     * @cfg {Boolean} [bufferedRenderer=true]
     * Buffered rendering is enabled by default.
     * 
     * Configure as `false` to disable buffered rendering. See {@link #Ext.grid.plugin.BufferedRenderer}.
     *
     * @since 5.0.0
     */
    bufferedRenderer: true,

<span id='Ext-panel-Table-property-optimizedColumnMove'>    /**
</span>     * @property {Boolean} optimizedColumnMove
     * If you are writing a grid plugin or a {Ext.grid.feature.Feature Feature} which creates a column-based structure which
     * needs a view refresh when columns are moved, then set this property in the grid.
     *
     * An example is the built in {@link Ext.grid.feature.AbstractSummary Summary} Feature. This creates summary rows, and the
     * summary columns must be in the same order as the data columns. This plugin sets the `optimizedColumnMove` to `false.
     */

<span id='Ext-panel-Table-property-ownerGrid'>    /**
</span>     * @property {Ext.view.Table} ownerGrid
     * A reference to the top-level owning grid component.
     * 
     * This is a reference to this GridPanel if this GridPanel is not part of a locked grid arrangement.
     * @readonly
     * @private
     * @since 5.0.0
     */
    ownerGrid: null,

<span id='Ext-panel-Table-property-colLinesCls'>    colLinesCls: Ext.baseCSSPrefix + &#39;grid-with-col-lines&#39;,
</span><span id='Ext-panel-Table-property-rowLinesCls'>    rowLinesCls: Ext.baseCSSPrefix + &#39;grid-with-row-lines&#39;,
</span><span id='Ext-panel-Table-property-noRowLinesCls'>    noRowLinesCls: Ext.baseCSSPrefix + &#39;grid-no-row-lines&#39;,
</span><span id='Ext-panel-Table-property-hiddenHeaderCtCls'>    hiddenHeaderCtCls: Ext.baseCSSPrefix + &#39;grid-header-ct-hidden&#39;,
</span><span id='Ext-panel-Table-property-hiddenHeaderCls'>    hiddenHeaderCls: Ext.baseCSSPrefix + &#39;grid-header-hidden&#39;,
</span><span id='Ext-panel-Table-property-resizeMarkerCls'>    resizeMarkerCls: Ext.baseCSSPrefix + &#39;grid-resize-marker&#39;,
</span><span id='Ext-panel-Table-property-emptyCls'>    emptyCls: Ext.baseCSSPrefix + &#39;grid-empty&#39;,
</span>    
<span id='Ext-panel-Table-property-focusable'>    focusable: true,
</span><span id='Ext-panel-Table-property-tabIndex'>    tabIndex: 0,
</span>
<span id='Ext-panel-Table-event-viewready'>    /**
</span>     * @event viewready
     * Fires when the grid view is available (use this for selecting a default row).
     * @param {Ext.panel.Table} this
     */

    constructor: function (config) {
        var me = this,
            store;

        me.ownerGrid = (config &amp;&amp; config.ownerGrid) || me;

        me.callParent([config]);

        store = this.store;

        // Any further changes become stateful.
        store.trackStateChanges = true;

        if (me.autoLoad) {
            store.unblockLoad();
            store.load();
        }
    },

<span id='Ext-panel-Table-method-initComponent'>    initComponent: function() {
</span>        //&lt;debug&gt;
        if (this.verticalScroller) {
            Ext.Error.raise(&quot;The verticalScroller config is not supported.&quot;);
        }
        if (!this.viewType) {
            Ext.Error.raise(&quot;You must specify a viewType config.&quot;);
        }
        if (this.headers) {
            Ext.Error.raise(&quot;The headers config is not supported. Please specify columns instead.&quot;);
        }
        //&lt;/debug&gt;

        var me = this,
            headerCtCfg = me.columns || me.colModel || [],
            view,
            i, len,
            bufferedRenderer,
            // Look up the configured Store. If none configured, use the fieldless, empty Store defined in Ext.data.Store.
            store       = me.store = Ext.data.StoreManager.lookup(me.store || &#39;ext-empty-store&#39;),
            columns;

        me.enableLocking = me.enableLocking || me.hasLockedColumns(headerCtCfg);

        // Block store loads during construction or initialization of plugins!
        if (me.autoLoad) {
            me.store.blockLoad();
        }

        // Construct the plugins now rather than in the constructor of AbstractComponent because the component may have a subclass
        // that has overridden initComponent and defined plugins in it. For plugins like RowExpander that rely upon a grid feature,
        // this is a problem because the view needs to know about all its features before it&#39;s constructed. Constructing the plugins
        // now ensures that plugins defined in the instance config or in initComponent are all constructed before the view.
        // See EXTJSIV-11927.
        //
        // Note that any components that do not inherit from this class will still have their plugins constructed in
        // AbstractComponent:initComponent.
        if (me.plugins) {
            me.plugins = me.constructPlugins();
        }

        // Add the row/column line classes to the body element so that the settings are not inherited by docked grids (https://sencha.jira.com/browse/EXTJSIV-9263).
        if (me.columnLines) {
            me.addBodyCls(me.colLinesCls);
        }

        me.addBodyCls(me.rowLines ? me.rowLinesCls : me.noRowLinesCls);
        me.addBodyCls(me.extraBodyCls);


        // If any of the Column objects contain a locked property, and are not processed, this is a lockable TablePanel, a
        // special view will be injected by the Ext.grid.locking.Lockable mixin, so no processing of .
        if (me.enableLocking) {
            me.self.mixin(&#39;lockable&#39;, Ext.grid.locking.Lockable);
            me.injectLockable();
        }
        // Not lockable - create the HeaderContainer
        else {
            // It&#39;s a fully instantiated HeaderContainer
            if (headerCtCfg.isRootHeader) {
                me.headerCt = headerCtCfg;

                me.headerCt.forceFit = !!me.forceFit;

                // If it&#39;s an instance then the column managers were already created and bound to the headerCt.
                me.columnManager = headerCtCfg.columnManager;
                me.visibleColumnManager = headerCtCfg.visibleColumnManager;
            }
            // It&#39;s an array of Column definitions, or a config object of a HeaderContainer
            else {
                if (Ext.isArray(headerCtCfg)) {
                    headerCtCfg = {
                        items: headerCtCfg
                    };
                }
                Ext.apply(headerCtCfg, {
                    grid: me,
                    forceFit: me.forceFit,
                    sortable: me.sortableColumns,
                    enableColumnMove: me.enableColumnMove,
                    enableColumnResize: me.enableColumnResize,
                    columnLines: me.columnLines,
                    sealed: me.sealedColumns
                });
                if (me.hideHeaders) {
                    headerCtCfg.height = 0;
                    // don&#39;t set the hidden property, we still need these to layout
                    headerCtCfg.hiddenHeaders = true;
                }

                if (Ext.isDefined(me.enableColumnHide)) {
                    headerCtCfg.enableColumnHide = me.enableColumnHide;
                }
                me.headerCt = new Ext.grid.header.Container(headerCtCfg);
            }
        }

        // Maintain backward compatibiliy by providing the initial leaf column set as a property.
        me.columns = columns = me.headerCt.getGridColumns();

        me.scrollTask = new Ext.util.DelayedTask(me.syncHorizontalScroll, me);

        me.cls = (me.cls || &#39;&#39;) + (&#39; &#39; + me.extraBaseCls);

        // autoScroll is not a valid configuration
        delete me.autoScroll;

        bufferedRenderer = me.plugins &amp;&amp; Ext.Array.findBy(me.plugins, function(p) {
            return p.isBufferedRenderer;
        });

        // If we find one in the plugins, just use that.
        if (bufferedRenderer) {
            me.bufferedRenderer = bufferedRenderer;
        }

        // If this TablePanel is lockable (Either configured lockable, or any of the defined columns has a &#39;locked&#39; property)
        // then a special lockable view containing 2 side-by-side grids will have been injected so we do not need to set up any UI.
        if (!me.hasView) {

            // If the Store is paging blocks of the dataset in, then it can only be sorted remotely.
            if (store.isBufferedStore &amp;&amp; !store.remoteSort) {
                for (i = 0, len = columns.length; i &lt; len; i++) {
                    columns[i].sortable = false;
                }
            }

            if (me.hideHeaders) {
                me.headerCt.addCls(me.hiddenHeaderCtCls);
                me.addCls(me.hiddenHeaderCls);
            }

            me.relayHeaderCtEvents(me.headerCt);
            me.features = me.features || [];
            if (!Ext.isArray(me.features)) {
                me.features = [me.features];
            }
            me.dockedItems = [].concat(me.dockedItems || []);
            me.dockedItems.unshift(me.headerCt);
            me.viewConfig = me.viewConfig || {};

            // AbstractDataView will look up a Store configured as an object
            // getView converts viewConfig into a View instance
            view = me.getView();

            me.items = [view];
            me.hasView = true;

            // Add a listener to synchronize the horizontal scroll position of the headers
            // with the table view&#39;s element... Unless we are not showing headers!
            if (!me.hideHeaders) {
                view.on({
                    scroll: me.onHorizontalScroll,
                    scope: me,
                    onFrame: !!Ext.global.requestAnimationFrame
                });
            }

            // Attach this Panel to the Store
            me.bindStore(store, true);

            me.mon(view, {
                viewready: me.onViewReady,
                refresh: me.onRestoreHorzScroll,
                scope: me
            });
        }

        // Relay events from the View whether it be a LockingView, or a regular GridView
        me.relayEvents(me.view, [
<span id='Ext-panel-Table-event-beforeitemmousedown'>            /**
</span>             * @event beforeitemmousedown
             * @inheritdoc Ext.view.View#beforeitemmousedown
             */
            &#39;beforeitemmousedown&#39;,
<span id='Ext-panel-Table-event-beforeitemmouseup'>            /**
</span>             * @event beforeitemmouseup
             * @inheritdoc Ext.view.View#beforeitemmouseup
             */
            &#39;beforeitemmouseup&#39;,
<span id='Ext-panel-Table-event-beforeitemmouseenter'>            /**
</span>             * @event beforeitemmouseenter
             * @inheritdoc Ext.view.View#beforeitemmouseenter
             */
            &#39;beforeitemmouseenter&#39;,
<span id='Ext-panel-Table-event-beforeitemmouseleave'>            /**
</span>             * @event beforeitemmouseleave
             * @inheritdoc Ext.view.View#beforeitemmouseleave
             */
            &#39;beforeitemmouseleave&#39;,
<span id='Ext-panel-Table-event-beforeitemclick'>            /**
</span>             * @event beforeitemclick
             * @inheritdoc Ext.view.View#beforeitemclick
             */
            &#39;beforeitemclick&#39;,
<span id='Ext-panel-Table-event-beforeitemdblclick'>            /**
</span>             * @event beforeitemdblclick
             * @inheritdoc Ext.view.View#beforeitemdblclick
             */
            &#39;beforeitemdblclick&#39;,
<span id='Ext-panel-Table-event-beforeitemcontextmenu'>            /**
</span>             * @event beforeitemcontextmenu
             * @inheritdoc Ext.view.View#beforeitemcontextmenu
             */
            &#39;beforeitemcontextmenu&#39;,
<span id='Ext-panel-Table-event-itemmousedown'>            /**
</span>             * @event itemmousedown
             * @inheritdoc Ext.view.View#itemmousedown
             */
            &#39;itemmousedown&#39;,
<span id='Ext-panel-Table-event-itemmouseup'>            /**
</span>             * @event itemmouseup
             * @inheritdoc Ext.view.View#itemmouseup
             */
            &#39;itemmouseup&#39;,
<span id='Ext-panel-Table-event-itemmouseenter'>            /**
</span>             * @event itemmouseenter
             * @inheritdoc Ext.view.View#itemmouseenter
             */
            &#39;itemmouseenter&#39;,
<span id='Ext-panel-Table-event-itemmouseleave'>            /**
</span>             * @event itemmouseleave
             * @inheritdoc Ext.view.View#itemmouseleave
             */
            &#39;itemmouseleave&#39;,
<span id='Ext-panel-Table-event-itemclick'>            /**
</span>             * @event itemclick
             * @inheritdoc Ext.view.View#itemclick
             */
            &#39;itemclick&#39;,
<span id='Ext-panel-Table-event-itemdblclick'>            /**
</span>             * @event itemdblclick
             * @inheritdoc Ext.view.View#itemdblclick
             */
            &#39;itemdblclick&#39;,
<span id='Ext-panel-Table-event-itemcontextmenu'>            /**
</span>             * @event itemcontextmenu
             * @inheritdoc Ext.view.View#itemcontextmenu
             */
            &#39;itemcontextmenu&#39;,
<span id='Ext-panel-Table-event-beforecellclick'>            /**
</span>             * @event beforecellclick
             * @inheritdoc Ext.view.Table#beforecellclick
             */
            &#39;beforecellclick&#39;,
<span id='Ext-panel-Table-event-cellclick'>            /**
</span>             * @event cellclick
             * @inheritdoc Ext.view.Table#cellclick
             */
            &#39;cellclick&#39;,
<span id='Ext-panel-Table-event-beforecelldblclick'>            /**
</span>             * @event beforecelldblclick
             * @inheritdoc Ext.view.Table#beforecelldblclick
             */
            &#39;beforecelldblclick&#39;,
<span id='Ext-panel-Table-event-celldblclick'>            /**
</span>             * @event celldblclick
             * @inheritdoc Ext.view.Table#celldblclick
             */
            &#39;celldblclick&#39;,
<span id='Ext-panel-Table-event-beforecellcontextmenu'>            /**
</span>             * @event beforecellcontextmenu
             * @inheritdoc Ext.view.Table#beforecellcontextmenu
             */
            &#39;beforecellcontextmenu&#39;,
<span id='Ext-panel-Table-event-cellcontextmenu'>            /**
</span>             * @event cellcontextmenu
             * @inheritdoc Ext.view.Table#cellcontextmenu
             */
            &#39;cellcontextmenu&#39;,
<span id='Ext-panel-Table-event-beforecellmousedown'>            /**
</span>             * @event beforecellmousedown
             * @inheritdoc Ext.view.Table#beforecellmousedown
             */
            &#39;beforecellmousedown&#39;,
<span id='Ext-panel-Table-event-cellmousedown'>            /**
</span>             * @event cellmousedown
             * @inheritdoc Ext.view.Table#cellmousedown
             */
            &#39;cellmousedown&#39;,
<span id='Ext-panel-Table-event-beforecellmouseup'>            /**
</span>             * @event beforecellmouseup
             * @inheritdoc Ext.view.Table#beforecellmouseup
             */
            &#39;beforecellmouseup&#39;,
<span id='Ext-panel-Table-event-cellmouseup'>            /**
</span>             * @event cellmouseup
             * @inheritdoc Ext.view.Table#cellmouseup
             */
            &#39;cellmouseup&#39;,
<span id='Ext-panel-Table-event-beforecellkeydown'>            /**
</span>             * @event beforecellkeydown
             * @inheritdoc Ext.view.Table#beforecellkeydown
             */
            &#39;beforecellkeydown&#39;,
<span id='Ext-panel-Table-event-cellkeydown'>            /**
</span>             * @event cellkeydown
             * @inheritdoc Ext.view.Table#cellkeydown
             */
            &#39;cellkeydown&#39;,
<span id='Ext-panel-Table-event-rowclick'>            /**
</span>             * @event rowclick
             * @inheritdoc Ext.view.Table#rowclick
             */
            &#39;rowclick&#39;,
<span id='Ext-panel-Table-event-rowdblclick'>            /**
</span>             * @event rowdblclick
             * @inheritdoc Ext.view.Table#rowdblclick
             */
            &#39;rowdblclick&#39;,
<span id='Ext-panel-Table-event-rowcontextmenu'>            /**
</span>             * @event rowcontextmenu
             * @inheritdoc Ext.view.Table#rowcontextmenu
             */
            &#39;rowcontextmenu&#39;,
<span id='Ext-panel-Table-event-rowmousedown'>            /**
</span>             * @event rowmousedown
             * @inheritdoc Ext.view.Table#rowmousedown
             */
            &#39;rowmousedown&#39;,
<span id='Ext-panel-Table-event-rowmouseup'>            /**
</span>             * @event rowmouseup
             * @inheritdoc Ext.view.Table#rowmouseup
             */
            &#39;rowmouseup&#39;,
<span id='Ext-panel-Table-event-rowkeydown'>            /**
</span>             * @event rowkeydown
             * @inheritdoc Ext.view.Table#rowkeydown
             */
            &#39;rowkeydown&#39;,
<span id='Ext-panel-Table-event-beforeitemkeydown'>            /**
</span>             * @event beforeitemkeydown
             * @inheritdoc Ext.view.Table#beforeitemkeydown
             */
            &#39;beforeitemkeydown&#39;,
<span id='Ext-panel-Table-event-itemkeydown'>            /**
</span>             * @event itemkeydown
             * @inheritdoc Ext.view.Table#itemkeydown
             */
            &#39;itemkeydown&#39;,
<span id='Ext-panel-Table-event-beforecontainermousedown'>            /**
</span>             * @event beforecontainermousedown
             * @inheritdoc Ext.view.View#beforecontainermousedown
             */
            &#39;beforecontainermousedown&#39;,
<span id='Ext-panel-Table-event-beforecontainermouseup'>            /**
</span>             * @event beforecontainermouseup
             * @inheritdoc Ext.view.View#beforecontainermouseup
             */
            &#39;beforecontainermouseup&#39;,
<span id='Ext-panel-Table-event-beforecontainermouseover'>            /**
</span>             * @event beforecontainermouseover
             * @inheritdoc Ext.view.View#beforecontainermouseover
             */
            &#39;beforecontainermouseover&#39;,
<span id='Ext-panel-Table-event-beforecontainermouseout'>            /**
</span>             * @event beforecontainermouseout
             * @inheritdoc Ext.view.View#beforecontainermouseout
             */
            &#39;beforecontainermouseout&#39;,
<span id='Ext-panel-Table-event-beforecontainerclick'>            /**
</span>             * @event beforecontainerclick
             * @inheritdoc Ext.view.View#beforecontainerclick
             */
            &#39;beforecontainerclick&#39;,
<span id='Ext-panel-Table-event-beforecontainerdblclick'>            /**
</span>             * @event beforecontainerdblclick
             * @inheritdoc Ext.view.View#beforecontainerdblclick
             */
            &#39;beforecontainerdblclick&#39;,
<span id='Ext-panel-Table-event-beforecontainercontextmenu'>            /**
</span>             * @event beforecontainercontextmenu
             * @inheritdoc Ext.view.View#beforecontainercontextmenu
             */
            &#39;beforecontainercontextmenu&#39;,
<span id='Ext-panel-Table-event-beforecontainerkeydown'>            /**
</span>             * @event beforecontainerkeydown
             * @inheritdoc Ext.view.View#beforecontainerkeydown
             */
            &#39;beforecontainerkeydown&#39;,
<span id='Ext-panel-Table-event-containermouseup'>            /**
</span>             * @event containermouseup
             * @inheritdoc Ext.view.View#containermouseup
             */
            &#39;containermouseup&#39;,
<span id='Ext-panel-Table-event-containermousedown'>            /**
</span>             * @event containermousedown
             * @inheritdoc Ext.view.View#containermousedown
             */
            &#39;containermousedown&#39;,
<span id='Ext-panel-Table-event-containermouseover'>            /**
</span>             * @event containermouseover
             * @inheritdoc Ext.view.View#containermouseover
             */
            &#39;containermouseover&#39;,
<span id='Ext-panel-Table-event-containermouseout'>            /**
</span>             * @event containermouseout
             * @inheritdoc Ext.view.View#containermouseout
             */
            &#39;containermouseout&#39;,
<span id='Ext-panel-Table-event-containerclick'>            /**
</span>             * @event containerclick
             * @inheritdoc Ext.view.View#containerclick
             */
            &#39;containerclick&#39;,
<span id='Ext-panel-Table-event-containerdblclick'>            /**
</span>             * @event containerdblclick
             * @inheritdoc Ext.view.View#containerdblclick
             */
            &#39;containerdblclick&#39;,
<span id='Ext-panel-Table-event-containercontextmenu'>            /**
</span>             * @event containercontextmenu
             * @inheritdoc Ext.view.View#containercontextmenu
             */
            &#39;containercontextmenu&#39;,
<span id='Ext-panel-Table-event-containerkeydown'>            /**
</span>             * @event containerkeydown
             * @inheritdoc Ext.view.View#containerkeydown
             */
            &#39;containerkeydown&#39;,
<span id='Ext-panel-Table-event-selectionchange'>            /**
</span>             * @event selectionchange
             * @inheritdoc Ext.selection.Model#selectionchange
             */
            &#39;selectionchange&#39;,
<span id='Ext-panel-Table-event-beforeselect'>            /**
</span>             * @event beforeselect
             * @inheritdoc Ext.selection.RowModel#beforeselect
             */
            &#39;beforeselect&#39;,
<span id='Ext-panel-Table-event-select'>            /**
</span>             * @event select
             * @inheritdoc Ext.selection.RowModel#select
             */
            &#39;select&#39;,
<span id='Ext-panel-Table-event-beforedeselect'>            /**
</span>             * @event beforedeselect
             * @inheritdoc Ext.selection.RowModel#beforedeselect
             */
            &#39;beforedeselect&#39;,
<span id='Ext-panel-Table-event-deselect'>            /**
</span>             * @event deselect
             * @inheritdoc Ext.selection.RowModel#deselect
             */
            &#39;deselect&#39;
        ]);

        me.callParent(arguments);
        me.addStateEvents([&#39;columnresize&#39;, &#39;columnmove&#39;, &#39;columnhide&#39;, &#39;columnshow&#39;, &#39;sortchange&#39;, &#39;filterchange&#39;, &#39;groupchange&#39;]);
    },

<span id='Ext-panel-Table-method-beforeRender'>    beforeRender: function() {
</span>        var me = this,
            bufferedRenderer = me.bufferedRenderer;

        // Don&#39;t create a buffered renderer for a locked grid.
        if (!me.lockable) {
            // If we&#39;re auto heighting, we can&#39;t buffered render, so don&#39;t create it
            if (bufferedRenderer &amp;&amp; me.getSizeModel().height.auto) {
                //&lt;debug&gt;
                if (bufferedRenderer.isBufferedRenderer) {
                    Ext.Error.raise(&#39;Cannot use buffered rendering with auto height&#39;);
                }
                //&lt;/debug&gt;
                me.bufferedRenderer = bufferedRenderer = false;
            }
        
            if (bufferedRenderer &amp;&amp; !bufferedRenderer.isBufferedRenderer) {
                // Create a BufferedRenderer as a plugin if we have not already configured with one.
                bufferedRenderer = {
                    xclass: &#39;Ext.grid.plugin.BufferedRenderer&#39;
                };
                Ext.copyTo(bufferedRenderer, me, &#39;variableRowHeight,numFromEdge,trailingBufferZone,leadingBufferZone,scrollToLoadBuffer&#39;);
                me.bufferedRenderer = me.addPlugin(bufferedRenderer);
            }
        }
        me.callParent(arguments);
    },
    
<span id='Ext-panel-Table-method-initFocusableEvents'>    initFocusableEvents: function() {
</span>        var me = this,
            view = me.getView();

        me.callParent();
        me.focusEnterLeaveListeners = view.getFocusEl().on({
            focusenter: me.onFocusEnter,
            focusleave: me.onFocusLeave,
            scope: me,
            destroyable: true
        });
    },

<span id='Ext-panel-Table-method-onFocus'>    onFocus: function(e) {
</span>        this.callParent([e]);

        // Focusing the main el delegates focus to a descendant cell.
        this.handleFocusEnter(e);
    },
    
<span id='Ext-panel-Table-method-onFocusEnter'>    onFocusEnter: function(e) {
</span>        this.handleFocusEnter(e);
    },

<span id='Ext-panel-Table-method-handleFocusEnter'>    handleFocusEnter: function(e) {
</span>        var me = this,
            view = me.getView(),
            targetView,
            navigationModel = view.getNavigationModel(),
            lastFocused,
            focusPosition,
            br = view.bufferedRenderer,
            firstRecord;

        if (!me.containsFocus) {
            lastFocused = focusPosition = view.getLastFocused();

            // Default to the first cell if the NavigationModel has never focused anything
            if (!focusPosition) {
                targetView = view.isLockingView ? (view.lockedGrid.isVisible() ? view.lockedView : view.normalView) : view;
                firstRecord = view.dataSource.getAt(br ? br.getFirstVisibleRowIndex() : 0);

                // A non-row producing record like a collapsed placeholder.
                // We cannot focus these yet.
                if (!firstRecord.isNonData) {
                    focusPosition = new Ext.grid.CellContext(targetView).setPosition({
                        row: firstRecord,
                        column: 0
                    });
                }
            }

            // Not a descendant which we allow to carry focus. Blur it.
            if (!focusPosition) {
                e.stopEvent();
                e.getTarget().blur();
                return;
            }
            navigationModel.setPosition(focusPosition, null, e, null, !!lastFocused);

            // We now contain focus is that was successful
            me.containsFocus = !!navigationModel.getPosition();
        }
        
        if (me.containsFocus) {
            this.getView().el.dom.setAttribute(&#39;tabindex&#39;, &#39;-1&#39;);
        }
    },

<span id='Ext-panel-Table-method-onFocusLeave'>    onFocusLeave: function(e) {
</span>        var view = this.getView();

        // Ignore this event if we do not actually contain focus.
        // CellEditors are rendered into the view&#39;s encapculating element,
        // So focusleave will fire when they are programatically blurred.
        // We will not have focus at that point.
        if (this.containsFocus) {

            // Blur the focused cell
            view.getNavigationModel().setPosition(null, null, e, null, true);

            this.containsFocus = false;
            view.focusEl = view.el;
            view.focusEl.dom.setAttribute(&#39;tabindex&#39;, 0);
        }
    },

<span id='Ext-panel-Table-method-hasLockedColumns'>    // Private. Determine if there are any columns with a locked configuration option
</span>    hasLockedColumns: function(columns) {
        var i,
            len,
            column;

        // Fully instantiated HeaderContainer
        if (columns.isRootHeader) {
            columns = columns.items.items;
        }
        // Config object with items
        else if (Ext.isObject(columns)) {
            columns = columns.items;
        }
        for (i = 0, len = columns.length; i &lt; len; i++) {
            column = columns[i];
            if (!column.processed &amp;&amp; column.locked) {
                return true;
            }
        }
    },

<span id='Ext-panel-Table-method-relayHeaderCtEvents'>    relayHeaderCtEvents: function (headerCt) {
</span>        this.relayEvents(headerCt, [
<span id='Ext-panel-Table-event-columnresize'>            /**
</span>             * @event columnresize
             * @inheritdoc Ext.grid.header.Container#columnresize
             */
            &#39;columnresize&#39;,
<span id='Ext-panel-Table-event-columnmove'>            /**
</span>             * @event columnmove
             * @inheritdoc Ext.grid.header.Container#columnmove
             */
            &#39;columnmove&#39;,
<span id='Ext-panel-Table-event-columnhide'>            /**
</span>             * @event columnhide
             * @inheritdoc Ext.grid.header.Container#columnhide
             */
            &#39;columnhide&#39;,
<span id='Ext-panel-Table-event-columnshow'>            /**
</span>             * @event columnshow
             * @inheritdoc Ext.grid.header.Container#columnshow
             */
            &#39;columnshow&#39;,
<span id='Ext-panel-Table-event-columnschanged'>            /**
</span>             * @event columnschanged
             * @inheritdoc Ext.grid.header.Container#columnschanged
             */
            &#39;columnschanged&#39;,
<span id='Ext-panel-Table-event-sortchange'>            /**
</span>             * @event sortchange
             * @inheritdoc Ext.grid.header.Container#sortchange
             */
            &#39;sortchange&#39;,
<span id='Ext-panel-Table-event-headerclick'>            /**
</span>             * @event headerclick
             * @inheritdoc Ext.grid.header.Container#headerclick
             */
            &#39;headerclick&#39;,
<span id='Ext-panel-Table-event-headercontextmenu'>            /**
</span>             * @event headercontextmenu
             * @inheritdoc Ext.grid.header.Container#headercontextmenu
             */
            &#39;headercontextmenu&#39;,
<span id='Ext-panel-Table-event-headertriggerclick'>            /**
</span>             * @event headertriggerclick
             * @inheritdoc Ext.grid.header.Container#headertriggerclick
             */
            &#39;headertriggerclick&#39;
        ]);
    },

<span id='Ext-panel-Table-method-getState'>    getState: function(){
</span>        var me = this,
            state = me.callParent(),
            storeState = me.store.getState();

        state = me.addPropertyToState(state, &#39;columns&#39;, me.headerCt.getColumnsState());

        if (storeState) {
            state.storeState = storeState;
        }
        return state;
    },

<span id='Ext-panel-Table-method-applyState'>    applyState: function (state) {
</span>        var me = this,
            sorter = state.sort,
            storeState = state.storeState,
            store = me.store,
            columns = state.columns;

        delete state.columns;

        // Ensure superclass has applied *its* state.
        // Component saves dimensions (and anchor/flex) plus collapsed state.
        me.callParent(arguments);

        if (columns) {
            me.headerCt.applyColumnsState(columns);
        }

        // Old stored sort state. Deprecated and will die out.
        if (sorter) {
            if (store.remoteSort) {
                // Pass false to prevent a sort from occurring.
                store.sort({
                    property: sorter.property,
                    direction: sorter.direction,
                    root: sorter.root
                }, null, false);
            } else {
                store.sort(sorter.property, sorter.direction);
            }
        }
        // New storeState which encapsulates groupers, sorters and filters.
        else if (storeState) {
            store.applyState(storeState);
        }
    },

<span id='Ext-panel-Table-method-getStore'>    /**
</span>     * Returns the store associated with this Panel.
     * @return {Ext.data.Store} The store
     */
    getStore: function(){
        return this.store;
    },

<span id='Ext-panel-Table-method-getView'>    /**
</span>     * Gets the view for this panel.
     * @return {Ext.view.Table}
     */
    getView: function() {
        var me = this,
            sm,
            viewConfig;

        if (!me.view) {
            sm = me.getSelectionModel();

            viewConfig = Ext.apply({
                // TableView injects the view reference into this grid so that we have a reference as early as possible
                // and Features need a reference to the grid.
                // For these reasons, we configure a reference to this grid into the View
                grid: me,
                ownerGrid: me.ownerGrid,
                deferInitialRefresh: me.deferRowRender,
                variableRowHeight: me.variableRowHeight,
                preserveScrollOnRefresh: true,
                trackOver: me.trackMouseOver !== false,
                throttledUpdate: me.throttledUpdate === true,
                scroll: me.scroll,
                xtype: me.viewType,
                store: me.store,
                headerCt: me.headerCt,
                columnLines: me.columnLines,
                rowLines: me.rowLines,
                selModel: sm,
                navigationModel: &#39;grid&#39;,
                features: me.features,
                panel: me,
                emptyText: me.emptyText || &#39;&#39;
            }, me.viewConfig);

            // Reconcile conflicting scroll requests in the grid&#39;s scroll configuration and viewConfig&#39;s scroll configuration.
            // If the grid has scroll:&#39;vertical&#39;, and the viewConfig has scroll&quot;horizontal&#39;, the outcome must be scroll: &#39;both&#39;
            if (me.scroll &amp;&amp; me.viewConfig.scroll &amp;&amp; me.scroll !== me.viewConfig.scroll) {
                viewConfig.scroll = &#39;both&#39;;
            }

            Ext.widget(viewConfig);

            // Normalize the application of the markup wrapping the emptyText config.
            // `emptyText` can now be defined on the grid as well as on its viewConfig, and this led to the emptyText not
            // having the wrapping markup when it was defined in the viewConfig. It should be backwards compatible.
            // Note that in the unlikely event that emptyText is defined on both the grid config and the viewConfig that the viewConfig wins.
            if (me.view.emptyText) {
                me.view.emptyText = &#39;&lt;div class=&quot;&#39; + me.emptyCls + &#39;&quot;&gt;&#39; + me.view.emptyText + &#39;&lt;/div&gt;&#39;;
            }

            // TableView&#39;s custom component layout, Ext.view.TableLayout requires a reference to the headerCt because it depends on the headerCt doing its work.
            me.view.getComponentLayout().headerCt = me.headerCt;

            me.mon(me.view, {
                uievent: me.processEvent,
                scope: me
            });
            sm.view = me.view;
            me.headerCt.view = me.view;

            // Plugins and features may need to access the view as soon as it is created.
            if (me.hasListeners.viewcreated) {
                me.fireEvent(&#39;viewcreated&#39;, me, me.view);
            }
        }
        return me.view;
    },

<span id='Ext-panel-Table-method-getColumnManager'>    getColumnManager: function() {
</span>        return this.columnManager;
    },

<span id='Ext-panel-Table-method-getVisibleColumnManager'>    getVisibleColumnManager: function() {
</span>        return this.visibleColumnManager;
    },

<span id='Ext-panel-Table-method-getTopLevelColumnManager'>    getTopLevelColumnManager: function() {
</span>        return this.ownerGrid.getColumnManager();
    },

<span id='Ext-panel-Table-method-getTopLevelVisibleColumnManager'>    getTopLevelVisibleColumnManager: function() {
</span>        return this.ownerGrid.getVisibleColumnManager();
    },

<span id='Ext-panel-Table-method-setAutoScroll'>    /**
</span>     * @private
     * autoScroll is never valid for all classes which extend TablePanel.
     */
    setAutoScroll: Ext.emptyFn,

<span id='Ext-panel-Table-method-processEvent'>    /**
</span>     * @private
     * Processes UI events from the view. Propagates them to whatever internal Components need to process them.
     * @param {String} type Event type, eg &#39;click&#39;
     * @param {Ext.view.Table} view TableView Component
     * @param {HTMLElement} cell Cell HTMLElement the event took place within
     * @param {Number} recordIndex Index of the associated Store Model (-1 if none)
     * @param {Number} cellIndex Cell index within the row
     * @param {Ext.event.Event} e Original event
     */
    processEvent: function(type, view, cell, recordIndex, cellIndex, e, record, row) {
        var header = e.position.column;

        if (header) {
            return header.processEvent.apply(header, arguments);
        }
    },

<span id='Ext-panel-Table-method-scrollByDeltaY'>    scrollByDeltaY: function(yDelta, animate) {
</span>        this.getView().scrollBy(0, yDelta, animate);
    },

<span id='Ext-panel-Table-method-scrollByDeltaX'>    scrollByDeltaX: function(xDelta, animate) {
</span>        this.getView().scrollBy(xDelta, 0, animate);
    },

<span id='Ext-panel-Table-method-afterCollapse'>    afterCollapse: function() {
</span>        this.saveScrollPos();
        this.callParent(arguments);
    },

<span id='Ext-panel-Table-method-afterExpand'>    afterExpand: function() {
</span>        this.callParent(arguments);
        this.restoreScrollPos();
    },

<span id='Ext-panel-Table-method-saveScrollPos'>    saveScrollPos: Ext.emptyFn,
</span>
<span id='Ext-panel-Table-method-restoreScrollPos'>    restoreScrollPos: Ext.emptyFn,
</span>
<span id='Ext-panel-Table-method-onHeaderResize'>    onHeaderResize: function() {
</span>        // Touch scroll manager needs to know about the new width
        if (this.view.scrollManager) {
            this.view.scrollManager.refresh();
        }
    },

<span id='Ext-panel-Table-method-onHeaderMove'>    // Update the view when a header moves
</span>    onHeaderMove: function(headerCt, header, colsToMove, fromIdx, toIdx) {
        var me = this;

        // If there are Features or Plugins which create DOM which must match column order, they set the optimizedColumnMove flag to false.
        // In this case we must refresh the view on column move.
        if (me.optimizedColumnMove === false) {
            me.view.refreshView();
        }

        // Simplest case for default DOM structure is just to swap the columns round in the view.
        else {
            me.view.moveColumn(fromIdx, toIdx, colsToMove);
        }
        me.delayScroll();
    },

<span id='Ext-panel-Table-method-onHeaderHide'>    // Section onHeaderHide is invoked after view.
</span>    onHeaderHide: function(headerCt, header) {
        if (this.view.refreshCounter) {
            this.view.refreshView();
        }
    },

<span id='Ext-panel-Table-method-onHeaderShow'>    onHeaderShow: function(headerCt, header) {
</span>        if (this.view.refreshCounter) {
            this.view.refreshView();
        }
    },

<span id='Ext-panel-Table-method-onHeadersChanged'>    // To be triggered on add/remove/move for a leaf header
</span>    onHeadersChanged: function(headerCt, header) {
        var me = this;
        if (me.rendered &amp;&amp; !me.reconfiguring) {
            me.view.refreshView();
            me.delayScroll();
        }
    },

<span id='Ext-panel-Table-method-delayScroll'>    delayScroll: function(){
</span>        var target = this.view;
        if (target) {
            // Do not cause a layout by reading scrollX now.
            // It must be read from the target when the task finally executes.
            this.scrollTask.delay(10, null, null, [target]);
        }
    },

<span id='Ext-panel-Table-method-onViewReady'>    /**
</span>     * @private
     * Fires the TablePanel&#39;s viewready event when the view declares that its internal DOM is ready
     */
    onViewReady: function() {
         this.fireEvent(&#39;viewready&#39;, this);   
    },

<span id='Ext-panel-Table-method-onRestoreHorzScroll'>    /**
</span>     * @private
     * Tracks when things happen to the view and preserves the horizontal scroll position.
     */
    onRestoreHorzScroll: function() {
        var me = this,
            x = me.scrollXPos;

        if (x) {
            // We need to restore the body scroll position here
            me.syncHorizontalScroll(me, true);
        }
    },

<span id='Ext-panel-Table-method-getScrollerOwner'>    getScrollerOwner: function() {
</span>        var rootCmp = this;
        if (!this.scrollerOwner) {
            rootCmp = this.up(&#39;[scrollerOwner]&#39;);
        }
        return rootCmp;
    },

<span id='Ext-panel-Table-method-getLhsMarker'>    /**
</span>     * Gets left hand side marker for header resizing.
     * @private
     */
    getLhsMarker: function() {
        var me = this;
        return me.lhsMarker || (me.lhsMarker = Ext.DomHelper.append(me.el, {
            role: &#39;presentation&#39;,
            cls: me.resizeMarkerCls
        }, true));
    },

<span id='Ext-panel-Table-method-getRhsMarker'>    /**
</span>     * Gets right hand side marker for header resizing.
     * @private
     */
    getRhsMarker: function() {
        var me = this;

        return me.rhsMarker || (me.rhsMarker = Ext.DomHelper.append(me.el, {
            role: &#39;presentation&#39;,
            cls: me.resizeMarkerCls
        }, true));
    },

<span id='Ext-panel-Table-method-getSelection'>    /**
</span>     * Returns the grid&#39;s selection. See `{@link Ext.selection.Model#getSelection}`.
     * @inheritdoc Ext.selection.Model#getSelection
     */
    getSelection: function () {
        return this.getSelectionModel().getSelection();
    },

<span id='Ext-panel-Table-method-updateSelection'>    updateSelection: function(selection) {
</span>        var me = this,
            sm;

        if (!me.ignoreNextSelection) {
            me.ignoreNextSelection = true;
            sm = me.getSelectionModel();
            if (selection) {
                sm.select(selection);
            } else {
                sm.deselectAll();
            }
            me.ignoreNextSelection = false;
        }
    },

<span id='Ext-panel-Table-method-updateBindSelection'>    updateBindSelection: function(selModel, selection) {
</span>        var me = this,
            selected = null;

        if (!me.ignoreNextSelection) {
            me.ignoreNextSelection = true;
            if (selection.length) {
                selected = selModel.getLastSelected();
                me.hasHadSelection = true;
            }
            if (me.hasHadSelection) {
                me.setSelection(selected);
            }
            me.ignoreNextSelection = false;
        }
    },

<span id='Ext-panel-Table-method-getNavigationModel'>    getNavigationModel: function() {
</span>        return this.getView().getNavigationModel();
    },

<span id='Ext-panel-Table-method-getSelectionModel'>    /**
</span>     * Returns the selection model being used and creates it via the configuration if it has not been created already.
     * @return {Ext.selection.Model} selModel
     */
    getSelectionModel: function(){
        var me = this,
            selModel = me.selModel,
            applyMode, mode, type;
        
        if (!selModel) {
            selModel = {};
            // no config, set our own mode
            applyMode = true;
        }

        if (!selModel.events) {
            // only config provided, set our mode if one doesn&#39;t exist on the config
            type = selModel.selType || me.selType;
            applyMode = !selModel.mode;
            selModel = me.selModel = Ext.create(&#39;selection.&#39; + type, selModel);
        }

        if (me.simpleSelect) {
            mode = &#39;SIMPLE&#39;;
        } else if (me.multiSelect) {
            mode = &#39;MULTI&#39;;
        }

        Ext.applyIf(selModel, {
            allowDeselect: me.allowDeselect
        });
        
        if (mode &amp;&amp; applyMode) {
            selModel.setSelectionMode(mode);
        }

        if (!selModel.hasRelaySetup) {
            me.relayEvents(selModel, [
                &#39;selectionchange&#39;, &#39;beforeselect&#39;, &#39;beforedeselect&#39;, &#39;select&#39;, &#39;deselect&#39;
            ]);
            selModel.hasRelaySetup = true;
            if (selModel.isRowModel) {
                selModel.on(&#39;selectionchange&#39;, me.updateBindSelection, me);
            }
        }

        // lock the selection model if user
        // has disabled selection
        if (me.disableSelection) {
            selModel.locked = true;
        }
        return selModel;
    },

<span id='Ext-panel-Table-method-getScrollTarget'>    getScrollTarget: function(){
</span>        var owner = this.getScrollerOwner(),
            items = owner.query(&#39;tableview&#39;);

        return items[1] || items[0];
    },

<span id='Ext-panel-Table-method-onHorizontalScroll'>    onHorizontalScroll: function(view) {
</span>        this.syncHorizontalScroll(view);
    },

<span id='Ext-panel-Table-method-syncHorizontalScroll'>    syncHorizontalScroll: function(target, setBody) {
</span>        var me = this,
            x = me.view.getScrollX(),
            scrollTarget;

        setBody = setBody === true;
        // Only set the horizontal scroll if we&#39;ve changed position,
        // so that we don&#39;t set this on vertical scrolls
        if (me.rendered &amp;&amp; (setBody || x !== me.scrollXPos)) {
            // Only set the body position if we&#39;re reacting to a refresh, otherwise
            // we just need to set the header.
            if (setBody) {   
                scrollTarget = me.getScrollTarget();
                scrollTarget.setScrollX(x);
            }
            me.headerCt.setScrollX(x);
            me.scrollXPos = x;
        }
    },

<span id='Ext-panel-Table-method-onStoreLoad'>    // template method meant to be overriden
</span>    onStoreLoad: Ext.emptyFn,

<span id='Ext-panel-Table-method-getEditorParent'>    getEditorParent: function() {
</span>        return this.body;
    },

<span id='Ext-panel-Table-method-bindStore'>    bindStore: function(store, initial) {
</span>        var me = this,
            view = me.getView(),
            bufferedRenderer = me.bufferedRenderer;

        // Normally, this method will always be called with a valid store (because there is a symmetric
        // .unbindStore method), but there are cases where this method will be called and passed a null
        // value, i.e., a panel is used as a pickerfield. See EXTJS-13089.
        if (store) {
            // Bind to store immediately because subsequent processing looks for grid&#39;s store property
            me.store = store;

            // If we&#39;re in a reconfigure (we already have a BufferedRenderer which is bound to our old store),
            // rebind the BufferedRenderer
            if (bufferedRenderer &amp;&amp; bufferedRenderer.isBufferedRenderer &amp;&amp; bufferedRenderer.store) {
                bufferedRenderer.bindStore(store);
            }

            if (view.store !== store) {
                // If coming from a reconfigure, we need to set the actual store property on the view. Setting the
                // store will then also set the dataSource.
                //
                // Note that if it&#39;s a grid feature then this is sorted out in view.bindStore(), and it&#39;s own
                // implementation of .bindStore() will be called.
                view.bindStore(store, false);
            }

            me.mon(store, {
                load: me.onStoreLoad,
                scope: me
            });
            me.storeRelayers = me.relayEvents(store, [
<span id='Ext-panel-Table-event-filterchange'>                /**
</span>                 * @event filterchange
                 * @inheritdoc Ext.data.Store#filterchange
                 */
                &#39;filterchange&#39;,
<span id='Ext-panel-Table-event-groupchange'>                /**
</span>                 * @event groupchange
                 * @inheritdoc Ext.data.Store#groupchange
                 */
                &#39;groupchange&#39;
            ]);
        } else {
            me.unbindStore();
        }
    },

<span id='Ext-panel-Table-method-unbindStore'>    unbindStore: function() {
</span>        var me = this,
            store = me.store,
            view;

        if (store) {
            me.store = null;

            me.mun(store, {
                load: me.onStoreLoad,
                scope: me
            });

            Ext.destroy(me.storeRelayers);

            view = me.view;
            if (view.store) {
                view.bindStore(null);
            }
        }
    },

<span id='Ext-panel-Table-method-setColumns'>    setColumns: function(columns) {
</span>        // If being reconfigured from zero columns to zero columns, skip operation.
        // This can happen if columns are being set from a binding and the initial value
        // of the bound data in the ViewModel is []
        if (columns.length || this.getColumnManager().getColumns().length) {
            this.reconfigure(undefined, columns);
        }
    },

<span id='Ext-panel-Table-method-setStore'>    setStore: function (store) {
</span>        this.reconfigure(store);
    },

<span id='Ext-panel-Table-method-reconfigure'>    /**
</span>     * @method reconfigure
     * Reconfigures the grid / tree with a new store/columns. Either the store or the 
     * columns can be omitted if you don&#39;t wish to change them.
     *
     * The {@link #enableLocking} config should be set to `true` before the reconfigure 
     * method is executed if locked columns are intended to be used.
     *
     * @param {Ext.data.Store} [store] The new store. You can pass `null` if no new store.
     * @param {Object[]} [columns] An array of column configs
     */
    reconfigure: function(store, columns) {
        var me = this,
            oldStore = me.store,
            headerCt = me.headerCt,
            oldColumns = headerCt ? headerCt.items.getRange() : me.columns;

        // Allow optional store argument to be fully omitted, and the columns argument to be solo
        if (arguments.length === 1 &amp;&amp; Ext.isArray(store)) {
            columns = store;
            store = null;
        }

        // Make copy in case the beforereconfigure listener mutates it.
        if (columns) {
            columns = Ext.Array.slice(columns);
        }

        me.reconfiguring = true;
        me.fireEvent(&#39;beforereconfigure&#39;, me, store, columns, oldStore, oldColumns);
        if (me.lockable) {
            me.reconfigureLockable(store, columns);
        } else {
            Ext.suspendLayouts();
            if (columns) {
                // new columns, delete scroll pos
                delete me.scrollXPos;
                headerCt.removeAll();
                headerCt.add(columns);
            }
            // The following test compares the result of an assignment of the store var with the oldStore var
            // This saves a large amount of code.
            if (store &amp;&amp; (store = Ext.StoreManager.lookup(store)) !== oldStore) {
                me.unbindStore();
                me.bindStore(store);
            } else {
                me.getView().refreshView();
            }
            Ext.resumeLayouts(true);
        }
        me.fireEvent(&#39;reconfigure&#39;, me, store, columns, oldStore, oldColumns);
        delete me.reconfiguring;
    },

<span id='Ext-panel-Table-method-beforeDestroy'>    beforeDestroy: function(){
</span>        var task = this.scrollTask;
        if (task) {
            task.cancel();
            this.scrollTask = null;
        }
        Ext.destroy(this.focusEnterLeaveListeners);
        this.callParent();
    },

<span id='Ext-panel-Table-method-onDestroy'>    onDestroy: function(){
</span>        var me = this;
        if (me.lockable) {
            me.destroyLockable();
        }
        me.unbindStore();
        me.callParent();
        me.columns = me.storeRelayers = me.columnManager = me.visibleColumnManager = null;
    },
    
<span id='Ext-panel-Table-method-destroy'>    destroy: function() {
</span>        // Clear out references here because other things (plugins/features) may need to know about them during destruction
        var me = this;
        me.callParent();
        if (me.isDestroyed) {
            me.view = me.selModel = me.headerCt = null;
        }
    },

<span id='Ext-panel-Table-property-privates'>    privates: {
</span>        getFocusEl: function() {
            return this.getView().getFocusEl();
        }
    }
});
</pre>
</body>
</html>
