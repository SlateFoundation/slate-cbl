/*

Siesta 4.0.6
Copyright(c) 2009-2016 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/products/siesta/license

*/
/**
 @class Siesta.Recorder.Recorder

Low level class which records the events of the window it's attached to. It records basic mouse and key events,
but does not record scroll events and other browser type events. Since it's JS based, we cannot record
native dialog interactions, such as alert, print or confirm etc.

It tries to coalesce certain event patterns into higher order events (click, drag etc).

*/
Class('Siesta.Recorder.Recorder', {

    does : [
        JooseX.Observable,
        Siesta.Util.Role.Dom,
        Siesta.Util.Role.CanParseOs
    ],

    has : {
        active              : null,

        extractor           : null,

        extractorClass      : Siesta.Recorder.TargetExtractor,

        extractorConfig     : null,

        /**
         * @cfg {Array[String]/String} uniqueComponentProperty A string or an array of strings, containing attribute names that the Recorder will use to identify Ext JS components.
         */
        uniqueComponentProperty : null,

        /**
         * @cfg {String} uniqueDomNodeProperty A property that will be used to uniquely identify DOM nodes.
         */
        uniqueDomNodeProperty : 'id',

        /**
         * @cfg {Boolean} recordOffsets true to record the offset to each targeted DOM element for recorded actions to make sure the recorded action can be played back with exact precision.
         * Should be avoided for most cases, to let Siesta pick the center of each target.
         */
        recordOffsets       : true,

        // ignore events generated by Siesta (bypass in normal use, but for testing recorder we need it)
        ignoreSynthetic     : true,

        // The window this recorder is observing for events
        window              : null,

        // Fire a mouseidle event if mouse doesn't move for a while.
        idleTimeout         : 3000,
        // console.logs all DOM events detected
        debugMode           : false,

        eventsToRecord      : {
            init : function () {
                return [
                    "keydown",
                    "keypress",
                    "keyup",

                    "click",
                    "dblclick",
                    "contextmenu",
                    "mousedown",
                    "mouseup"
                ];
            }
        },

        // "raw" log of all dom events
        events              : Joose.I.Array,

        actions             : Joose.I.Array,
        actionsByEventId    : Joose.I.Object,
        cursorPosition      : Joose.I.Array,

        swallowExceptions   : false,
        recordMouseMove     : true,
        mouseMoveTimerId    : null,
        windowResizeTimerId : null,
        dragPixelThreshold  : 3, // If mousedown/mouseup position differs by less, we consider it a click

        // If the mouse is moved upon a target matching these selectors, a moveCursorTo will be recorded
        moveCursorToSelectors   : Joose.I.Array,

        // our own private helper selectors
        _moveCursorToSelectors          : Joose.I.Array,
        moveCursorToSelectorsMatcher    : null,
        lastMoveCursorToEl              : null,
        lastMoveTimestamp               : null,
        actionClass                     : Siesta.Recorder.Action
    },


    methods : {

        initialize : function () {
            this.onUnload                       = this.onUnload.bind(this);
            this.onFrameLoad                    = this.onFrameLoad.bind(this);
            this.onDomEvent                     = this.onDomEvent.bind(this);
            this.resetMouseMoveListener         = this.resetMouseMoveListener.bind(this);
            this.onWindowResizeThrottler        = this.onWindowResizeThrottler.bind(this);
            this.throttledMouseMove             = this.throttleMouseMoveListener(this.onBodyMouseMove, this.idleTimeout);
            this.onBodyMouseOver                = this.onBodyMouseOver.bind(this);
            this.moveCursorToSelectorsMatcher   = this._moveCursorToSelectors.concat(this.moveCursorToSelectors).join(',');

            var extractorConfig = this.extractorConfig || {}

            extractorConfig.uniqueComponentProperty = extractorConfig.uniqueComponentProperty || this.uniqueComponentProperty;
            extractorConfig.uniqueDomNodeProperty = extractorConfig.uniqueDomNodeProperty || this.uniqueDomNodeProperty;
            extractorConfig.swallowExceptions = this.swallowExceptions;

            this.extractor                  = new this.extractorClass(extractorConfig);
        },


        isSamePoint : function (event1, event2) {
            return Math.abs(event1.x - event2.x) <= this.dragPixelThreshold &&
                   Math.abs(event1.y - event2.y) <= this.dragPixelThreshold;
        },

        isSameTarget : function(event1, event2) {
            return event1.target == event2.target || this.contains(event1.target, event2.target) || this.contains(event2.target, event1.target);
        },


        clear          : function () {
            this.events     = []
            this.actions    = []

            this.fireEvent('clear', this)
        },


        // We monitor page loads so the recorder can add a waitForPageLoad action
        onUnload : function () {
            var actions = this.actions,
                last = actions.length && actions[actions.length - 1];

            if (last && last.target) {
                last.waitForPageLoad = true;
            }
        },

        // After frame has loaded, stop listening to old window and restart on new frame window
        onFrameLoad    : function (event) {
            this.stop();

            this.attach(event.target.contentWindow);

            this.start();
        },

        /*
         * Attaches the recorder to a Window object
         * @param {Window} window The window to attach to.
         **/
        attach         : function (window) {
            if (this.window !== window) {
                this.stop()
            }

            // clear only events, keep the actions
            this.events = []

            this.window = window;
        },

        /*
         * Starts recording events of the current Window object
         **/
        start          : function () {
            this.stop();

            this.active         = Date.now();
            this.onStart();
            this.fireEvent('start', this);
        },

        /*
         * Stops the recording of events
         **/
        stop           : function () {
            if (this.active) {
                this.active     = null;
                this.onStop();
                this.fireEvent('stop', this);
            }
        },


        getRecordedEvents : function () {
            return this.events;
        },


        getRecordedActions : function () {
            return this.actions
        },


        getRecordedActionsAsSteps : function () {
            return Joose.A.map(this.actions, function (action) {
                return action.asStep()
            })
        },


        onDomEvent : function (e) {
            if (this.swallowExceptions) {
                // extra protection from the exceptions from the recorder itself
                try {
                    this.processDomEvent(e);
                } catch(e) {
                    this.fireEvent('exception', e);
                }
            } else {
                this.processDomEvent(e);
            }

            if (this.getException()) {
                this.fireEvent('exception', this.getException());
            }
        },

        processDomEvent : function (e) {
            var target          = e.target

            if (this.debugMode) {
                console.log(e.type, target, e.keyIdentifier || e.key);
            }

            // Never trust IE - target may be absent
            // Ignore events from played back test (if user plays test and records before it's stopped)
            if (!target || (this.ignoreSynthetic && e.synthetic)) return;

            var eventType       = e.type
            var isKeyEvent      = eventType.match(/^key/)

            var keys            = Siesta.Test.Simulate.KeyCodes().keys

            // Ignore special keys which are used only in combination with other keys
            if (isKeyEvent && (e.keyCode === keys.SHIFT || e.keyCode === keys.CTRL || e.keyCode === keys.ALT)) return;

            var event           = Siesta.Recorder.Event.fromDomEvent(e)

            // this "reset" will ensure that "onBodyMouseMove" handler will be called after "idleTimeout"
            // after any other dom event
            this.resetMouseMoveListener();

            this.convertToAction(event)

            this.events.push(event)

            this.fireEvent('domevent', event)
        },


        eventToAction : function (event, actionName) {
            var type        = event.type

            if (!actionName)
                if (type.match(/^key/))
                    // convert all key events to type for now
                    actionName  = 'type'
                else
                    actionName  = type

            var config      = {
                action          : actionName,

                target          : this.extractor.getTargets(event, true, this.recordOffsets),

                options         : event.options,

                sourceEvent     : event
            }

            // `window` object to which the event target belongs
            var win             = event.target.ownerDocument.defaultView;

            // Case of nested iframe
            if (win !== this.window) {

                if (!win.frameElement.id) {
                    throw 'To record events in a nested iframe, please set an "id" property on your frames';
                }

                // Prepend the frame id to each suggested target
                config.target = config.target.filter(function(actionTarget) {
                    if (typeof(actionTarget.target) === 'string') {
                        actionTarget.target = '#' + win.frameElement.id + ' -> ' + actionTarget.target;

                        return true;
                    }
                    // Skip array coordinates for nested iframes, make little sense
                    return false;
                });
            }

            return new this.actionClass(config)
        },


        recordAsAction : function (event, actionName) {
            var action      = this.eventToAction(event, actionName)

            if (action) {
                this.addAction(action)
            }
        },


        addAction : function (action) {
            if (!(action instanceof this.actionClass)) {
                action = new this.actionClass(action);
            }

            this.beforeAddAction(action);

            this.actions.push(action)
            if (action.sourceEvent) this.actionsByEventId[ action.sourceEvent.id ] = action

            this.fireEvent('actionadd', action)
        },


        removeAction : function (actionToRemove) {
            var actions     = this.actions;

            for (var i = 0; i < actions.length; i++) {
                var action  = actions[ i ]

                if (action == actionToRemove) {
                    actions.splice(i, 1)

                    if (action.sourceEvent) delete this.actionsByEventId[ action.sourceEvent.id ]

                    this.fireEvent('actionremove', actionToRemove)
                    break;
                }
            }
        },


        removeActionByEventId : function (eventId) {
            this.removeAction(this.getActionByEventId(eventId))
        },


        removeActionByEvent : function (event) {
            this.removeAction(this.getActionByEventId(event.id))
        },


        getActionByEventId : function (eventId) {
            return this.actionsByEventId[ eventId ]
        },


        getLastAction : function () {
            return this.actions[ this.actions.length - 1 ]
        },

        getLastEvent : function () {
            return this.events[ this.events.length - 1 ]
        },


        canCombineTypeActions : function (prevOptions, curOptions) {
            return prevOptions.ctrlKey == curOptions.ctrlKey &&
                prevOptions.metaKey == curOptions.metaKey &&
                prevOptions.altKey == curOptions.altKey;
        },


        // Method which tries to identify "composite" DOM interactions such as 'click/contextmenu' (3 events), double click
        // but also complex scenarios such as 'drag'
        convertToAction : function (event) {
            var type        = event.type

            if (type == 'keypress' || type == 'keyup' || type == 'keydown') {
                this.convertKeyEventToAction(event);
                return
            }

            var events      = this.getRecordedEvents(),
                length      = events.length,
                tail        = this.getLastEvent();

            // if there's no already recorded events - there's nothing to coalsce
            if (!length) {
                this.recordAsAction(event)

                return
            }

            var tail        = events[ length - 1 ],
                tailPrev    = length >= 2 ? events[ length - 2 ] : null;

            var tailType    = tail.type

            // when user clicks on the <label> with "for" attribute 2 "click" events are triggered
            // just ignore the 2nd event and not record it as action
            // in FF, the 2nd "click" will have 0, 0 coordinates, so we have to disable `isSamePoint` extra sanity check
            if (type == 'click' && tailType == 'click' /*&& this.isSamePoint(event, tail)*/ && tail.target.getAttribute('for')) {
                return
            }

            if (type == 'dblclick') {
                // removing the last `click` action - one click event will still remain
                this.removeAction(this.getLastAction())

                this.getLastAction().action = 'dblclick'

                this.fireEvent('actionupdate', this.getLastAction())

                return
            }


            // if mousedown/up happened in a row in different points - this is considered to be a drag operation
            if (tailType == 'mousedown' && type == 'mouseup' && event.button == tail.button && !this.isSamePoint(event, tail)) {
                var lastAction      = this.getLastAction()

                // if we've recorded "moveCursorTo" in between mousedown / up (we don't record mousemove, so tail event will be still
                // mousedown) then we don't need to convert "mouseup" into drag
                if (lastAction.action != 'moveCursorTo') {
                    lastAction.action   = 'drag'

                    lastAction.by       = [ event.x - tail.x, event.y - tail.y ]

    //                var toTarget        = new Siesta.Recorder.Target({ targets : this.extractor.getTargets(event) })
    //
    //                if (!toTarget.isTooGeneric()) lastAction.toTarget = toTarget

                    this.fireEvent('actionupdate', lastAction)

                    return
                } else if (lastAction.sourceEvent && !this.isSamePoint(event, lastAction.sourceEvent)) {
                    this.addMoveCursorAction(event, this.recordOffsets)

                    // the `mouseup` action will be recorded as the last `this.recordAsAction(event)` statement
                }
            }

            // In some situations the mouseup event may remove/overwrite the current element and no click will be triggered
            // so we need to catch drag operation on mouseup (see above) and ignore following "click" event
            if (type === 'click' && this.getLastAction() && this.getLastAction().action === 'drag') {
                return
            }

            // On Mac ignore mouseup happening after contextmenu
            if (type == 'mouseup' && tailType === 'contextmenu') {
                return
            }

            if (tailPrev && type === 'click') {
                if (
                    // Verify tail
                    tailType == 'mouseup' &&
                    event.button == tail.button &&
                    event.button == tailPrev.button &&
                    this.isSamePoint(event, tail) &&

                    // Verify previous tail
                    tailPrev.type == 'mousedown' &&
                    this.isSameTarget(event, tail) &&
                    this.isSameTarget(event, tailPrev) &&
                    this.isSamePoint(event, tailPrev)
                ) {
                    this.removeActionByEvent(tailPrev)
                    this.removeActionByEvent(tail)

                    // reuse mousedown event info, since that has the correct initial target information. Target may have been changed by mousedown/mouseup.
                    var props = ['timestamp', 'options', 'x', 'y', 'target', 'charCode', 'keyCode', 'button'];

                    props.forEach(function(prop) {
                        event[prop] = tailPrev[prop];
                    });
                }
            } else if (type === 'contextmenu') {
                // Verify tail (Mac OSX doesn't fire mouse up)
                if ((tailType == 'mouseup' || tailType == 'mousedown') && event.button == tail.button && this.isSamePoint(event, tail)) {
                    this.removeActionByEvent(tail)
                }
                // Verify previous tail
                if (tailType == 'mouseup' && tailPrev.type == 'mousedown' &&
                    this.isSameTarget(event, tail) &&
                    this.isSameTarget(event, tailPrev) &&
                    this.isSamePoint(event, tailPrev)) {
                    this.removeActionByEvent(tailPrev)
                }
            }

            this.recordAsAction(event)
        },

        convertKeyEventToAction : function (event) {
            var type            = event.type
            var tail            = this.getLastEvent();
            var KC              = Siesta.Test.Simulate.KeyCodes();
            var isSpecial       = type == 'keydown' && (KC.isSpecial(event.keyCode) || KC.isNav(event.keyCode));
            var isModifier      = KC.isModifier(event.keyCode);
            var options         = event.options;
            var prevType        = tail && tail.type;
            var prevSpecial     = type == 'keypress' && prevType == 'keydown' && (KC.isSpecial(tail.keyCode) || KC.isNav(tail.keyCode));
            var isWindows       = this.parseOS(navigator.platform) === 'Windows';
            var isMac           = this.parseOS(navigator.platform) === 'MacOS';

            // On Windows, no keypress is triggered if CTRL key is pressed along with a regular char (e.g Ctrl-C).
            // On Mac, no keypress is triggered if CMD key is pressed along with a regular char (e.g Cmd-C).
            if (type == 'keypress' && !isSpecial && !prevSpecial || (type == 'keydown' && (isSpecial || isModifier || (isWindows && options.ctrlKey) || (isMac && options.metaKey)))) {
                var lastAction      = this.getLastAction()

                var text            = isSpecial ? '[' + KC.fromCharCode(event.charCode, true) + ']' : String.fromCharCode(event.charCode);
                // Crude check to make sure we don't merge a CTRL-C with the next "normal" keystroke
                if (lastAction && lastAction.action === 'type' && this.canCombineTypeActions(lastAction.options, event.options)) {
                    if (!KC.isModifier(event.keyCode)){
                        lastAction.value += text

                        this.fireEvent('actionupdate', lastAction)
                    }
                } else {
                    this.addAction({
                        action          : 'type',

                        value           : text,

                        sourceEvent     : event,
                        options         : event.options
                    })
                }

                return
            }

            // ignore 'keydown' events
        },


        onStart : function () {
            var me              = this,
                window          = me.window,
                doc             = window.document,
                body            = doc.body,
                resizeTimeout   = null,
                frameWindows    = this.getNestedFrames().map(function(frame) { return frame.contentWindow; });

            // Listen to test window and any frames nested in it
            [ window ].concat(frameWindows).forEach(function (win) {
                me.registerWindowListeners(win);

                win.frameElement && win.frameElement.addEventListener('load', function() {
                    me.registerWindowListeners(win);
                });
            })

            if (this.recordMouseMove) {
                if (this.moveCursorToSelectorsMatcher) {
                    body.addEventListener('mouseover', this.onBodyMouseOver);
                    this.lastMoveCursorToEl = null;
                }
                body.addEventListener('mousemove', this.throttledMouseMove, true);
                body.addEventListener('mouseleave', this.resetMouseMoveListener);
            }

            window.frameElement && window.frameElement.addEventListener('load', this.onFrameLoad);
            window.addEventListener('unload', this.onUnload);
            window.addEventListener('resize', this.onWindowResizeThrottler);
        },


        registerWindowListeners : function (win) {
            var me = this;

            // We might not have access to the frame window if it's in another domain
            try {
                var foo = win.document;
            } catch(e) {
                return;
            }

            // Safari doesn't throw exception when trying to access x-domain frames
            if (!foo) return;

            me.eventsToRecord.forEach(function (name) {
                win.document.addEventListener(name, me.onDomEvent, true);
            });
        },


        deregisterWindowListeners : function (win) {
            var me = this;

            try {
                var foo = win.document;
            } catch(e) { return; }

            me.eventsToRecord.forEach(function (name) {
                win.document.removeEventListener(name, me.onDomEvent, true);
            });
        },

        // Returns only frames on the same domain
        getNestedFrames : function() {
            var testWindow      = this.window,
                doc             = testWindow.document;

            return Array.prototype.slice.apply(doc.getElementsByTagName('iframe')).filter(function(frame) {
                try {
                    var foo = frame.contentWindow.document;
                } catch(e) { return false; }

                return true;
            });
        },

        onStop : function () {
            var me              = this,
                testWindow      = me.window,
                doc             = testWindow.document,
                body            = doc.body,
                frameWindows    = this.getNestedFrames().map(function(frame) { return frame.contentWindow; });

            // Unlisten to test window and any frames nested in it
            [ testWindow ].concat(frameWindows).forEach(function (win) {
                me.deregisterWindowListeners(win);

                win.frameElement && win.frameElement.addEventListener('unload', function() {
                    me.deregisterWindowListeners(win);
                });
            })

            if (this.recordMouseMove) {
                if (this.moveCursorToSelectorsMatcher) {
                    body.removeEventListener('mouseover', this.onBodyMouseOver);
                    this.lastMoveCursorToEl = null;
                }
                body.removeEventListener('mousemove', this.throttledMouseMove, true);
                body.removeEventListener('mouseleave', this.resetMouseMoveListener);
            }

            testWindow.frameElement && testWindow.frameElement.removeEventListener('load', this.onFrameLoad);
            testWindow.removeEventListener('unload', this.onUnload);
            testWindow.removeEventListener('resize', this.onWindowResizeThrottler);

            this.resetMouseMoveListener()
        },


        resetMouseMoveListener : function () {
            clearTimeout(this.mouseMoveTimerId);
        },

        // This allows a user to indicate that the cursor should be move to a certain place
        // if mouse is still for a period (idleTimeout) of time.
        onBodyMouseMove        : function (e, recordOffsets) {
            if (this.swallowExceptions) {
                // handling exceptions from the recorder itself
                try {
                    this.processBodyMouseMove(e, recordOffsets);
                } catch(e) {
                    this.fireEvent('exception', e);
                }
            } else {
                this.processBodyMouseMove(e, recordOffsets);
            }

            if (this.getException()) {
                this.fireEvent('exception', this.getException());
            }
        },

        onBodyMouseOver : function(e) {
            var target = e.target;

            if (this.is(target, this.moveCursorToSelectorsMatcher) ||
                (target = this.closest(e.target, this.moveCursorToSelectorsMatcher, 3))) {

                if (target !== this.lastMoveCursorToEl) {
                    var docEl       = this.window.document.documentElement;

                    var evtData = {
                        type      : e.type,
                        target    : target,
                        timeStamp : Date.now(),
                        options   : e.options,
                        clientX   : e.clientX,
                        clientY   : e.clientY,
                        pageX     : e.clientX + docEl.scrollLeft,
                        pageY     : e.clientY + docEl.scrollTop
                    };

                    this.onBodyMouseMove(evtData, false);
                    this.lastMoveCursorToEl = target;
                }
            }
        },

        processBodyMouseMove : function (e, recordOffsets) {
            // Skip test playback events and mouse moves in frames
            if ((this.ignoreSynthetic && e.synthetic) || e.target.ownerDocument !== this.window.document) return;

            // Avoid duplicate events
            if (this.lastMoveCursorToEl === e.target || this.contains(this.lastMoveCursorToEl, e.target, 3)) return;

            var mouseMoveEvent  = new Siesta.Recorder.Event.fromDomEvent(e)

            recordOffsets = recordOffsets !== undefined ? recordOffsets : this.recordOffsets;

            this.addMoveCursorAction(mouseMoveEvent, recordOffsets);
        },


        throttleMouseMoveListener : function (fn, threshhold) {
            var last,
                me = this;

            return function (event) {
                var now         = Date.now();
                var docEl       = me.window.document.documentElement;

                me.lastMoveTimestamp = now;

                // No access to pageX/pageY in IE9
                me.cursorPosition[0] = event.clientX + docEl.scrollLeft;
                me.cursorPosition[1] = event.clientY + docEl.scrollTop;

                if (last && now < last + threshhold) {
                    var args = arguments;

                    clearTimeout(me.mouseMoveTimerId);

                    me.mouseMoveTimerId = setTimeout(function () {
                        last    = now;
                        fn.apply(me, args);
                    }, threshhold);
                } else {
                    last        = now;
                }
            };
        },

        onWindowResizeThrottler : function (e) {
            if ( !this.windowResizeTimerId ) {
                var me = this;
                this.windowResizeTimerId = setTimeout(function() {
                    me.windowResizeTimerId = null;
                    me.onWindowResize(e);
                }, 500);
            }
        },

        onWindowResize : function(event) {
            var win = this.window;

            if (win) {
                var d            = win.document;
                var windowWidth  = win.innerWidth || d.documentElement.clientWidth || d.body.clientWidth,
                    windowHeight = win.innerHeight || d.documentElement.clientHeight || d.body.clientHeight;

                this.addAction({
                    action          : 'setWindowSize',
                    value           : [windowWidth, windowHeight],
                    sourceEvent     : event
                })
            }
        },

        // Returns an exception that happened during target extraction
        getException : function() {
            return this.extractor.exception;
        },

        // Hook called before adding actions to inject 'helping' actions
        beforeAddAction : function(action) {
        },

        addMoveCursorAction : function(event, recordOffsets) {
            this.addAction({
                action          : 'moveCursorTo',

                target          : this.extractor.getTargets(event, true, recordOffsets),

                sourceEvent     : event,
                options         : event.options
            })
        }
    }
    // eof methods
});
