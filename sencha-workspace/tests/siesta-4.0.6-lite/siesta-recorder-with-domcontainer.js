;!function () {;
var Joose = {}

// configuration hash

Joose.C             = typeof JOOSE_CFG != 'undefined' ? JOOSE_CFG : {}

Joose.is_IE         = '\v' == 'v'
Joose.is_NodeJS     = Boolean(typeof process != 'undefined' && process.pid)


Joose.top           = Joose.is_NodeJS && global || this

Joose.stub          = function () {
    return function () { throw new Error("Modules can not be instantiated") }
}


Joose.VERSION       = ({ /*PKGVERSION*/VERSION : '3.50.1' }).VERSION


if (typeof module != 'undefined') module.exports = Joose
/*if (!Joose.is_NodeJS) */
this.Joose = Joose


// Static helpers for Arrays
Joose.A = {

    each : function (array, func, scope) {
        scope = scope || this
        
        for (var i = 0, len = array.length; i < len; i++) 
            if (func.call(scope, array[i], i) === false) return false
    },
    
    
    eachR : function (array, func, scope) {
        scope = scope || this

        for (var i = array.length - 1; i >= 0; i--) 
            if (func.call(scope, array[i], i) === false) return false
    },
    
    
    exists : function (array, value) {
        for (var i = 0, len = array.length; i < len; i++) if (array[i] == value) return true
            
        return false
    },
    
    
    map : function (array, func, scope) {
        scope = scope || this
        
        var res = []
        
        for (var i = 0, len = array.length; i < len; i++) 
            res.push( func.call(scope, array[i], i) )
            
        return res
    },
    

    grep : function (array, func) {
        var a = []
        
        Joose.A.each(array, function (t) {
            if (func(t)) a.push(t)
        })
        
        return a
    },
    
    
    remove : function (array, removeEle) {
        var a = []
        
        Joose.A.each(array, function (t) {
            if (t !== removeEle) a.push(t)
        })
        
        return a
    }
    
}

// Static helpers for Strings
Joose.S = {
    
    saneSplit : function (str, delimeter) {
        var res = (str || '').split(delimeter)
        
        if (res.length == 1 && !res[0]) res.shift()
        
        return res
    },
    

    uppercaseFirst : function (string) { 
        return string.substr(0, 1).toUpperCase() + string.substr(1, string.length - 1)
    },
    
    
    strToClass : function (name, top) {
        var current = top || Joose.top
        
        Joose.A.each(name.split('.'), function (segment) {
            if (current) 
                current = current[ segment ]
            else
                return false
        })
        
        return current
    }
}

var baseFunc    = function () {}

var enumProps   = [ 'hasOwnProperty', 'valueOf', 'toString', 'constructor' ]

var manualEnum  = true

for (var i in { toString : 1 }) manualEnum = false


// Static helpers for objects
Joose.O = {

    each : function (object, func, scope) {
        scope = scope || this
        
        for (var i in object) 
            if (func.call(scope, object[i], i) === false) return false
        
        if (manualEnum) 
            return Joose.A.each(enumProps, function (el) {
                
                if (object.hasOwnProperty(el)) return func.call(scope, object[el], el)
            })
    },
    
    
    eachOwn : function (object, func, scope) {
        scope = scope || this
        
        return Joose.O.each(object, function (value, name) {
            if (object.hasOwnProperty(name)) return func.call(scope, value, name)
        }, scope)
    },
    
    
    copy : function (source, target) {
        target = target || {}
        
        Joose.O.each(source, function (value, name) { target[name] = value })
        
        return target
    },
    
    
    copyOwn : function (source, target) {
        target = target || {}
        
        Joose.O.eachOwn(source, function (value, name) { target[name] = value })
        
        return target
    },
    
    
    getMutableCopy : function (object) {
        baseFunc.prototype = object
        
        return new baseFunc()
    },
    
    
    extend : function (target, source) {
        return Joose.O.copy(source, target)
    },
    
    
    isEmpty : function (object) {
        for (var i in object) if (object.hasOwnProperty(i)) return false
        
        return true
    },
    
    
    isInstance: function (obj) {
        return obj && obj.meta && obj.constructor == obj.meta.c
    },
    
    
    isClass : function (obj) {
        return obj && obj.meta && obj.meta.c == obj
    },
    
    
    wantArray : function (obj) {
        if (obj instanceof Array) return obj
        
        return [ obj ]
    },
    
    
    // this was a bug in WebKit, which gives typeof / / == 'function'
    // should be monitored and removed at some point in the future
    isFunction : function (obj) {
        return typeof obj == 'function' && obj.constructor != / /.constructor
    }
}


//initializers

Joose.I = {
    Array       : function () { return [] },
    Object      : function () { return {} },
    Function    : function () { return arguments.callee },
    Now         : function () { return new Date() }
};
Joose.Proto = Joose.stub()

Joose.Proto.Empty = Joose.stub()
    
Joose.Proto.Empty.meta = {};
;(function () {

    Joose.Proto.Object = Joose.stub()
    
    
    var SUPER = function () {
        var self = SUPER.caller
        
        if (self == SUPERARG) self = self.caller
        
        if (!self.SUPER) throw "Invalid call to SUPER"
        
        return self.SUPER[self.methodName].apply(this, arguments)
    }
    
    
    var SUPERARG = function () {
        return this.SUPER.apply(this, arguments[0])
    }
    
    
    
    Joose.Proto.Object.prototype = {
        
        SUPERARG : SUPERARG,
        SUPER : SUPER,
        
        INNER : function () {
            throw "Invalid call to INNER"
        },                
        
        
        BUILD : function (config) {
            return arguments.length == 1 && typeof config == 'object' && config || {}
        },
        
        
        initialize: function () {
        },
        
        
        toString: function () {
            return "a " + this.meta.name
        }
        
    }
        
    Joose.Proto.Object.meta = {
        constructor     : Joose.Proto.Object,
        
        methods         : Joose.O.copy(Joose.Proto.Object.prototype),
        attributes      : {}
    }
    
    Joose.Proto.Object.prototype.meta = Joose.Proto.Object.meta

})();
;(function () {

    Joose.Proto.Class = function () {
        return this.initialize(this.BUILD.apply(this, arguments)) || this
    }
    
    var bootstrap = {
        
        VERSION             : null,
        AUTHORITY           : null,
        
        constructor         : Joose.Proto.Class,
        superClass          : null,
        
        name                : null,
        
        attributes          : null,
        methods             : null,
        
        meta                : null,
        c                   : null,
        
        defaultSuperClass   : Joose.Proto.Object,
        
        
        BUILD : function (name, extend) {
            this.name = name
            
            return { __extend__ : extend || {} }
        },
        
        
        initialize: function (props) {
            var extend      = props.__extend__
            
            this.VERSION    = extend.VERSION
            this.AUTHORITY  = extend.AUTHORITY
            
            delete extend.VERSION
            delete extend.AUTHORITY
            
            this.c = this.extractConstructor(extend)
            
            this.adaptConstructor(this.c)
            
            if (extend.constructorOnly) {
                delete extend.constructorOnly
                return
            }
            
            this.construct(extend)
        },
        
        
        construct : function (extend) {
            if (!this.prepareProps(extend)) return
            
            var superClass = this.superClass = this.extractSuperClass(extend)
            
            this.processSuperClass(superClass)
            
            this.adaptPrototype(this.c.prototype)
            
            this.finalize(extend)
        },
        
        
        finalize : function (extend) {
            this.processStem(extend)
            
            this.extend(extend)
        },
        
        
        //if the extension returns false from this method it should re-enter 'construct'
        prepareProps : function (extend) {
            return true
        },
        
        
        extractConstructor : function (extend) {
            var res = extend.hasOwnProperty('constructor') ? extend.constructor : this.defaultConstructor()
            
            delete extend.constructor
            
            return res
        },
        
        
        extractSuperClass : function (extend) {
            if (extend.hasOwnProperty('isa') && !extend.isa) throw new Error("Attempt to inherit from undefined superclass [" + this.name + "]")
            
            var res = extend.isa || this.defaultSuperClass
            
            delete extend.isa
            
            return res
        },
        
        
        processStem : function () {
            var superMeta       = this.superClass.meta
            
            this.methods        = Joose.O.getMutableCopy(superMeta.methods || {})
            this.attributes     = Joose.O.getMutableCopy(superMeta.attributes || {})
        },
        
        
        initInstance : function (instance, props) {
            Joose.O.copyOwn(props, instance)
        },
        
        
        defaultConstructor: function () {
            return function (arg) {
                var BUILD = this.BUILD
                
                var args = BUILD && BUILD.apply(this, arguments) || arg || {}
                
                var thisMeta    = this.meta
                
                thisMeta.initInstance(this, args)
                
                return thisMeta.hasMethod('initialize') && this.initialize(args) || this
            }
        },
        
        
        processSuperClass: function (superClass) {
            var superProto      = superClass.prototype
            
            //non-Joose superclasses
            if (!superClass.meta) {
                
                var extend = Joose.O.copy(superProto)
                
                extend.isa = Joose.Proto.Empty
                // clear potential value in the `extend.constructor` to prevent it from being modified
                delete extend.constructor
                
                var meta = new this.defaultSuperClass.meta.constructor(null, extend)
                
                superClass.meta = superProto.meta = meta
                
                meta.c = superClass
            }
            
            this.c.prototype    = Joose.O.getMutableCopy(superProto)
            this.c.superClass   = superProto
        },
        
        
        adaptConstructor: function (c) {
            c.meta = this
            
            if (!c.hasOwnProperty('toString')) c.toString = function () { return this.meta.name }
        },
    
        
        adaptPrototype: function (proto) {
            //this will fix weird semantic of native "constructor" property to more intuitive (idea borrowed from Ext)
            proto.constructor   = this.c
            proto.meta          = this
        },
        
        
        addMethod: function (name, func) {
            func.SUPER = this.superClass.prototype
            
            //chrome don't allow to redefine the "name" property
            func.methodName = name
            
            this.methods[name] = func
            this.c.prototype[name] = func
        },
        
        
        addAttribute: function (name, init) {
            this.attributes[name] = init
            this.c.prototype[name] = init
        },
        
        
        removeMethod : function (name) {
            delete this.methods[name]
            delete this.c.prototype[name]
        },
    
        
        removeAttribute: function (name) {
            delete this.attributes[name]
            delete this.c.prototype[name]
        },
        
        
        hasMethod: function (name) { 
            return Boolean(this.methods[name])
        },
        
        
        hasAttribute: function (name) { 
            return this.attributes[name] !== undefined
        },
        
    
        hasOwnMethod: function (name) { 
            return this.hasMethod(name) && this.methods.hasOwnProperty(name)
        },
        
        
        hasOwnAttribute: function (name) { 
            return this.hasAttribute(name) && this.attributes.hasOwnProperty(name)
        },
        
        
        extend : function (props) {
            Joose.O.eachOwn(props, function (value, name) {
                if (name != 'meta' && name != 'constructor') 
                    if (Joose.O.isFunction(value) && !value.meta) 
                        this.addMethod(name, value) 
                    else 
                        this.addAttribute(name, value)
            }, this)
        },
        
        
        subClassOf : function (classObject, extend) {
            return this.subClass(extend, null, classObject)
        },
    
    
        subClass : function (extend, name, classObject) {
            extend      = extend        || {}
            extend.isa  = classObject   || this.c
            
            return new this.constructor(name, extend).c
        },
        
        
        instantiate : function () {
            var f = function () {}
            
            f.prototype = this.c.prototype
            
            var obj = new f()
            
            return this.c.apply(obj, arguments) || obj
        }
    }
    
    //micro bootstraping
    
    Joose.Proto.Class.prototype = Joose.O.getMutableCopy(Joose.Proto.Object.prototype)
    
    Joose.O.extend(Joose.Proto.Class.prototype, bootstrap)
    
    Joose.Proto.Class.prototype.meta = new Joose.Proto.Class('Joose.Proto.Class', bootstrap)
    
    
    
    Joose.Proto.Class.meta.addMethod('isa', function (someClass) {
        var f = function () {}
        
        f.prototype = this.c.prototype
        
        return new f() instanceof someClass
    })
})();
Joose.Managed = Joose.stub()

Joose.Managed.Property = new Joose.Proto.Class('Joose.Managed.Property', {
    
    name            : null,
    
    init            : null,
    value           : null,
    
    definedIn       : null,
    
    
    initialize : function (props) {
        Joose.Managed.Property.superClass.initialize.call(this, props)
        
        this.computeValue()
    },
    
    
    computeValue : function () {
        this.value = this.init
    },    
    
    
    //targetClass is still open at this stage
    preApply : function (targetClass) {
    },
    

    //targetClass is already open at this stage
    postUnApply : function (targetClass) {
    },
    
    
    apply : function (target) {
        target[this.name] = this.value
    },
    
    
    isAppliedTo : function (target) {
        return target[this.name] == this.value
    },
    
    
    unapply : function (from) {
        if (!this.isAppliedTo(from)) throw "Unapply of property [" + this.name + "] from [" + from + "] failed"
        
        delete from[this.name]
    },
    
    
    cloneProps : function () {
        return {
            name        : this.name, 
            init        : this.init,
            definedIn   : this.definedIn
        }
    },

    
    clone : function (name) {
        var props = this.cloneProps()
        
        props.name = name || props.name
        
        return new this.constructor(props)
    }
    
    
}).c;
Joose.Managed.Property.ConflictMarker = new Joose.Proto.Class('Joose.Managed.Property.ConflictMarker', {
    
    isa : Joose.Managed.Property,

    apply : function (target) {
        throw new Error("Attempt to apply ConflictMarker [" + this.name + "] to [" + target + "]")
    }
    
}).c;
Joose.Managed.Property.Requirement = new Joose.Proto.Class('Joose.Managed.Property.Requirement', {
    
    isa : Joose.Managed.Property,

    
    apply : function (target) {
        if (!target.meta.hasMethod(this.name)) 
            throw new Error("Requirement [" + this.name + "], defined in [" + this.definedIn.definedIn.name + "] is not satisfied for class [" + target + "]")
    },
    
    
    unapply : function (from) {
    }
    
}).c;
Joose.Managed.Property.Attribute = new Joose.Proto.Class('Joose.Managed.Property.Attribute', {
    
    isa : Joose.Managed.Property,
    
    slot                : null,
    
    
    initialize : function () {
        Joose.Managed.Property.Attribute.superClass.initialize.apply(this, arguments)
        
        this.slot = this.name
    },
    
    
    apply : function (target) {
        target.prototype[ this.slot ] = this.value
    },
    
    
    isAppliedTo : function (target) {
        return target.prototype[ this.slot ] == this.value
    },
    
    
    unapply : function (from) {
        if (!this.isAppliedTo(from)) throw "Unapply of property [" + this.name + "] from [" + from + "] failed"
        
        delete from.prototype[this.slot]
    },
    
    
    clearValue : function (instance) {
        delete instance[ this.slot ]
    },
    
    
    hasValue : function (instance) {
        return instance.hasOwnProperty(this.slot)
    },
        
        
    getRawValueFrom : function (instance) {
        return instance[ this.slot ]
    },
    
    
    setRawValueTo : function (instance, value) {
        instance[ this.slot ] = value
        
        return this
    }
    
}).c;
Joose.Managed.Property.MethodModifier = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier', {
    
    isa : Joose.Managed.Property,

    
    prepareWrapper : function () {
        throw "Abstract method [prepareWrapper] of " + this + " was called"
    },
    
    
    apply : function (target) {
        var name            = this.name
        var targetProto     = target.prototype
        var isOwn           = targetProto.hasOwnProperty(name)
        var original        = targetProto[name]
        var superProto      = target.meta.superClass.prototype
        
        
        var originalCall = isOwn ? original : function () { 
            return superProto[name].apply(this, arguments) 
        }
        
        var methodWrapper = this.prepareWrapper({
            name            : name,
            modifier        : this.value, 
            
            isOwn           : isOwn,
            originalCall    : originalCall, 
            
            superProto      : superProto,
            
            target          : target
        })
        
        if (isOwn) methodWrapper.__ORIGINAL__ = original
        
        methodWrapper.__CONTAIN__   = this.value
        methodWrapper.__METHOD__    = this
        this.value.displayName      = this.getDisplayName(target)
        methodWrapper.displayName   = 'internal wrapper' 
        
        targetProto[name] = methodWrapper
    },
    
    
    getDisplayName : function (target) {
        return target.meta.name + '[' + this.name + ']'
    },
    
    
    isAppliedTo : function (target) {
        var targetCont = target.prototype[this.name]
        
        return targetCont && targetCont.__CONTAIN__ == this.value
    },
    
    
    unapply : function (from) {
        var name = this.name
        var fromProto = from.prototype
        var original = fromProto[name].__ORIGINAL__
        
        if (!this.isAppliedTo(from)) throw "Unapply of method [" + name + "] from class [" + from + "] failed"
        
        //if modifier was applied to own method - restore it
        if (original) 
            fromProto[name] = original
        //otherwise - just delete it, to reveal the inherited method 
        else
            delete fromProto[name]
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Override = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Override', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        var superProto      = params.superProto
        var superMetaConst  = superProto.meta.constructor
        
        //call to Joose.Proto level, require some additional processing
        var isCallToProto = (superMetaConst == Joose.Proto.Class || superMetaConst == Joose.Proto.Object) && !(params.isOwn && originalCall.IS_OVERRIDE) 
        
        var original = originalCall
        
        if (isCallToProto) original = function () {
            var beforeSUPER = this.SUPER
            
            this.SUPER  = superProto.SUPER
            
            var res = originalCall.apply(this, arguments)
            
            this.SUPER = beforeSUPER
            
            return res
        }

        var override = function () {
            
            var beforeSUPER = this.SUPER
            
            this.SUPER  = original
            
            var res = modifier.apply(this, arguments)
            
            this.SUPER = beforeSUPER
            
            return res
        }
        
        override.IS_OVERRIDE = true
        
        return override
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[override ' + this.name + ']'
    }
    
    
}).c;
Joose.Managed.Property.MethodModifier.Put = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Put', {
    
    isa : Joose.Managed.Property.MethodModifier.Override,


    prepareWrapper : function (params) {
        
        if (params.isOwn) throw "Method [" + params.name + "] is applying over something [" + params.originalCall + "] in class [" + params.target + "]"
        
        return Joose.Managed.Property.MethodModifier.Put.superClass.prepareWrapper.call(this, params)
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[' + this.name + ']'
    }
    
    
}).c;
Joose.Managed.Property.MethodModifier.After = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.After', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        return function () {
            var res = originalCall.apply(this, arguments)
            modifier.apply(this, arguments)
            return res
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[after ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Before = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Before', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        return function () {
            modifier.apply(this, arguments)
            return originalCall.apply(this, arguments)
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[before ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Around = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Around', {
    
    isa : Joose.Managed.Property.MethodModifier,

    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        var me
        
        var bound = function () {
            return originalCall.apply(me, arguments)
        }
            
        return function () {
            me = this
            
            var boundArr = [ bound ]
            boundArr.push.apply(boundArr, arguments)
            
            return modifier.apply(this, boundArr)
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[around ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Augment = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Augment', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var AUGMENT = function () {
            
            //populate callstack to the most deep non-augment method
            var callstack = []
            
            var self = AUGMENT
            
            do {
                callstack.push(self.IS_AUGMENT ? self.__CONTAIN__ : self)
                
                self = self.IS_AUGMENT && (self.__ORIGINAL__ || self.SUPER[self.methodName])
            } while (self)
            
            
            //save previous INNER
            var beforeINNER = this.INNER
            
            //create new INNER
            this.INNER = function () {
                var innerCall = callstack.pop()
                
                return innerCall ? innerCall.apply(this, arguments) : undefined
            }
            
            //augment modifier results in hypotetical INNER call of the same method in subclass 
            var res = this.INNER.apply(this, arguments)
            
            //restore previous INNER chain
            this.INNER = beforeINNER
            
            return res
        }
        
        AUGMENT.methodName  = params.name
        AUGMENT.SUPER       = params.superProto
        AUGMENT.IS_AUGMENT  = true
        
        return AUGMENT
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[augment ' + this.name + ']'
    }
    
}).c;
Joose.Managed.PropertySet = new Joose.Proto.Class('Joose.Managed.PropertySet', {
    
    isa                       : Joose.Managed.Property,

    properties                : null,
    
    propertyMetaClass         : Joose.Managed.Property,
    
    
    initialize : function (props) {
        Joose.Managed.PropertySet.superClass.initialize.call(this, props)
        
        //XXX this guards the meta roles :)
        this.properties = props.properties || {}
    },
    
    
    addProperty : function (name, props) {
        var metaClass = props.meta || this.propertyMetaClass
        delete props.meta
        
        props.definedIn     = this
        props.name          = name
        
        return this.properties[name] = new metaClass(props)
    },
    
    
    addPropertyObject : function (object) {
        return this.properties[object.name] = object
    },
    
    
    removeProperty : function (name) {
        var prop = this.properties[name]
        
        delete this.properties[name]
        
        return prop
    },
    
    
    haveProperty : function (name) {
        return this.properties[name] != null
    },
    

    haveOwnProperty : function (name) {
        return this.haveProperty(name) && this.properties.hasOwnProperty(name)
    },
    
    
    getProperty : function (name) {
        return this.properties[name]
    },
    
    
    //includes inherited properties (probably you wants 'eachOwn', which process only "own" (including consumed from Roles) properties) 
    each : function (func, scope) {
        Joose.O.each(this.properties, func, scope || this)
    },
    
    
    eachOwn : function (func, scope) {
        Joose.O.eachOwn(this.properties, func, scope || this)
    },
    
    
    //synonym for each
    eachAll : function (func, scope) {
        this.each(func, scope)
    },
    
    
    cloneProps : function () {
        var props = Joose.Managed.PropertySet.superClass.cloneProps.call(this)
        
        props.propertyMetaClass     = this.propertyMetaClass
        
        return props
    },
    
    
    clone : function (name) {
        var clone = this.cleanClone(name)
        
        clone.properties = Joose.O.copyOwn(this.properties)
        
        return clone
    },
    
    
    cleanClone : function (name) {
        var props = this.cloneProps()
        
        props.name = name || props.name
        
        return new this.constructor(props)
    },
    
    
    alias : function (what) {
        var props = this.properties
        
        Joose.O.each(what, function (aliasName, originalName) {
            var original = props[originalName]
            
            if (original) this.addPropertyObject(original.clone(aliasName))
        }, this)
    },
    
    
    exclude : function (what) {
        var props = this.properties
        
        Joose.A.each(what, function (name) {
            delete props[name]
        })
    },
    
    
    beforeConsumedBy : function () {
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.eachOwn(function (property, name) {
            var targetProperty = targetProps[name]
            
            if (targetProperty instanceof Joose.Managed.Property.ConflictMarker) return
            
            if (!targetProps.hasOwnProperty(name) || targetProperty == null) {
                target.addPropertyObject(property)
                return
            }
            
            if (targetProperty == property) return
            
            target.removeProperty(name)
            target.addProperty(name, {
                meta : Joose.Managed.Property.ConflictMarker
            })
        }, this)
    },
    
    
    composeTo : function (target) {
        this.eachOwn(function (property, name) {
            if (!target.haveOwnProperty(name)) target.addPropertyObject(property)
        })
    },
    
    
    composeFrom : function () {
        if (!arguments.length) return
        
        var flattening = this.cleanClone()
        
        Joose.A.each(arguments, function (arg) {
            var isDescriptor    = !(arg instanceof Joose.Managed.PropertySet)
            var propSet         = isDescriptor ? arg.propertySet : arg
            
            propSet.beforeConsumedBy(this, flattening)
            
            if (isDescriptor) {
                if (arg.alias || arg.exclude)   propSet = propSet.clone()
                if (arg.alias)                  propSet.alias(arg.alias)
                if (arg.exclude)                propSet.exclude(arg.exclude)
            }
            
            propSet.flattenTo(flattening)
        }, this)
        
        flattening.composeTo(this)
    },
    
    
    preApply : function (target) {
        this.eachOwn(function (property) {
            property.preApply(target)
        })
    },
    
    
    apply : function (target) {
        this.eachOwn(function (property) {
            property.apply(target)
        })
    },
    
    
    unapply : function (from) {
        this.eachOwn(function (property) {
            property.unapply(from)
        })
    },
    
    
    postUnApply : function (target) {
        this.eachOwn(function (property) {
            property.postUnApply(target)
        })
    }
    
}).c
;
var __ID__ = 1


Joose.Managed.PropertySet.Mutable = new Joose.Proto.Class('Joose.Managed.PropertySet.Mutable', {
    
    isa                 : Joose.Managed.PropertySet,

    ID                  : null,
    
    derivatives         : null,
    
    opened              : null,
    
    composedFrom        : null,
    
    
    initialize : function (props) {
        Joose.Managed.PropertySet.Mutable.superClass.initialize.call(this, props)
        
        //initially opened
        this.opened             = 1
        this.derivatives        = {}
        this.ID                 = __ID__++
        this.composedFrom       = []
    },
    
    
    addComposeInfo : function () {
        this.ensureOpen()
        
        Joose.A.each(arguments, function (arg) {
            this.composedFrom.push(arg)
            
            var propSet = arg instanceof Joose.Managed.PropertySet ? arg : arg.propertySet
                
            propSet.derivatives[this.ID] = this
        }, this)
    },
    
    
    removeComposeInfo : function () {
        this.ensureOpen()
        
        Joose.A.each(arguments, function (arg) {
            
            var i = 0
            
            while (i < this.composedFrom.length) {
                var propSet = this.composedFrom[i]
                propSet = propSet instanceof Joose.Managed.PropertySet ? propSet : propSet.propertySet
                
                if (arg == propSet) {
                    delete propSet.derivatives[this.ID]
                    this.composedFrom.splice(i, 1)
                } else i++
            }
            
        }, this)
    },
    
    
    ensureOpen : function () {
        if (!this.opened) throw "Mutation of closed property set: [" + this.name + "]"
    },
    
    
    addProperty : function (name, props) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.addProperty.call(this, name, props)
    },
    

    addPropertyObject : function (object) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.addPropertyObject.call(this, object)
    },
    
    
    removeProperty : function (name) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.removeProperty.call(this, name)
    },
    
    
    composeFrom : function () {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.composeFrom.apply(this, this.composedFrom)
    },
    
    
    open : function () {
        this.opened++
        
        if (this.opened == 1) {
        
            Joose.O.each(this.derivatives, function (propSet) {
                propSet.open()
            })
            
            this.deCompose()
        }
    },
    
    
    close : function () {
        if (!this.opened) throw "Unmatched 'close' operation on property set: [" + this.name + "]"
        
        if (this.opened == 1) {
            this.reCompose()
            
            Joose.O.each(this.derivatives, function (propSet) {
                propSet.close()
            })
        }
        this.opened--
    },
    
    
    reCompose : function () {
        this.composeFrom()
    },
    
    
    deCompose : function () {
        this.eachOwn(function (property, name) {
            if (property.definedIn != this) this.removeProperty(name)
        }, this)
    }
    
}).c;
Joose.Managed.StemElement = function () { throw "Modules may not be instantiated." }

Joose.Managed.StemElement.Attributes = new Joose.Proto.Class('Joose.Managed.StemElement.Attributes', {
    
    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : Joose.Managed.Property.Attribute
    
}).c
;
Joose.Managed.StemElement.Methods = new Joose.Proto.Class('Joose.Managed.StemElement.Methods', {
    
    isa : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass : Joose.Managed.Property.MethodModifier.Put,

    
    preApply : function () {
    },
    
    
    postUnApply : function () {
    }
    
}).c;
Joose.Managed.StemElement.Requirements = new Joose.Proto.Class('Joose.Managed.StemElement.Requirements', {

    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : Joose.Managed.Property.Requirement,
    
    
    
    alias : function () {
    },
    
    
    exclude : function () {
    },
    
    
    flattenTo : function (target) {
        this.each(function (property, name) {
            if (!target.haveProperty(name)) target.addPropertyObject(property)
        })
    },
    
    
    composeTo : function (target) {
        this.flattenTo(target)
    },
    
    
    preApply : function () {
    },
    
    
    postUnApply : function () {
    }
    
}).c;
Joose.Managed.StemElement.MethodModifiers = new Joose.Proto.Class('Joose.Managed.StemElement.MethodModifiers', {

    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : null,
    
    
    addProperty : function (name, props) {
        var metaClass = props.meta
        delete props.meta
        
        props.definedIn         = this
        props.name              = name
        
        var modifier            = new metaClass(props)
        var properties          = this.properties
        
        if (!properties[name]) properties[ name ] = []
        
        properties[name].push(modifier)
        
        return modifier
    },
    

    addPropertyObject : function (object) {
        var name            = object.name
        var properties      = this.properties
        
        if (!properties[name]) properties[name] = []
        
        properties[name].push(object)
        
        return object
    },
    
    
    //remove only the last modifier
    removeProperty : function (name) {
        if (!this.haveProperty(name)) return undefined
        
        var properties      = this.properties
        var modifier        = properties[ name ].pop()
        
        //if all modifiers were removed - clearing the properties
        if (!properties[name].length) Joose.Managed.StemElement.MethodModifiers.superClass.removeProperty.call(this, name)
        
        return modifier
    },
    
    
    alias : function () {
    },
    
    
    exclude : function () {
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (modifiersArr, name) {
            var targetModifiersArr = targetProps[name]
            
            if (targetModifiersArr == null) targetModifiersArr = targetProps[name] = []
            
            Joose.A.each(modifiersArr, function (modifier) {
                if (!Joose.A.exists(targetModifiersArr, modifier)) targetModifiersArr.push(modifier)
            })
            
        })
    },
    
    
    composeTo : function (target) {
        this.flattenTo(target)
    },

    
    deCompose : function () {
        this.each(function (modifiersArr, name) {
            var i = 0
            
            while (i < modifiersArr.length) 
                if (modifiersArr[i].definedIn != this) 
                    modifiersArr.splice(i, 1)
                else 
                    i++
        })
    },
    
    
    preApply : function (target) {
    },

    
    postUnApply : function (target) {
    },
    
    
    apply : function (target) {
        this.each(function (modifiersArr, name) {
            Joose.A.each(modifiersArr, function (modifier) {
                modifier.apply(target)
            })
        })
    },
    
    
    unapply : function (from) {
        this.each(function (modifiersArr, name) {
            for (var i = modifiersArr.length - 1; i >=0 ; i--) modifiersArr[i].unapply(from)
        })
    }
    
    
    
}).c;
Joose.Managed.PropertySet.Composition = new Joose.Proto.Class('Joose.Managed.PropertySet.Composition', {
    
    isa                         : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass           : Joose.Managed.PropertySet.Mutable,
    
    processOrder                : null,

    
    each : function (func, scope) {
        var props   = this.properties
        var scope   = scope || this
        
        Joose.A.each(this.processOrder, function (name) {
            func.call(scope, props[name], name)
        })
    },
    
    
    eachR : function (func, scope) {
        var props   = this.properties
        var scope   = scope || this
        
        Joose.A.eachR(this.processOrder, function (name) {
            func.call(scope, props[name], name)
        })
        
        
//        var props           = this.properties
//        var processOrder    = this.processOrder
//        
//        for(var i = processOrder.length - 1; i >= 0; i--) 
//            func.call(scope || this, props[ processOrder[i] ], processOrder[i])
    },
    
    
    clone : function (name) {
        var clone = this.cleanClone(name)
        
        this.each(function (property) {
            clone.addPropertyObject(property.clone())
        })
        
        return clone
    },
    
    
    alias : function (what) {
        this.each(function (property) {
            property.alias(what)
        })
    },
    
    
    exclude : function (what) {
        this.each(function (property) {
            property.exclude(what)
        })
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (property, name) {
            var subTarget = targetProps[name] || target.addProperty(name, {
                meta : property.constructor
            })
            
            property.flattenTo(subTarget)
        })
    },
    
    
    composeTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (property, name) {
            var subTarget = targetProps[name] || target.addProperty(name, {
                meta : property.constructor
            })
            
            property.composeTo(subTarget)
        })
    },
    
    
    
    deCompose : function () {
        this.eachR(function (property) {
            property.open()
        })
        
        Joose.Managed.PropertySet.Composition.superClass.deCompose.call(this)
    },
    
    
    reCompose : function () {
        Joose.Managed.PropertySet.Composition.superClass.reCompose.call(this)
        
        this.each(function (property) {
            property.close()
        })
    },
    
    
    unapply : function (from) {
        this.eachR(function (property) {
            property.unapply(from)
        })
    }
    
}).c
;
Joose.Managed.Stem = new Joose.Proto.Class('Joose.Managed.Stem', {
    
    isa                  : Joose.Managed.PropertySet.Composition,
    
    targetMeta           : null,
    
    attributesMC         : Joose.Managed.StemElement.Attributes,
    methodsMC            : Joose.Managed.StemElement.Methods,
    requirementsMC       : Joose.Managed.StemElement.Requirements,
    methodsModifiersMC   : Joose.Managed.StemElement.MethodModifiers,
    
    processOrder         : [ 'attributes', 'methods', 'requirements', 'methodsModifiers' ],
    
    
    initialize : function (props) {
        Joose.Managed.Stem.superClass.initialize.call(this, props)
        
        var targetMeta = this.targetMeta
        
        this.addProperty('attributes', {
            meta : this.attributesMC,
            
            //it can be no 'targetMeta' in clones
            properties : targetMeta ? targetMeta.attributes : {}
        })
        
        
        this.addProperty('methods', {
            meta : this.methodsMC,
            
            properties : targetMeta ? targetMeta.methods : {}
        })
        
        
        this.addProperty('requirements', {
            meta : this.requirementsMC
        })
        
        
        this.addProperty('methodsModifiers', {
            meta : this.methodsModifiersMC
        })
    },
    
    
    reCompose : function () {
        var c       = this.targetMeta.c
        
        this.preApply(c)
        
        Joose.Managed.Stem.superClass.reCompose.call(this)
        
        this.apply(c)
    },
    
    
    deCompose : function () {
        var c       = this.targetMeta.c
        
        this.unapply(c)
        
        Joose.Managed.Stem.superClass.deCompose.call(this)
        
        this.postUnApply(c)
    }
    
    
}).c
;
Joose.Managed.Builder = new Joose.Proto.Class('Joose.Managed.Builder', {
    
    targetMeta          : null,
    
    
    _buildStart : function (targetMeta, props) {
        targetMeta.stem.open()
        
        Joose.A.each([ 'trait', 'traits', 'removeTrait', 'removeTraits', 'does', 'doesnot', 'doesnt' ], function (builder) {
            if (props[builder]) {
                this[builder](targetMeta, props[builder])
                delete props[builder]
            }
        }, this)
    },
    
    
    _extend : function (props) {
        if (Joose.O.isEmpty(props)) return
        
        var targetMeta = this.targetMeta
        
        this._buildStart(targetMeta, props)
        
        Joose.O.eachOwn(props, function (value, name) {
            var handler = this[name]
            
            if (!handler) throw new Error("Unknown builder [" + name + "] was used during extending of [" + targetMeta.c + "]")
            
            handler.call(this, targetMeta, value)
        }, this)
        
        this._buildComplete(targetMeta, props)
    },
    

    _buildComplete : function (targetMeta, props) {
        targetMeta.stem.close()
    },
    
    
    methods : function (targetMeta, info) {
        Joose.O.eachOwn(info, function (value, name) {
            targetMeta.addMethod(name, value)
        })
    },
    

    removeMethods : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeMethod(name)
        })
    },
    
    
    have : function (targetMeta, info) {
        Joose.O.eachOwn(info, function (value, name) {
            targetMeta.addAttribute(name, value)
        })
    },
    
    
    havenot : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeAttribute(name)
        })
    },
    

    havent : function (targetMeta, info) {
        this.havenot(targetMeta, info)
    },
    
    
    after : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.After)
        })
    },
    
    
    before : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Before)
        })
    },
    
    
    override : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Override)
        })
    },
    
    
    around : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Around)
        })
    },
    
    
    augment : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Augment)
        })
    },
    
    
    removeModifier : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeMethodModifier(name)
        })
    },
    
    
    does : function (targetMeta, info) {
        Joose.A.each(Joose.O.wantArray(info), function (desc) {
            targetMeta.addRole(desc)
        })
    },
    

    doesnot : function (targetMeta, info) {
        Joose.A.each(Joose.O.wantArray(info), function (desc) {
            targetMeta.removeRole(desc)
        })
    },
    
    
    doesnt : function (targetMeta, info) {
        this.doesnot(targetMeta, info)
    },
    
    
    trait : function () {
        this.traits.apply(this, arguments)
    },
    
    
    traits : function (targetMeta, info) {
        if (targetMeta.firstPass) return
        
        if (!targetMeta.meta.isDetached) throw "Can't apply trait to not detached class"
        
        targetMeta.meta.extend({
            does : info
        })
    },
    
    
    removeTrait : function () {
        this.removeTraits.apply(this, arguments)
    },
     
    
    removeTraits : function (targetMeta, info) {
        if (!targetMeta.meta.isDetached) throw "Can't remove trait from not detached class"
        
        targetMeta.meta.extend({
            doesnot : info
        })
    },
    
    name : function (targetMeta, name) {
        targetMeta.name     = name
    }
    
}).c;
Joose.Managed.Class = new Joose.Proto.Class('Joose.Managed.Class', {
    
    isa                         : Joose.Proto.Class,
    
    stem                        : null,
    stemClass                   : Joose.Managed.Stem,
    stemClassCreated            : false,
    
    builder                     : null,
    builderClass                : Joose.Managed.Builder,
    builderClassCreated         : false,
    
    isDetached                  : false,
    firstPass                   : true,
    
    // a special instance, which, when passed as 1st argument to constructor, signifies that constructor should
    // skips traits processing for this instance
    skipTraitsAnchor            : {},
    
    
    //build for metaclasses - collects traits from roles
    BUILD : function () {
        var sup = Joose.Managed.Class.superClass.BUILD.apply(this, arguments)
        
        var props   = sup.__extend__
        
        var traits = Joose.O.wantArray(props.trait || props.traits || [])
        delete props.trait
        delete props.traits
        
        Joose.A.each(Joose.O.wantArray(props.does || []), function (arg) {
            var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
            
            if (role.meta.meta.isDetached) traits.push(role.meta.constructor)
        })
        
        if (traits.length) props.traits = traits 
        
        return sup
    },
    
    
    initInstance : function (instance, props) {
        Joose.O.each(this.attributes, function (attribute, name) {
            
            if (attribute instanceof Joose.Managed.Attribute) 
                attribute.initFromConfig(instance, props)
            else 
                if (props.hasOwnProperty(name)) instance[name] = props[name]
        })
    },
    
    
    // we are using the same constructor for usual and meta- classes
    defaultConstructor: function () {
        return function (skipTraitsAnchor, params) {
            
            var thisMeta    = this.meta
            var skipTraits  = skipTraitsAnchor == thisMeta.skipTraitsAnchor
            
            var BUILD       = this.BUILD
            
            var props       = BUILD && BUILD.apply(this, skipTraits ? params : arguments) || (skipTraits ? params[0] : skipTraitsAnchor) || {}
            
            
            // either looking for traits in __extend__ (meta-class) or in usual props (usual class)
            var extend  = props.__extend__ || props
            
            var traits = extend.trait || extend.traits
            
            if (traits || extend.detached) {
                delete extend.trait
                delete extend.traits
                delete extend.detached
                
                if (!skipTraits) {
                    var classWithTrait  = thisMeta.subClass({ does : traits || [] }, thisMeta.name)
                    var meta            = classWithTrait.meta
                    meta.isDetached     = true
                    
                    return meta.instantiate(thisMeta.skipTraitsAnchor, arguments)
                }
            }
            
            thisMeta.initInstance(this, props)
            
            return thisMeta.hasMethod('initialize') && this.initialize(props) || this
        }
    },
    
    
    finalize: function (extend) {
        Joose.Managed.Class.superClass.finalize.call(this, extend)
        
        this.stem.close()
        
        this.afterMutate()
    },
    
    
    processStem : function () {
        Joose.Managed.Class.superClass.processStem.call(this)
        
        this.builder    = new this.builderClass({ targetMeta : this })
        this.stem       = new this.stemClass({ name : this.name, targetMeta : this })
        
        var builderClass = this.getClassInAttribute('builderClass')
        
        if (builderClass) {
            this.builderClassCreated = true
            this.addAttribute('builderClass', this.subClassOf(builderClass))
        }
        
        
        var stemClass = this.getClassInAttribute('stemClass')
        
        if (stemClass) {
            this.stemClassCreated = true
            this.addAttribute('stemClass', this.subClassOf(stemClass))
        }
    },
    
    
    extend : function (props) {
        if (props.builder) {
            this.getBuilderTarget().meta.extend(props.builder)
            delete props.builder
        }
        
        if (props.stem) {
            this.getStemTarget().meta.extend(props.stem)
            delete props.stem
        }
        
        this.builder._extend(props)
        
        this.firstPass = false
        
        if (!this.stem.opened) this.afterMutate()
    },
    
    
    getBuilderTarget : function () {
        var builderClass = this.getClassInAttribute('builderClass')
        if (!builderClass) throw "Attempt to extend a builder on non-meta class"
        
        return builderClass
    },
    

    getStemTarget : function () {
        var stemClass = this.getClassInAttribute('stemClass')
        if (!stemClass) throw "Attempt to extend a stem on non-meta class"
        
        return stemClass
    },
    
    
    getClassInAttribute : function (attributeName) {
        var attrClass = this.getAttribute(attributeName)
        if (attrClass instanceof Joose.Managed.Property.Attribute) attrClass = attrClass.value
        
        return attrClass
    },
    
    
    addMethodModifier: function (name, func, type) {
        var props = {}
        
        props.init = func
        props.meta = type
        
        return this.stem.properties.methodsModifiers.addProperty(name, props)
    },
    
    
    removeMethodModifier: function (name) {
        return this.stem.properties.methodsModifiers.removeProperty(name)
    },
    
    
    addMethod: function (name, func, props) {
        props = props || {}
        props.init = func
        
        return this.stem.properties.methods.addProperty(name, props)
    },
    
    
    addAttribute: function (name, init, props) {
        props = props || {}
        props.init = init
        
        return this.stem.properties.attributes.addProperty(name, props)
    },
    
    
    removeMethod : function (name) {
        return this.stem.properties.methods.removeProperty(name)
    },

    
    removeAttribute: function (name) {
        return this.stem.properties.attributes.removeProperty(name)
    },
    
    
    hasMethod: function (name) {
        return this.stem.properties.methods.haveProperty(name)
    },
    
    
    hasAttribute: function (name) { 
        return this.stem.properties.attributes.haveProperty(name)
    },
    
    
    hasMethodModifiersFor : function (name) {
        return this.stem.properties.methodsModifiers.haveProperty(name)
    },
    
    
    hasOwnMethod: function (name) {
        return this.stem.properties.methods.haveOwnProperty(name)
    },
    
    
    hasOwnAttribute: function (name) { 
        return this.stem.properties.attributes.haveOwnProperty(name)
    },
    

    getMethod : function (name) {
        return this.stem.properties.methods.getProperty(name)
    },
    
    
    getAttribute : function (name) {
        return this.stem.properties.attributes.getProperty(name)
    },
    
    
    eachRole : function (roles, func, scope) {
        Joose.A.each(roles, function (arg, index) {
            var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
            
            func.call(scope || this, arg, role, index)
        }, this)
    },
    
    
    addRole : function () {
        
        this.eachRole(arguments, function (arg, role) {
            
            this.beforeRoleAdd(role)
            
            var desc = arg
            
            //compose descriptor can contain 'alias' and 'exclude' fields, in this case actual reference should be stored
            //into 'propertySet' field
            if (role != arg) {
                desc.propertySet = role.meta.stem
                delete desc.role
            } else
                desc = desc.meta.stem
            
            this.stem.addComposeInfo(desc)
            
        }, this)
    },
    
    
    beforeRoleAdd : function (role) {
        var roleMeta = role.meta
        
        if (roleMeta.builderClassCreated) this.getBuilderTarget().meta.extend({
            does : [ roleMeta.getBuilderTarget() ]
        })
        
        if (roleMeta.stemClassCreated) this.getStemTarget().meta.extend({
            does : [ roleMeta.getStemTarget() ]
        })
        
        if (roleMeta.meta.isDetached && !this.firstPass) this.builder.traits(this, roleMeta.constructor)
    },
    
    
    beforeRoleRemove : function (role) {
        var roleMeta = role.meta
        
        if (roleMeta.builderClassCreated) this.getBuilderTarget().meta.extend({
            doesnt : [ roleMeta.getBuilderTarget() ]
        })
        
        if (roleMeta.stemClassCreated) this.getStemTarget().meta.extend({
            doesnt : [ roleMeta.getStemTarget() ]
        })
        
        if (roleMeta.meta.isDetached && !this.firstPass) this.builder.removeTraits(this, roleMeta.constructor)
    },
    
    
    removeRole : function () {
        this.eachRole(arguments, function (arg, role) {
            this.beforeRoleRemove(role)
            
            this.stem.removeComposeInfo(role.meta.stem)
        }, this)
    },
    
    
    getRoles : function () {
        
        return Joose.A.map(this.stem.composedFrom, function (composeDesc) {
            //compose descriptor can contain 'alias' and 'exclude' fields, in this case actual reference is stored
            //into 'propertySet' field
            if (!(composeDesc instanceof Joose.Managed.PropertySet)) return composeDesc.propertySet
            
            return composeDesc.targetMeta.c
        })
    },
    
    
    does : function (role) {
        var myRoles = this.getRoles()
        
        for (var i = 0; i < myRoles.length; i++) if (role == myRoles[i]) return true
        for (var i = 0; i < myRoles.length; i++) if (myRoles[i].meta.does(role)) return true
        
        var superMeta = this.superClass.meta
        
        // considering the case of inheriting from non-Joose classes
        if (this.superClass != Joose.Proto.Empty && superMeta && superMeta.meta && superMeta.meta.hasMethod('does')) return superMeta.does(role)
        
        return false
    },
    
    
    getMethods : function () {
        return this.stem.properties.methods
    },
    
    
    getAttributes : function () {
        return this.stem.properties.attributes
    },
    
    
    afterMutate : function () {
    },
    
    
    getCurrentMethod : function () {
        for (var wrapper = arguments.callee.caller, count = 0; wrapper && count < 5; wrapper = wrapper.caller, count++)
            if (wrapper.__METHOD__) return wrapper.__METHOD__
        
        return null
    }
    
    
}).c;
Joose.Managed.Role = new Joose.Managed.Class('Joose.Managed.Role', {
    
    isa                         : Joose.Managed.Class,
    
    have : {
        defaultSuperClass       : Joose.Proto.Empty,
        
        builderRole             : null,
        stemRole                : null
    },
    
    
    methods : {
        
        defaultConstructor : function () {
            return function () {
                throw new Error("Roles cant be instantiated")
            }
        },
        

        processSuperClass : function () {
            if (this.superClass != this.defaultSuperClass) throw new Error("Roles can't inherit from anything")
        },
        
        
        getBuilderTarget : function () {
            if (!this.builderRole) {
                this.builderRole = new this.constructor().c
                this.builderClassCreated = true
            }
            
            return this.builderRole
        },
        
    
        getStemTarget : function () {
            if (!this.stemRole) {
                this.stemRole = new this.constructor().c
                this.stemClassCreated = true
            }
            
            return this.stemRole
        },
        
    
        addRequirement : function (methodName) {
            this.stem.properties.requirements.addProperty(methodName, {})
        }
        
    },
    

    stem : {
        methods : {
            
            apply : function () {
            },
            
            
            unapply : function () {
            }
        }
    },
    
    
    builder : {
        methods : {
            requires : function (targetClassMeta, info) {
                Joose.A.each(Joose.O.wantArray(info), function (methodName) {
                    targetClassMeta.addRequirement(methodName)
                }, this)
            }
        }
    }
    
}).c;
Joose.Managed.Attribute = new Joose.Managed.Class('Joose.Managed.Attribute', {
    
    isa : Joose.Managed.Property.Attribute,
    
    have : {
        is              : null,
        
        builder         : null,
        
        isPrivate       : false,
        
        role            : null,
        
        publicName      : null,
        setterName      : null,
        getterName      : null,
        
        //indicates the logical readableness/writeableness of the attribute
        readable        : false,
        writeable       : false,
        
        //indicates the physical presense of the accessor (may be absent for "combined" accessors for example)
        hasGetter       : false,
        hasSetter       : false,
        
        required        : false,
        
        canInlineSetRaw : true,
        canInlineGetRaw : true
    },
    
    
    after : {
        initialize : function () {
            var name = this.name
            
            this.publicName = name.replace(/^_+/, '')
            
            this.slot = this.isPrivate ? '$' + name : name
            
            this.setterName = this.setterName || this.getSetterName()
            this.getterName = this.getterName || this.getGetterName()
            
            this.readable  = this.hasGetter = /^r/i.test(this.is)
            this.writeable = this.hasSetter = /^.w/i.test(this.is)
        }
    },
    
    
    override : {
        
        computeValue : function () {
            var init    = this.init
            
            if (Joose.O.isClass(init) || !Joose.O.isFunction(init)) this.SUPER()
        },
        
        
        preApply : function (targetClass) {
            targetClass.meta.extend({
                methods : this.getAccessorsFor(targetClass)
            })
        },
        
        
        postUnApply : function (from) {
            from.meta.extend({
                removeMethods : this.getAccessorsFrom(from)
            })
        }
        
    },
    
    
    methods : {
        
        getAccessorsFor : function (targetClass) {
            var targetMeta = targetClass.meta
            var setterName = this.setterName
            var getterName = this.getterName
            
            var methods = {}
            
            if (this.hasSetter && !targetMeta.hasMethod(setterName)) {
                methods[setterName] = this.getSetter()
                methods[setterName].ACCESSOR_FROM = this
            }
            
            if (this.hasGetter && !targetMeta.hasMethod(getterName)) {
                methods[getterName] = this.getGetter()
                methods[getterName].ACCESSOR_FROM = this
            }
            
            return methods
        },
        
        
        getAccessorsFrom : function (from) {
            var targetMeta = from.meta
            var setterName = this.setterName
            var getterName = this.getterName
            
            var setter = this.hasSetter && targetMeta.getMethod(setterName)
            var getter = this.hasGetter && targetMeta.getMethod(getterName)
            
            var removeMethods = []
            
            if (setter && setter.value.ACCESSOR_FROM == this) removeMethods.push(setterName)
            if (getter && getter.value.ACCESSOR_FROM == this) removeMethods.push(getterName)
            
            return removeMethods
        },
        
        
        getGetterName : function () {
            return 'get' + Joose.S.uppercaseFirst(this.publicName)
        },


        getSetterName : function () {
            return 'set' + Joose.S.uppercaseFirst(this.publicName)
        },
        
        
        getSetter : function () {
            var me      = this
            var slot    = me.slot
            
            if (me.canInlineSetRaw)
                return function (value) {
                    this[ slot ] = value
                    
                    return this
                }
            else
                return function () {
                    return me.setRawValueTo.apply(this, arguments)
                }
        },
        
        
        getGetter : function () {
            var me      = this
            var slot    = me.slot
            
            if (me.canInlineGetRaw)
                return function (value) {
                    return this[ slot ]
                }
            else
                return function () {
                    return me.getRawValueFrom.apply(this, arguments)
                }
        },
        
        
        getValueFrom : function (instance) {
            var getterName      = this.getterName
            
            if (this.readable && instance.meta.hasMethod(getterName)) return instance[ getterName ]()
            
            return this.getRawValueFrom(instance)
        },
        
        
        setValueTo : function (instance, value) {
            var setterName      = this.setterName
            
            if (this.writeable && instance.meta.hasMethod(setterName)) 
                instance[ setterName ](value)
            else
                this.setRawValueTo(instance, value)
        },
        
        
        initFromConfig : function (instance, config) {
            var name            = this.name
            
            var value, isSet = false
            
            if (config.hasOwnProperty(name)) {
                value = config[name]
                isSet = true
            } else {
                var init    = this.init
                
                // simple function (not class) has been used as "init" value
                if (Joose.O.isFunction(init) && !Joose.O.isClass(init)) {
                    
                    value = init.call(instance, config, name)
                    
                    isSet = true
                    
                } else if (this.builder) {
                    
                    value = instance[ this.builder.replace(/^this\./, '') ](config, name)
                    isSet = true
                }
            }
            
            if (isSet)
                this.setRawValueTo(instance, value)
            else 
                if (this.required) throw new Error("Required attribute [" + name + "] is missed during initialization of " + instance)
        }
    }

}).c
;
Joose.Managed.Attribute.Builder = new Joose.Managed.Role('Joose.Managed.Attribute.Builder', {
    
    
    have : {
        defaultAttributeClass : Joose.Managed.Attribute
    },
    
    builder : {
        
        methods : {
            
            has : function (targetClassMeta, info) {
                Joose.O.eachOwn(info, function (props, name) {
                    if (typeof props != 'object' || props == null || props.constructor == / /.constructor) props = { init : props }
                    
                    props.meta = props.meta || targetClassMeta.defaultAttributeClass
                    
                    if (/^__/.test(name)) {
                        name = name.replace(/^_+/, '')
                        
                        props.isPrivate = true
                    }
                    
                    targetClassMeta.addAttribute(name, props.init, props)
                }, this)
            },
            
            
            hasnot : function (targetClassMeta, info) {
                this.havenot(targetClassMeta, info)
            },
            
            
            hasnt : function (targetClassMeta, info) {
                this.hasnot(targetClassMeta, info)
            }
        }
            
    }
    
}).c
;
Joose.Managed.My = new Joose.Managed.Role('Joose.Managed.My', {
    
    have : {
        myClass                         : null,
        
        needToReAlias                   : false
    },
    
    
    methods : {
        createMy : function (extend) {
            var thisMeta        = this.meta
            var isRole          = this instanceof Joose.Managed.Role
            
            var myExtend        = extend.my || {}
            delete extend.my
            
            // Symbiont will generally have the same meta class as its hoster, excepting the cases, when the superclass also have the symbiont. 
            // In such cases, the meta class for symbiont will be inherited (unless explicitly specified)
            var superClassMy    = this.superClass.meta.myClass
            
            if (!isRole && !myExtend.isa && superClassMy) myExtend.isa = superClassMy
            

            if (!myExtend.meta && !myExtend.isa) myExtend.meta = this.constructor
            
            myExtend.name       = this.name + '.my'
            
            var createdClass    = this.myClass = Class(myExtend)
            
            var c               = this.c
            
            c.prototype.my      = c.my = isRole ? createdClass : new createdClass({ HOST : c })
            
            this.needToReAlias = true
        },
        
        
        aliasStaticMethods : function () {
            this.needToReAlias = false
            
            var c           = this.c
            var myProto     = this.myClass.prototype
            
            Joose.O.eachOwn(c, function (property, name) {
                if (property.IS_ALIAS) delete c[ name ] 
            })
            
            this.myClass.meta.stem.properties.methods.each(function (method, name) {
                
                if (!c[ name ])
                    (c[ name ] = function () {
                        return myProto[ name ].apply(c.my, arguments)
                    }).IS_ALIAS = true
            })
        }
    },
    
    
    override : {
        
        extend : function (props) {
            var myClass = this.myClass
            
            if (!myClass && this.superClass.meta.myClass) this.createMy(props)
            
            if (props.my) {
                if (!myClass) 
                    this.createMy(props)
                else {
                    this.needToReAlias = true
                    
                    myClass.meta.extend(props.my)
                    delete props.my
                }
            }
            
            this.SUPER(props)
            
            if (this.needToReAlias && !(this instanceof Joose.Managed.Role)) this.aliasStaticMethods()
        }  
    },
    
    
    before : {
        
        addRole : function () {
            var myStem
            
            Joose.A.each(arguments, function (arg) {
                
                if (!arg) throw new Error("Attempt to consume an undefined Role into [" + this.name + "]")
                
                //instanceof Class to allow treat classes as roles
                var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
                
                if (role.meta.meta.hasAttribute('myClass') && role.meta.myClass) {
                    
                    if (!this.myClass) {
                        this.createMy({
                            my : {
                                does : role.meta.myClass
                            }
                        })
                        return
                    }
                    
                    myStem = this.myClass.meta.stem
                    if (!myStem.opened) myStem.open()
                    
                    myStem.addComposeInfo(role.my.meta.stem)
                }
            }, this)
            
            if (myStem) {
                myStem.close()
                
                this.needToReAlias = true
            }
        },
        
        
        removeRole : function () {
            if (!this.myClass) return
            
            var myStem = this.myClass.meta.stem
            myStem.open()
            
            Joose.A.each(arguments, function (role) {
                if (role.meta.meta.hasAttribute('myClass') && role.meta.myClass) {
                    myStem.removeComposeInfo(role.my.meta.stem)
                    
                    this.needToReAlias = true
                }
            }, this)
            
            myStem.close()
        }
        
    }
    
}).c;
Joose.Namespace = Joose.stub()

Joose.Namespace.Able = new Joose.Managed.Role('Joose.Namespace.Able', {

    have : {
        bodyFunc                : null
    },
    
    
    before : {
        extend : function (extend) {
            if (extend.body) {
                this.bodyFunc = extend.body
                delete extend.body
            }
        }
    },
    
    
    after: {
        
        afterMutate : function () {
            var bodyFunc = this.bodyFunc
            delete this.bodyFunc
            
            if (bodyFunc) Joose.Namespace.Manager.my.executeIn(this.c, bodyFunc)
        }
    }
    
}).c;
Joose.Managed.Bootstrap = new Joose.Managed.Role('Joose.Managed.Bootstrap', {
    
    does   : [ Joose.Namespace.Able, Joose.Managed.My, Joose.Managed.Attribute.Builder ]
    
}).c
;
Joose.Meta = Joose.stub()


Joose.Meta.Object = new Joose.Proto.Class('Joose.Meta.Object', {
    
    isa             : Joose.Proto.Object
    
}).c


;
Joose.Meta.Class = new Joose.Managed.Class('Joose.Meta.Class', {
    
    isa                         : Joose.Managed.Class,
    
    does                        : Joose.Managed.Bootstrap,
    
    have : {
        defaultSuperClass       : Joose.Meta.Object
    }
    
}).c

;
Joose.Meta.Role = new Joose.Meta.Class('Joose.Meta.Role', {
    
    isa                         : Joose.Managed.Role,
    
    does                        : Joose.Managed.Bootstrap
    
}).c;
Joose.Namespace.Keeper = new Joose.Meta.Class('Joose.Namespace.Keeper', {
    
    isa         : Joose.Meta.Class,
    
    have        : {
        externalConstructor             : null
    },
    
    
    methods: {
        
        defaultConstructor: function () {
            
            return function () {
                //constructors should assume that meta is attached to 'arguments.callee' (not to 'this') 
                var thisMeta = arguments.callee.meta
                
                if (thisMeta instanceof Joose.Namespace.Keeper) throw new Error("Module [" + thisMeta.c + "] may not be instantiated. Forgot to 'use' the class with the same name?")
                
                var externalConstructor = thisMeta.externalConstructor
                
                if (typeof externalConstructor == 'function') {
                    
                    externalConstructor.meta = thisMeta
                    
                    return externalConstructor.apply(this, arguments)
                }
                
                throw "NamespaceKeeper of [" + thisMeta.name + "] was planted incorrectly."
            }
        },
        
        
        //withClass should be not constructed yet on this stage (see Joose.Proto.Class.construct)
        //it should be on the 'constructorOnly' life stage (should already have constructor)
        plant: function (withClass) {
            var keeper = this.c
            
            keeper.meta = withClass.meta
            
            keeper.meta.c = keeper
            keeper.meta.externalConstructor = withClass
        }
    }
    
}).c


;
Joose.Namespace.Manager = new Joose.Managed.Class('Joose.Namespace.Manager', {
    
    have : {
        current     : null
    },
    
    
    methods : {
        
        initialize : function () {
            this.current    = [ Joose.top ]
        },
        
        
        getCurrent: function () {
            return this.current[0]
        },
        
        
        executeIn : function (ns, func) {
            var current = this.current
            
            current.unshift(ns)
            var res = func.call(ns, ns)
            current.shift()
            
            return res
        },
        
        
        earlyCreate : function (name, metaClass, props) {
            props.constructorOnly = true
            
            return new metaClass(name, props).c
        },
        
        
        //this function establishing the full "namespace chain" (including the last element)
        create : function (nsName, metaClass, extend) {
            
            //if no name provided, then we creating an anonymous class, so just skip all the namespace manipulations
            if (!nsName) return new metaClass(nsName, extend).c
            
            var me = this
            
            if (/^\./.test(nsName)) return this.executeIn(Joose.top, function () {
                return me.create(nsName.replace(/^\./, ''), metaClass, extend)
            })
            
            var props   = extend || {}
            
            var parts   = Joose.S.saneSplit(nsName, '.')
            var object  = this.getCurrent()
            var soFar   = object == Joose.top ? [] : Joose.S.saneSplit(object.meta.name, '.')
            
            for (var i = 0; i < parts.length; i++) {
                var part        = parts[i]
                var isLast      = i == parts.length - 1
                
                if (part == "meta" || part == "my" || !part) throw "Module name [" + nsName + "] may not include a part called 'meta' or 'my' or empty part."
                
                var cur =   object[part]
                
                soFar.push(part)
                
                var soFarName       = soFar.join(".")
                var needFinalize    = false
                var nsKeeper
                
                // if the namespace segment is empty
                if (typeof cur == "undefined") {
                    if (isLast) {
                        // perform "early create" which just fills the namespace segment with right constructor
                        // this allows us to have a right constructor in the namespace segment when the `body` will be called
                        nsKeeper        = this.earlyCreate(soFarName, metaClass, props)
                        needFinalize    = true
                    } else
                        nsKeeper        = new Joose.Namespace.Keeper(soFarName).c
                    
                    object[part] = nsKeeper
                    
                    cur = nsKeeper
                    
                } else if (isLast && cur && cur.meta) {
                    
                    var currentMeta = cur.meta
                    
                    if (metaClass == Joose.Namespace.Keeper)
                        //`Module` over something case - extend the original
                        currentMeta.extend(props)
                    else {
                        
                        if (currentMeta instanceof Joose.Namespace.Keeper) {
                            
                            currentMeta.plant(this.earlyCreate(soFarName, metaClass, props))
                            
                            needFinalize = true
                        } else
                            throw new Error("Double declaration of [" + soFarName + "]")
                    }
                    
                } else 
                    if (isLast && !(cur && cur.meta && cur.meta.meta)) throw "Trying to setup module " + soFarName + " failed. There is already something: " + cur

                // hook to allow embedd resource into meta
                if (isLast) this.prepareMeta(cur.meta)
                    
                if (needFinalize) cur.meta.construct(props)
                    
                object = cur
            }
            
            return object
        },
        
        
        prepareMeta : function () {
        },
        
        
        prepareProperties : function (name, props, defaultMeta, callback) {
            if (name && typeof name != 'string') {
                props   = name
                name    = null
            }
            
            var meta
            
            if (props && props.meta) {
                meta = props.meta
                delete props.meta
            }
            
            if (!meta)
                if (props && typeof props.isa == 'function' && props.isa.meta)
                    meta = props.isa.meta.constructor
                else
                    meta = defaultMeta
            
            return callback.call(this, name, meta, props)
        },
        
        
        getDefaultHelperFor : function (metaClass) {
            var me = this
            
            return function (name, props) {
                return me.prepareProperties(name, props, metaClass, function (name, meta, props) {
                    return me.create(name, meta, props)
                })
            }
        },
        
        
        register : function (helperName, metaClass, func) {
            var me = this
            
            if (this.meta.hasMethod(helperName)) {
                
                var helper = function () {
                    return me[ helperName ].apply(me, arguments)
                }
                
                if (!Joose.top[ helperName ])   Joose.top[ helperName ]         = helper
                if (!Joose[ helperName ])       Joose[ helperName ]             = helper
                
                if (Joose.is_NodeJS && typeof exports != 'undefined')            exports[ helperName ]    = helper
                
            } else {
                var methods = {}
                
                methods[ helperName ] = func || this.getDefaultHelperFor(metaClass)
                
                this.meta.extend({
                    methods : methods
                })
                
                this.register(helperName)
            }
        },
        
        
        Module : function (name, props) {
            return this.prepareProperties(name, props, Joose.Namespace.Keeper, function (name, meta, props) {
                if (typeof props == 'function') props = { body : props }    
                
                return this.create(name, meta, props)
            })
        }
    }
    
}).c

Joose.Namespace.Manager.my = new Joose.Namespace.Manager()

Joose.Namespace.Manager.my.register('Class', Joose.Meta.Class)
Joose.Namespace.Manager.my.register('Role', Joose.Meta.Role)
Joose.Namespace.Manager.my.register('Module')


// for the rest of the package
var Class       = Joose.Class
var Role        = Joose.Role
;
Role('Joose.Attribute.Delegate', {
    
    have : {
        handles : null
    },
    
    
    override : {
        
        eachDelegate : function (handles, func, scope) {
            if (typeof handles == 'string') return func.call(scope, handles, handles)
            
            if (handles instanceof Array)
                return Joose.A.each(handles, function (delegateTo) {
                    
                    func.call(scope, delegateTo, delegateTo)
                })
                
            if (handles === Object(handles))
                Joose.O.eachOwn(handles, function (delegateTo, handleAs) {
                    
                    func.call(scope, handleAs, delegateTo)
                })
        },
        
        
        getAccessorsFor : function (targetClass) {
            var targetMeta  = targetClass.meta
            var methods     = this.SUPER(targetClass)
            
            var me      = this
            
            this.eachDelegate(this.handles, function (handleAs, delegateTo) {
                
                if (!targetMeta.hasMethod(handleAs)) {
                    var handler = methods[ handleAs ] = function () {
                        var attrValue = me.getValueFrom(this)
                        
                        return attrValue[ delegateTo ].apply(attrValue, arguments)
                    }
                    
                    handler.ACCESSOR_FROM = me
                }
            })
            
            return methods
        },
        
        
        getAccessorsFrom : function (from) {
            var methods = this.SUPER(from)
            
            var me          = this
            var targetMeta  = from.meta
            
            this.eachDelegate(this.handles, function (handleAs) {
                
                var handler = targetMeta.getMethod(handleAs)
                
                if (handler && handler.value.ACCESSOR_FROM == me) methods.push(handleAs)
            })
            
            return methods
        }
    }
})

;
Role('Joose.Attribute.Trigger', {
    
    have : {
        trigger        : null
    }, 

    
    after : {
        initialize : function() {
            if (this.trigger) {
                if (!this.writeable) throw new Error("Can't use `trigger` for read-only attributes")
                
                this.hasSetter = true
            }
        }
    },
    
    
    override : {
        
        getSetter : function() {
            var original    = this.SUPER()
            var trigger     = this.trigger
            
            if (!trigger) return original
            
            var me      = this
            var init    = Joose.O.isFunction(me.init) ? null : me.init
            
            return function () {
                var oldValue    = me.hasValue(this) ? me.getValueFrom(this) : init
                
                var res         = original.apply(this, arguments)
                
                trigger.call(this, me.getValueFrom(this), oldValue)
                
                return res
            }
        }
    }
})    

;
Role('Joose.Attribute.Lazy', {
    
    
    have : {
        lazy        : null
    }, 
    
    
    before : {
        computeValue : function () {
            if (typeof this.init == 'function' && this.lazy) {
                this.lazy = this.init    
                delete this.init    
            }
        }
    },
    
    
    after : {
        initialize : function () {
            if (this.lazy) this.readable = this.hasGetter = true
        }
    },
    
    
    override : {
        
        getGetter : function () {
            var original    = this.SUPER()
            var lazy        = this.lazy
            
            if (!lazy) return original
            
            var me      = this    
            
            return function () {
                if (!me.hasValue(this)) {
                    var initializer = typeof lazy == 'function' ? lazy : this[ lazy.replace(/^this\./, '') ]
                    
                    me.setValueTo(this, initializer.apply(this, arguments))
                }
                
                return original.call(this)    
            }
        }
    }
})

;
Role('Joose.Attribute.Accessor.Combined', {
    
    
    have : {
        isCombined        : false
    }, 
    
    
    after : {
        initialize : function() {
            this.isCombined = this.isCombined || /..c/i.test(this.is)
            
            if (this.isCombined) {
                this.slot = '$$' + this.name
                
                this.hasGetter = true
                this.hasSetter = false
                
                this.setterName = this.getterName = this.publicName
            }
        }
    },
    
    
    override : {
        
        getGetter : function() {
            var getter    = this.SUPER()
            
            if (!this.isCombined) return getter
            
            var setter    = this.getSetter()
            
            var me = this
            
            return function () {
                
                if (!arguments.length) {
                    if (me.readable) return getter.call(this)
                    throw new Error("Call to getter of unreadable attribute: [" + me.name + "]")
                }
                
                if (me.writeable) return setter.apply(this, arguments)
                
                throw new Error("Call to setter of read-only attribute: [" + me.name + "]")    
            }
        }
    }
    
})

;
Joose.Managed.Attribute.meta.extend({
    does : [ Joose.Attribute.Delegate, Joose.Attribute.Trigger, Joose.Attribute.Lazy, Joose.Attribute.Accessor.Combined ]
})            

;
Role('Joose.Meta.Singleton', {
    
    has : {
        forceInstance           : Joose.I.Object,
        instance                : null
    },
    
    
    
    override : {
        
        defaultConstructor : function () {
            var meta        = this
            var previous    = this.SUPER()
            
            this.adaptConstructor(previous)
            
            return function (forceInstance, params) {
                if (forceInstance == meta.forceInstance) return previous.apply(this, params) || this
                
                var instance = meta.instance
                
                if (instance) {
                    if (meta.hasMethod('configure')) instance.configure.apply(instance, arguments)
                } else
                    meta.instance = new meta.c(meta.forceInstance, arguments)
                    
                return meta.instance
            }
        }        
    }
    

})


Joose.Namespace.Manager.my.register('Singleton', Class({
    isa     : Joose.Meta.Class,
    meta    : Joose.Meta.Class,
    
    does    : Joose.Meta.Singleton
}))
;
;
}();;
;
Class('JooseX.Observable.Event', {
    
    has : {
        name        : { required : true },
        args        : { required : true },
        
        source      : { required : true },
        
        splat       : null,
        current     : null,
        
        bubbling    : true
    },
    
        
    methods : {
        
        stopPropagation : function () {
            this.bubbling = false
        }
    }
})


;
Class('JooseX.Observable.Listener', {

    has : {
        channel     : { required : true },
        eventName   : { required : true },
        
        func        : { required : true },
        scope       : null,
        
        single          : false,
        
        buffer          : null,
        bufferMax       : null,
        
        bufferStartedAt : null,
        bufferTimeout   : null,
        
        delayTimeout    : null,
        
        delay           : null
    },
    
        
    methods : {
        
        activate : function (event, args) {
            var me      = this
            
            if (me.buffer != null) {
                
                if (me.bufferMax != null)
                    if (!me.bufferStartedAt) 
                        me.bufferStartedAt = new Date()
                    else
                        if (new Date - me.bufferStartedAt > me.bufferMax) return
                
                        
                if (me.bufferTimeout) clearTimeout(me.bufferTimeout)
                
                me.bufferTimeout = setTimeout(function () {
                    
                    delete me.bufferStartedAt
                    delete me.bufferTimeout
                    
                    me.doActivate(event, args)
                    
                }, me.buffer)
                
                return
            }
            
            if (me.delay != null) {
                
                me.delayTimeout = setTimeout(function () {
                    
                    delete me.delayTimeout
                    
                    me.doActivate(event, args)
                    
                }, me.delay)
                
                return
            }
            
            return me.doActivate(event, args)
        },
        
        
        doActivate : function (event, args) {
            if (this.single) this.remove()
            
            return this.func.apply(this.scope || event.source, [ event ].concat(args) ) !== false
        },
        
        
        cancel  : function () {
            if (this.buffer) {
                clearTimeout(this.bufferTimeout)
                
                delete this.bufferTimeout
                delete this.bufferStartedAt
            }
            
            if (this.delay) clearTimeout(this.delayTimeout)
        },
        
        
        remove : function () {
            this.channel.removeListener(this)
        }
    }
})


;
Class('JooseX.Observable.Channel', {
    
    has : {
        channels    : Joose.I.Object,
        
        listeners   : Joose.I.Object
    },
    
        
    methods : {
        
        destroy : function () {
            Joose.O.each(this.channels, function (channel, name) {
                channel.purgeListeners()
            })
            
            this.channels   = null
            
            // cleanup paranoya
            Joose.O.each(this.listeners, function (value, name) {
                this.listeners[ name ]  = null
            }, this)
            
            this.listeners  = null
        },
        
        
        // (!) segments array will be destroyed in this method
        getListenersFor : function (segments, name, activators) {
            var listeners = this.listeners
            
            if (listeners[ '**' ]) {
                
                var splat       = segments.concat(name)
                
                Joose.A.each(listeners[ '**' ], function (listener) {
                    activators.push({
                        listener    : listener,
                        splat       : splat
                    })
                })
            }
            
            if (segments.length) {
                var next = this.getSingleChannel(segments.shift(), true)
                
                if (next) next.getListenersFor(segments, name, activators)
            } else {
                
                if (listeners[ '*' ])
                    Joose.A.each(listeners[ '*' ], function (listener) {
                        
                        activators.push({
                            listener    : listener,
                            splat       : name
                        })
                    })
                
                if (listeners[ name ])  
                    Joose.A.each(listeners[ name ], function (listener) {
                        
                        activators.push({
                            listener    : listener
                        })
                    })
            }
        },
        
        
        hasListenerFor : function (segments, name) {
            var listeners = this.listeners
            
            if (listeners[ '**' ] && listeners[ '**' ].length) return true
            
            if (segments.length)  {
                var next = this.getSingleChannel(segments.shift(), true)
                
                if (next) return next.hasListenerFor(segments, name)
                
            } else {
                
                if (listeners[ '*' ] && listeners[ '*' ].length) return true
                
                if (listeners[ name ] && listeners[ name ].length) return true  
            }
            
            return false
        },
        
        
        addListener : function (listener) {
            var eventName   = listener.eventName
            var listeners   = this.listeners
            
            listeners[ eventName ] = listeners[ eventName ] || []
            
            listeners[ eventName ].push(listener)
        },
        
        
        removeListener : function (listenerToRemove) {
            // already purged
            if (!this.listeners) return
            
            var eventListeners      = this.listeners[ listenerToRemove.eventName ]
            
            eventListeners && Joose.A.each(eventListeners, function (listener, index) {
                
                if (listener == listenerToRemove) {
                    
                    eventListeners.splice(index, 1)
                    
                    return false
                }
            })
        },
        
        
        removeListenerByHandler : function (eventName, func, scope) {
            var eventListeners      = this.listeners[ eventName ]
            
            eventListeners && Joose.A.each(eventListeners, function (listener, index) {
                
                if (listener.func == func && listener.scope == scope) {
                    
                    eventListeners.splice(index, 1)
                    
                    return false
                }
            })
        },
        
        
        getSingleChannel : function (name, doNotCreate) {
            var channels    = this.channels
            
            if (channels[ name ]) return channels[ name ]
            
            if (doNotCreate) return null
            
            return channels[ name ] = new JooseX.Observable.Channel()
        },
        
        
        // (!) segments array will be destroyed in this method
        getChannel : function (segments, doNotCreate) {
            if (!segments.length) return this
            
            var next    = this.getSingleChannel(segments.shift(), doNotCreate)
            
            if (doNotCreate && !next) return null
            
            return next.getChannel(segments, doNotCreate)
        }
    }
})


;
Role('JooseX.Observable', {
    
    /*PKGVERSION*/VERSION : 0.04,
    
//    use : [ 
//        'JooseX.Observable.Channel',    
//        'JooseX.Observable.Listener', 
//        'JooseX.Observable.Event'    
//    ],
    
    
//    trait   : 'JooseX.Observable.Meta',
    
    
    has : {
        rootChannel             : {
            is          : 'rw',
            init        : function () { return new JooseX.Observable.Channel() }
        },
        
        suspendCounter          : 0
    },
    
        
    methods : {
        
        getBubbleTarget : function () {
        },
        
        
        parseEventPath : function (path) {
            var channels    = path.split('/')
            var eventName   = channels.pop()
            
            if (channels.length && !channels[ 0 ]) channels.shift()
            
            return {
                channels        : channels,
                eventName       : eventName
            }
        },
        
        
        on : function (path, func, scope, options) {
            if (!func) throw "Not valid listener function provided when subsribing on event: " + path
            
            var parsed      = this.parseEventPath(path)
            var channel     = this.getRootChannel().getChannel(parsed.channels)
            
            var listener    = new JooseX.Observable.Listener(Joose.O.extend(options || {}, {
                channel     : channel,
                eventName   : parsed.eventName,
                
                func        : func,
                scope       : scope
            }))
            
            channel.addListener(listener)
            
            return listener
        },
        
        
        un : function (path, func, scope) {
            
            if (path instanceof JooseX.Observable.Listener) {
                
                path.remove()
                
                return
            }
            
            var parsed      = this.parseEventPath(path)
            var channel     = this.getRootChannel().getChannel(parsed.channels, true)
            
            if (channel) channel.removeListenerByHandler(parsed.eventName, func, scope)
        },
        
        
        emit : function () {
            return this.fireEvent.apply(this, arguments)
        },
        
        
        fireEvent : function (path) {
            if (this.suspendCounter) return
            
            var args        = Array.prototype.slice.call(arguments, 1)

            var event       = new JooseX.Observable.Event({
                name        : path,
                args        : args,
                
                source      : this
            }) 
            
            return this.propagateEvent(event, path, args)
        },
        
        
        propagateEvent : function (event, path, args) {
            if (this.suspendCounter) return
            
            var parsed      = this.parseEventPath(path)
            var eventName   = parsed.eventName
            
            if (!eventName == '*' || eventName == '**') throw new Error("Can't fire an empty event or event with `*`, `**` names ")
            
            var activators  = []
            
            this.getRootChannel().getListenersFor(parsed.channels, eventName, activators)
            
            var res             = true
            
            event.current       = this
            
            if (activators.length) Joose.A.each(activators, function (activator) {
                event.splat = activator.splat
                
                res = activator.listener.activate(event, args) !== false && res
            })
            
            if (event.bubbling) {
                
                var further = this.getBubbleTarget()
                
                if (further) res = further.propagateEvent(event, path, args) !== false && res
            } 
                
            return res
        },
        
        
        hasListenerFor : function (path) {
            var parsed      = this.parseEventPath(path)
            
            return this.getRootChannel().hasListenerFor(parsed.channels, parsed.eventName)
        },
        
        
        purgeListeners  : function () {
            this.rootChannel.destroy()
            
            this.rootChannel = new JooseX.Observable.Channel()
        },
        
        
        suspendEvents : function () {
            this.suspendCounter++
        },
        
        
        resumeEvents : function () {
            this.suspendCounter--
            
            if (this.suspendCounter < 0) this.suspendCounter = 0
        }
    }
});
;
Class('JooseX.Namespace.Depended.Manager', {
    
    my : {
    
        have : {
            
            INC                             : [ 'lib', '/jsan' ],
            
            disableCaching                  : true,
            
            resources                       : {},
            
            resourceTypes                   : {},
            
            ANONYMOUS_RESOURCE_COUNTER      : 0
        },
    
        
        
        methods : {
            
            //get own resource of some thing (resource will be also attached to that abstract thing)
            //if the something is requesting own resource its considered loaded
            getMyResource : function (type, token, me) {
                var resource = this.getResource({
                    type : type,
                    token : token
                })
                
                if (resource.attachedTo && resource.attachedTo != me) throw resource + " is already attached to [" + resource.attachedTo + "]"
                
                resource.attachedTo     = me
                resource.loaded         = true
                resource.loading        = false
                
                return resource
            },
            
            
            getResource : function (descriptor) {
                
                if (typeof descriptor == 'object') {
                    var type                = descriptor.type = descriptor.type || 'javascript'
                    var token               = descriptor.token
                    var requiredVersion     = descriptor.version
                    
                    delete descriptor.version
                    
                } else 
                    if (typeof descriptor == 'string') {
                    
                        var match = /^(\w+):\/\/(.+)/.exec(descriptor)
                        
                        if (match) {
                            // type & token are explicitly specified
                            type    = match[1]
                            token   = match[2]
                            
                            if (type == 'http' || type == 'https') {
                                token   = type + '://' + token
                                type    = 'javascript'
                            }
                        } else {
                            // no type specified
                            token = descriptor
                            
                            type = /\//.test(token) || /\.js$/.test(token) ? 'javascript' : 'joose'
                        }
                    }
                    
                if (!token) {
                    token       = '__ANONYMOUS_RESOURCE__' + this.ANONYMOUS_RESOURCE_COUNTER++
                    descriptor  = undefined
                }
                
                var id = type + '://' + token
                
                var resource = this.resources[id]
                
                if (!resource) {
                    var resourceClass = this.resourceTypes[type]
                    if (!resourceClass) throw new Error("Unknown resource type: [" + type + "]")
                    
                    resource = this.resources[id] = new resourceClass(typeof descriptor == 'object' ? descriptor : { 
                        token : token,
                        
                        type : type
                    })
                }
                
                resource.setRequiredVersion(requiredVersion)
                
                return resource
            },
            
            
            registerResourceClass : function (typeName, resourceClass) {
                this.resourceTypes[typeName] = resourceClass
            },
            
            
            use : function (dependenciesInfo, callback, scope) {
                Class({
                    use    : dependenciesInfo,
                    
                    body   : function () {
                        if (callback) Joose.Namespace.Manager.my.executeIn(Joose.top, function (ns) {
                            callback.call(scope || this, ns)
                        })
                    }
                })
            },
            
            
            getINC : function () {
                var INC         = this.INC
                var original    = use.__ORIGINAL__
                var paths       = use.paths
                
                // user have modified the `use.path` with direct assignment - return `use.paths`
                if (INC == original && paths != original) return paths
                
                // user have modified the `JooseX.Namespace.Depended.Manager.my.INC` with direct assignment - return it
                if (INC != original && paths == original) return INC
                
                if (INC != original && paths != original) throw "Both INC sources has been modified"
                
                // user was only using the in-place array mutations - return any
                return INC
            }
        }
    }
})

use = function (dependenciesInfo, callback, scope) {
    JooseX.Namespace.Depended.Manager.my.use(dependenciesInfo, callback, scope) 
}

use.paths = use.__ORIGINAL__ = JooseX.Namespace.Depended.Manager.my.INC


Joose.I.FutureClass = function (className) { 
    return function () { 
        return eval(className) 
    } 
}


/**

Name
====


JooseX.Namespace.Depended.Manager - A global collection of all resources


SYNOPSIS
========

        JooseX.Namespace.Depended.Manager.my.registerResourceClass('custom-type', JooseX.Namespace.Depended.Resource.Custom)
        

DESCRIPTION
===========

`JooseX.Namespace.Depended.Manager` is a global collection of all resources. 

**Note:** Its a pure [static](http://joose.github.com/Joose/doc/html/Joose/Manual/Static.html) class - all its methods and properties are static.


METHODS
=======

### registerResourceClass

> `void registerResourceClass(String type, Class constructor)`

> After you've created your custom resource class, you need to register it with call to this method.

> Then you can refer to new resources with the following descriptors: 

                {
                    type    : 'custom-type',
                    token   : 'some-token'
                }



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues>

For general Joose questions you can also visit [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1) on freenode or the mailing list at <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](Resource.html)

General documentation for Joose: <http://joose.github.com/Joose/>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at [http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues](http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues)



AUTHORS
=======

Nickolay Platonov [nplatonov@cpan.org](mailto:nplatonov@cpan.org)



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/
;
Class('JooseX.Namespace.Depended.Resource', {
    
    has : {
        
        attachedTo          : null,
        
        type                : null,
        token               : null,
        
        id                  : null,
        
        loading             : false,
        loaded              : false,
        ready               : false,
        
        presence            : null,
        readyness           : null,
        
        loadedFromURL       : null,
        
        readyListeners      : Joose.I.Array,
        
        dependencies        : Joose.I.Object,
        
        onBeforeReady       : { is : 'rw', init : null },
        readyDelegated      : false,
        
        version             : { is : 'rw', init : null },
        requiredVersion     : { is : 'rw', init : null },
        
        hasReadyCheckScheduled  : false
    },
    
    
    after: {
        
        initialize: function () {
            if (!this.id) this.id = this.type + '://' + this.token
        }
        
    },

    
    
    methods: {
        
        setOnBeforeReady : function (func) {
            if (this.onBeforeReady) throw "Can't redefine 'onBeforeReady' for " + this
            
            this.onBeforeReady = func
        },
        
        
        setVersion : function (version) {
            if (!version) return
            
            if (this.version && this.version != version) throw new Error("Cant redefine version of " + this)
            
            var requiredVersion = this.requiredVersion
            
            if (requiredVersion && version < requiredVersion) throw new Error("Versions conflict on " + this + " required [" + requiredVersion + "], got [" + version + "]")
                
            this.version = version
        },
        
        
        setRequiredVersion : function (version) {
            if (!version) return
            
            var requiredVersion = this.requiredVersion
            
            if (!requiredVersion || version > requiredVersion) 
                if (this.isLoaded() || this.loading)
                    throw "Cant increase required version - " + this + " is already loaded"
                else
                    this.requiredVersion = version
        },
        
        
        toString : function () {
            return "Resource: id=[" + this.id + "], type=[" + this.meta.name + "]"
        },
        
        
        addDescriptor : function (descriptor) {
            var resource = JooseX.Namespace.Depended.Manager.my.getResource(descriptor)
            
            var dependencies    = this.dependencies
            var resourceID      = resource.id
            
            //if there is already such dependency or the resource is ready
            if (dependencies[ resourceID ] || resource.isReady()) return
            
            var me = this
            //pushing listener to the end(!) of the list
            resource.readyListeners.push(function () {
                
                delete dependencies[ resourceID ]
                me.checkReady()
            })
            
            //adding dependency
            dependencies[ resourceID ] = resource
            
            //we are not ready, since there are depedencies to load                
            this.ready = false
        },
        
        
        handleDependencies : function () {
            // || {} required for classes on which this Role was applied after they were created - they have this.dependencies not initialized
            Joose.O.eachOwn(this.dependencies || {}, function (resource) {
                resource.handleLoad()
            })
            
            this.checkReady()
        },
        
        
        checkReady : function () {
            if (!Joose.O.isEmpty(this.dependencies) || this.hasReadyCheckScheduled) return
            
            if (this.onBeforeReady) {
                
                if (!this.readyDelegated) {
                    this.readyDelegated = true
                    
                    var me = this
                    
                    this.onBeforeReady(function(){
                        me.fireReady()
                    }, me)
                }
            } else 
                this.fireReady()
        },
        
        
        fireReady: function () {
            this.ready      = true
            
            var listeners   = this.readyListeners
            
            this.readyListeners = []
            
            Joose.A.each(listeners, function (listener) {
                listener()
            })
        },
        
        
        isReady : function () {
            if (!this.isLoaded()) return false
            
            var isReady = false
            
            try {
                isReady = this.readyness()
            } catch (e) {
            }
            
            return isReady || this.ready
        },
        
        
        isLoaded : function () {
            var isPresent = false
            
            try {
                isPresent = this.presence()
            } catch (e) {
            }
            
            return isPresent || this.loaded
        },
        
        
        handleLoad: function() {
            
            if (this.isLoaded()) {
                this.checkReady()
                return
            }
            
            if (this.loading) return
            this.loading = true
            
            var urls = Joose.O.wantArray(this.getUrls())
            
            var me = this
            
            
            // this delays the 'checkReady' until the resourse will be *fully* materialized
            // *fully* means that even the main class of the resource is already "ready"
            // the possible other classes in the same file could be not
            // see 110_several_classes_in_file.t.js, 120_script_tag_transport.t.js for example
            me.hasReadyCheckScheduled = true
            
            var onsuccess = function (resourceBlob, url) {
                me.loaded = true
                me.loading = false
                
                me.loadedFromURL = url
                
                Joose.Namespace.Manager.my.executeIn(Joose.top, function () {
                    
                    me.materialize(resourceBlob, url)
                })
                
                me.hasReadyCheckScheduled = false
                
                // handle the dependency of the class after its materialization completition
                me.handleDependencies()
            }
            
            var onerror = function (e) {
                //if no more urls
                if (!urls.length) throw new Error(me + " not found") 
                
                me.load(urls.shift(), onsuccess, onerror)
            }
            
            this.load(urls.shift(), onsuccess, onerror)
        },
        

        getUrls: function () {
            throw "Abstract resource method 'getUrls' was called"
        },
        
        
        load : function (url, onsuccess, onerror) {
            throw "Abstract resource method 'load' was called"
        },
        
        
        materialize : function (resourceBlob) {
            throw "Abstract resource method 'materialize' was called"
        }
        
    }
})


/**

Name
====


JooseX.Namespace.Depended.Resource - Abstract resource class 


SYNOPSIS
========
        
        //mostly for subclassing only
        Class("JooseX.Namespace.Depended.Resource.JavaScript", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Resource` is an abstract resource class. Its not supposed to be used directly, instead you should use
one of its subclasses.


ATTRIBUTES
==========

### attachedTo

> `Object attachedTo`

> An arbitrary object to which this resource is attached (its a corresponding class in JooseX.Namespace.Depended)


### type

> `String type`

> A type of resource  - plain string. `JooseX.Namespace.Depended.Manager` maintain a collection of resource types, accessible 


### token

> `String token`

> A token of resource  - plain string with arbitrary semantic. Each subclass should provide this semantic along with `token -> url` conertion method (locator)  


### id

> `String id`

> An id of resource - is computed as `type + '://' + token'


### loading

> `Boolean loading`

> A sign whether this resource is currently loading

  
### loaded

> `Boolean loaded`

> A sign whether this resource is already loaded


### ready

> `Boolean ready`

> A sign whether this resource is considered ready. Resource is ready, when its loaded, and all its dependencies are ready.


### loadedFromURL

> `String loadedFromURL`

> An url, from which the resource was loaded.


### readyListeners

> `Array[Function] readyListeners`

> An array of functions, which will be called after this resource becomes ready. Functions will be called sequentially. 


### dependencies

> `Object dependencies`

> An object containing the dependencies of this resource. Keys are the `id`s of resources and the values - the resource instances itself.

 
### onBeforeReady

> `Function onBeforeReady`

> A function, which will be called, right after the all dependencies of the resource became ready, but before its own `readyListeners` will be called.
It supposed to perform any needed additional actions to post-process the loaded resource.

> Function will receive two arguments - the 1st is the callback, which should be called when `onBeforeReady` will finish its work. 2nd is the resource instance.

  
### version

> `r/w Number version`

> A version of this resource. Currently is handled as Number, this may change in future releases.

  
### requiredVersion

> `r/w Number requiredVersion`

> A *requiredVersion* version of this resource. Required here means the maximum version from all references to this resource. 



METHODS
=======

### addDescriptor

> `void addDescriptor(Object|String descriptor)`

> Add the resource, described with passed descriptor as the dependency for this resource.


### getUrls

> `String|Array[String] getUrls()`

> Abstract method, will throw an exception if not overriden. It should return the array of urls (or a single url) from which this resource can be potentially loaded. 
This method should take into account the `use.paths` setting


### load

> `void load(String url, Function onsuccess, Function onerror)`

> Abstract method, will throw an exception if not overriden. It should load the content of the resource from the passed `url`. If there was an error during loading
(for example file not found) should not throw the exception. Instead, should call the `onerror` continuation with it (exception instance).

> After successfull loading, should call the `onsuccess` continuation with the resource content as 1st argument, and `url` as 2nd: `onsuccess(text, url)`


### materialize

> `void materialize(String resourceBlob, String url)`

> Abstract method, will throw an exception if not overriden. It should "materialize" the resource. The concrete semantic of this action is determined by resource nature.
For example this method can create some tag in the DOM tree, or execute the code or something else.

> Currently this method is supposed to operate synchronously, this may change in future releases. 
 

SEE ALSO
========

Web page of this package: <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Resource/>

General documentation for Joose: <http://joose.github.com/Joose/>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Resource/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/
;
Role('JooseX.Namespace.Depended.Materialize.Eval', {
    
    requires : [ 'handleLoad' ],
    
    methods : {
        
        materialize : function (resourceBlob) {
            // "indirect eval" call 
            (window.execScript || window.eval)(resourceBlob)
        }
    }
})

/**

Name
====


JooseX.Namespace.Depended.Materialize.Eval - materializator, which treat the resource content as JavaScript code, and use `eval` function to evalute it 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Materialize.Eval, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Materialize.Eval` is a materializator role. It provide the implementation of `materialize` method. 


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Class('JooseX.Namespace.Depended.Resource.JavaScript', {
    
    isa : JooseX.Namespace.Depended.Resource,
    
    has : {
        
        hasDirectUrl    : false
    },
    
    after: {
        
        initialize: function () {
            var me      = this
            
            // backward compat
            if (this.type == 'nonjoose') this.type = 'javascript'
            
            
            var presence = this.presence
            
            if (typeof presence == 'string') this.presence = function () {
                return eval(presence)
            }
            
            if (!presence) this.presence = function () {
                return eval(me.token)
            }
            
            if (!this.readyness) this.readyness = this.presence
        }
        
    },

    
    methods : {
        
        BUILD : function (config) {
            var token = config.token
            
            var match = /^=(.*)/.exec(token)
            
            if (match) {
                this.hasDirectUrl   = true
                
                token               = match[1]
            }
            
            if (/^http/.test(token)) {
                this.hasDirectUrl   = true
                
                config.trait        = JooseX.Namespace.Depended.Transport.ScriptTag
            }
            
            if (/^\//.test(token)) this.hasDirectUrl   = true
                
            return config
        },
        
        
        getUrls : function () {
            var url = this.token
            
            if (this.hasDirectUrl) return [ url ]
            
            var manager = JooseX.Namespace.Depended.Manager.my
            
            return Joose.A.map(manager.getINC(), function (libroot) {
                libroot = libroot.replace(/\/$/, '')
                
                return [ libroot ].concat(url).join('/') + (manager.disableCaching ? '?disableCaching=' + new Date().getTime() : '')
            })
        }
    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('javascript',    JooseX.Namespace.Depended.Resource.JavaScript)
JooseX.Namespace.Depended.Manager.my.registerResourceClass('nonjoose',      JooseX.Namespace.Depended.Resource.JavaScript)
;
Class('JooseX.Namespace.Depended.Resource.JooseClass', {
    
    isa : JooseX.Namespace.Depended.Resource.JavaScript,
    
    // NOTE : we don't add the default materialization and transport roles here - they'll be added
    // in one of the Bootstrap/*.js files
    
    after: {
        
        initialize: function () {
            var me = this
            
            this.presence = function () {
                var c = Joose.S.strToClass(me.token)
                
                return c && c.meta.resource
            }
            
            this.readyness = function () {
                var c = eval(me.token)
                
                return c && c.meta.resource.ready
            }
        }
        
    },
    
    
    methods : {
        
        addDescriptor : function (descriptor) {
            if (typeof descriptor == 'object' && !descriptor.token) 
                Joose.O.eachOwn(descriptor, function (version, name) {
                    this.addDescriptor({
                        type : 'joose',
                        token : name,
                        version : version
                    })
                }, this)
            else
                this.SUPER(descriptor)
        },
        
        
        getUrls : function () {
            var urls = []
            var className = this.token.split('.')
            
            var manager = JooseX.Namespace.Depended.Manager.my
            
            return Joose.A.map(manager.getINC(), function (libroot) {
                libroot = libroot.replace(/\/$/, '')
                
                return [ libroot ].concat(className).join('/') + '.js' + (manager.disableCaching ? '?disableCaching=' + new Date().getTime() : '')
            })
        }
    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('joose', JooseX.Namespace.Depended.Resource.JooseClass);
;
if (typeof JooseX != "undefined" && !JooseX.SimpleRequest) {;
Class("JooseX.SimpleRequest", {

    have : {
    	req : null
	},

    
    methods: {
    	
        initialize: function () {
            if (window.XMLHttpRequest)
                this.req = new XMLHttpRequest()
            else
                this.req = new ActiveXObject("Microsoft.XMLHTTP")
        },
        
        
        getText: function (urlOrOptions, async, callback, scope) {
            var req = this.req
            
            var headers
            var url
            
            if (typeof urlOrOptions != 'string') {
                headers = urlOrOptions.headers
                url = urlOrOptions.url
                async = async || urlOrOptions.async
                callback = callback || urlOrOptions.callback
                scope = scope || urlOrOptions.scope
            } else url = urlOrOptions
            
            req.open('GET', url, async || false)
            
            if (headers) Joose.O.eachOwn(headers, function (value, name) {
                req.setRequestHeader(name, value)
            })
            
            try {
                req.onreadystatechange = function (event) {  
                    if (async && req.readyState == 4) {  
                        // status is set to 0 for failed cross-domain requests.. 
                        if (req.status == 200 /*|| req.status == 0*/) callback.call(scope || this, true, req.responseText)
                        else callback.call(scope || this, false, "File not found: " + url)
                    }  
                };  
                req.send(null)
            } catch (e) {
                throw "File not found: " + url
            }
            
            if (!async)
                if (req.status == 200 || req.status == 0) return req.responseText; else throw "File not found: " + url
            
            return null
        }
    }
})
;
};
Role('JooseX.Namespace.Depended.Materialize.ScriptTag', {
    
    requires : [ 'handleLoad' ],
    
    methods : {
        
        materialize : function (resourceBlob) {
            var loaderNode = document.createElement("script")
            
            loaderNode.text = resourceBlob
            
            //adding to body, because Safari do not create HEAD for iframe's documents
            document.body.appendChild(loaderNode)
        }
    }
})
;
Role('JooseX.Namespace.Depended.Transport.XHRAsync', {
    
    requires : [ 'handleLoad' ],
    
    override : {
        
        load: function (url, onsuccess, onerror) {
            var req = new JooseX.SimpleRequest()
            
            try {
                req.getText(url, true, function (success, text) {
                    
                    if (!success) { 
                        onerror(this + " not found") 
                        return 
                    }
                    
                    onsuccess(text, url)
                })
            } catch (e) {
                onerror(e)
            }
        }
    }
})


/**

Name
====


JooseX.Namespace.Depended.Transport.XHRAsync - transport, which use the asynchronous XHR request for resource loading 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.XHRAsync, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.XHRAsync` is a transport role. It provide the implementation of `load` method, which use the 
asynchronous XHR request for resource loading. 



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Transport.ScriptTag', {
    
    requires : [ 'handleLoad' ],
    
    
    methods : {
        
        getScriptTag : function () {
            
        }
    },
    
    
    override : {
        
        load: function (url, onsuccess, onerror) {

            var scriptNode       = document.createElement('script')

            scriptNode.type      = 'text/javascript'
            scriptNode.src       = url
            scriptNode.async     = true
            
            
            if (Joose.is_IE) {
                
                var timeout    = setTimeout(function () {
                    
                    onerror(url + " load failed.")
                    
                }, 10000)
                
                scriptNode.onreadystatechange = function() {
                    
                    var readyState = scriptNode.readyState
                    
                    if (readyState == 'complete' || readyState == 'loaded') {
                        
                        clearTimeout(timeout)
                            
                        onsuccess(null, url)
                    }
                }
                
                
            } else {
                
                scriptNode.onload = function() {
                    onsuccess(scriptNode.text, url)
                }
            
                scriptNode.onerror = function () {
                    onerror(url + " load failed.")
                }
            }
                
            var head            = document.getElementsByTagName('head')[0] || document.body
            
            head.appendChild(scriptNode)
        },
        
        
        materialize : function (blob, url) {
        }
    }
})



/**

Name
====


JooseX.Namespace.Depended.Transport.ScriptTag - transport, which use the &lt;script&gt; tag for resource loading 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.ScriptTag, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.ScriptTag` is a transport role. It provide the implementation of `load` method, which use the 
&lt;script&gt; tag for resource loading. It also overrides the `materialize` method as &lt;script&gt; tag execute the code along with loading. 



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Transport.NodeJS', {

    requires : [ 'handleLoad' ],
    
    override : {
        
        load: function (url, onsuccess, onerror) {
            var fs = require('fs')
            
            try {
                var content = fs.readFileSync(url, 'utf8')
                
            } catch (e) {
                
                onerror(e)
                
                return
            }
            
            onsuccess(content, url)
            
//            fs.readFile(url, function (err, data) {
//                if (err) {
//                    onerror(err)
//                    
//                    return
//                }
//                
//                onsuccess(data, url)
//            })            
        }
    }
})


/**

Name
====


JooseX.Namespace.Depended.Transport.Node - transport, which use the `fs.readFileSync()` call of NodeJS, to load the content of resource. 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.Node, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.Node` is a transport role. It provide the implementation of `load` method, 
which use the `fs.readFile()` call of NodeJS for resource loading. 

This transport behaves synchronously.



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Materialize.NodeJS', {
    
    requires : [ 'handleLoad' ],
    
    methods : {
        
        materialize : function (resourceBlob, url) {
            
            if (global.__PROVIDER__)
//                require('vm').runInThisContext(resourceBlob + '', url)    
            
//                // running in Test.Run
//                
                eval(resourceBlob + '')
            
            else
                // global scope
                require('vm').runInThisContext('(function (exports, require, module, __filename, __dirname) {' + resourceBlob + '})', url)(exports, require, module, __filename, __dirname)
        }
    }
})

/**

Name
====


JooseX.Namespace.Depended.Materialize.NodeJS - materializator, which execute the code, using the `Script.runInThisContext` call of NodeJS. 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Materialize.NodeJS, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Materialize.NodeJS` is a materializator role. It provide the implementation of `materialize` method. 


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Class('JooseX.Namespace.Depended.Resource.Require', {
    
    isa     : JooseX.Namespace.Depended.Resource,
    
    
    methods : {
        
        getUrls : function () {
            return [ this.token ]
        },
        
        
        load: function (url, onsuccess, onerror) {
            
            require.async(url, function (err) {
                if (err instanceof Error) 
                    onerror(err)
                else
                    onsuccess('', url)
            })
            
        },

        
        materialize : function () {
        }
        
    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('require', JooseX.Namespace.Depended.Resource.Require)
;
Role('JooseX.Namespace.Depended', {
    
    /*VERSION,*/
    
    meta : Joose.Managed.Role,
    
    requires : [ 'prepareProperties' ],
    
    
    have : {
        containResources                    : [ 'use', 'meta', 'isa', 'does', 'trait', 'traits' ]
    },

    
    override: {
        
//        GETCURRENT : function () {
//            var currentModule   = this.getCurrent()
//            
//            return currentModule == Joose.top ? 'TOP' : currentModule.meta.name
//        },
        
        
        prepareProperties : function (name, extend, defaultMeta, callback) {
            if (name && typeof name != 'string') {
                extend = name
                name = null
            }
            
            extend = extend || {}
            
            var summaredDeps    = this.collectAllDeps(extend)
            var currentModule   = this.getCurrent()
            
            if (currentModule !== Joose.top && !currentModule.meta) {
                require('console').log("CURRENT MODULE: %s", require('util').inspect(currentModule))
                require('console').log("TOP: %s", require('util').inspect(Joose.top))
            }
            
            var resource = JooseX.Namespace.Depended.Manager.my.getResource({
                type    : 'joose',
                token   : currentModule == Joose.top ? name : currentModule.meta.name + '.' + name
            })
            
            
            if (extend.VERSION) resource.setVersion(extend.VERSION)
            
            //BEGIN executes right after the all dependencies are loaded, but before this module becomes ready (before body())
            //this allows to manually control the "ready-ness" of module (custom pre-processing)
            //BEGIN receives the function (callback), which should be called at the end of custom processing 
            if (extend.BEGIN) {
                resource.setOnBeforeReady(extend.BEGIN)
                
                delete extend.BEGIN
            }
            
            Joose.A.each(summaredDeps, function (descriptor) {
                resource.addDescriptor(descriptor)
            })
            
            
            //skip constructing for classes w/o dependencies 
            if (Joose.O.isEmpty(resource.dependencies)) {
                this.inlineAllDeps(extend)
                
                var res = this.SUPER(name, extend, defaultMeta, callback)
                
                //this will allow to classes which don't have dependencies to be ready synchronously
                resource.checkReady()
                
                return res
            } else {
                
                var me      = this
                var SUPER   = this.SUPER
                
                var current
                
                //unshift is critical for correct order of readyListerens processing!
                //constructing is delaying until resource will become ready 
                resource.readyListeners.unshift(function () {
                    me.inlineAllDeps(extend)
                    
                    Joose.Namespace.Manager.my.executeIn(currentModule, function () {
                        
                        SUPER.call(me, name, extend, defaultMeta, callback)
                    })
                })
                
                // running as <script> in browser or as main script in node
                if (!resource.hasReadyCheckScheduled) 
                    if (Joose.is_NodeJS) 
                        resource.handleDependencies()
                    else
                        // defer the dependencies loading, because they actually could be provided later in the same bundle file
                        // this, however, affect performance, so bundles should be created in the dependencies-ordered way
                        setTimeout(function () {
                            resource.handleDependencies()
                        }, 0)
                
                
                return this.create(name, Joose.Namespace.Keeper, {})
            }
        },
        
        
        prepareMeta : function (meta) {
            meta.resource = meta.resource || JooseX.Namespace.Depended.Manager.my.getMyResource('joose', meta.name, meta.c)
        }
    },
    //eof override
    
    
    methods : {
        
        alsoDependsFrom : function (extend, summaredDeps) {
        },
        
        
        collectAllDeps : function (extend) {
            var summaredDeps    = []
            var me              = this
            
            //gathering all the related resourses from various builders
            this.collectClassDeps(extend, summaredDeps)
            
            var extendMy = extend.my
            
            //gathering resourses of 'my'
            this.collectClassDeps(extendMy, summaredDeps)
            

            //gathering resourses from own attributes
            if (extend.has) Joose.O.each(extend.has, function (attr, name) {
                // do not try to collect the dependencies when class is given as init value
                if (Joose.O.isClass(attr)) return 
                
                me.collectClassDeps(attr, summaredDeps)
            })
            
            //gathering resourses from attributes of `my`
            if (extendMy && extendMy.has) Joose.O.each(extendMy.has, function (attr, name) {
                // do not try to collect the dependencies when class is given as init value
                if (Joose.O.isClass(attr)) return
                
                me.collectClassDeps(attr, summaredDeps)
            })
            
            //and from externally collected additional resources 
            this.alsoDependsFrom(extend, summaredDeps)
            
            return summaredDeps
        },
        
        
        collectClassDeps : function (from, to) {
            
            if (from) Joose.A.each(this.containResources, function (propName) {
                
                this.collectDependencies(from[propName], to, from, propName)
                
            }, this)
        },
        
        
        collectDependencies : function (from, to, extend, propName) {
            if (from) Joose.A.each(Joose.O.wantArray(from), function (descriptor) {
                if (descriptor && typeof descriptor != 'function') to.push(descriptor)
            })
        },
        
        
        inlineAllDeps : function (extend) {
            var me              = this
            
            this.inlineDeps(extend)
            
            var extendMy = extend.my
            
            if (extendMy) this.inlineDeps(extendMy)
            

            if (extend.has) Joose.O.each(extend.has, function (attr, name) {
                
                if (attr && typeof attr == 'object') me.inlineDeps(attr)
            })
            
            if (extendMy && extendMy.has) Joose.O.each(extendMy.has, function (attr, name) {
                
                if (attr && typeof attr == 'object') me.inlineDeps(attr)
            })
        },
        
        
        inlineDeps : function (extend) {
            delete extend.use
            
            Joose.A.each(this.containResources, function (propName) {
                
                if (extend[propName]) {
                
                    var descriptors = []
                    
                    Joose.A.each(Joose.O.wantArray(extend[propName]), function (descriptor, index) {
                        
                        var descType = typeof descriptor
                        
                        if (descType == 'function')
                            descriptors.push(descriptor.meta ? descriptor : (propName != 'isa' ? descriptor() : null ))
                        else
                            if (descType == 'object')
                                if (descriptor.token)
                                    descriptors.push(eval(descriptor.token)) 
                                else
                                    Joose.O.each(descriptor, function (version, name) { 
                                        descriptors.push(eval(name)) 
                                    })
                            else 
                                if (descType == 'string')
                                    descriptors.push(eval(descriptor))
                                else 
                                    throw new Error("Wrong dependency descriptor format: " + descriptor)
                        
                    })
                    
                    if (propName != 'isa' && propName != 'meta')
                        extend[propName] = descriptors
                    else
                        if (descriptors.length > 1) 
                            throw "Cant specify several super- or meta- classes"
                        else
                            if (descriptors[0]) extend[propName] = descriptors[0]
                        
                }
            })
        }
    }
})


Joose.Namespace.Manager.meta.extend({
    does : JooseX.Namespace.Depended
})

;
if (Joose.is_NodeJS) {

    JooseX.Namespace.Depended.Resource.JavaScript.meta.extend({
        
        does : [ JooseX.Namespace.Depended.Transport.NodeJS, JooseX.Namespace.Depended.Materialize.NodeJS ]
    })
    
    
    
    JooseX.Namespace.Depended.Manager.my.disableCaching = false
    
    Joose.Namespace.Manager.my.containResources.unshift('require')
    
    
    
    JooseX.Namespace.Depended.meta.extend({
        
        override : {
            
            collectDependencies : function (from, to, extend, propName) {
                if (propName != 'require') return this.SUPERARG(arguments)
                
                if (!from) return
                
                Joose.A.each(Joose.O.wantArray(from), function (url) {
                    to.push({
                        type    : 'require',
                        token   : url
                    })
                })
                
                delete extend.require
            }
        }
    })
} else
    JooseX.Namespace.Depended.Resource.JavaScript.meta.extend({
        
        does : [ JooseX.Namespace.Depended.Transport.XHRAsync, JooseX.Namespace.Depended.Materialize.Eval ]
    })
;
;
Class('Scope.Provider', {
    
    /*VERSION,*/
    
    has     : {
        name                : null,
        
        launchId            : null,
        
        scope               : null,
        
        seedingCode         : null,
        seedingScript       : null,
        
        preload             : {
            is      : 'ro',
            init    : Joose.I.Array
        },
        
        cleanupCallback         : null,
        beforeCleanupCallback   : null
    },
    
        
    methods : {
        
        isCSS : function (url) {
            return /\.css(\?.*)?$/i.test(url)
        },
        
        
        isAlreadySetUp : function () {
            return Boolean(this.scope)
        },
        
        
        addPreload : function (preloadDesc) {
            if (this.isAlreadySetUp()) throw new Error("Can't use `addPreload` - scope is already setup. Use `runCode/runScript` instead")
            
            if (typeof preloadDesc == 'string')
                
                if (this.isCSS(preloadDesc)) 
                    preloadDesc = {
                        type        : 'css',
                        url         : preloadDesc
                    }
                else
                    preloadDesc = {
                        type        : 'js',
                        url         : preloadDesc
                    }
            else
            
                if (preloadDesc.text) 
                    preloadDesc = {
                        type        : 'js',
                        content     : preloadDesc.text
                    }
                    
            if (!preloadDesc.type) throw new Error("Preload descriptor must have the `type` property")
                
            this.preload.push(preloadDesc)
        },
        
        
        addOnErrorHandler : function (handler, callback) {
            throw "Abstract method `addOnErrorHandler` of Scope.Provider called"
        },
        
        
        create : function () {
            throw "Abstract method `create` of Scope.Provider called"
        },
        
        
        setup : function (callback) {
            throw "Abstract method `setup` of Scope.Provider called"
        },
        
        
        cleanup : function (callback) {
            throw "Abstract method `cleanup` of Scope.Provider called"
        },
        
        
        runCode : function (text, callback) {
            throw "Abstract method `runCode` of Scope.Provider called"
        },
        
        
        runScript : function (url, callback) {
            throw "Abstract method `runScript` of Scope.Provider called"
        }
    }
})


Scope.Provider.__ONLOAD__   = {}
Scope.Provider.__ONERROR__  = {}
Scope.Provider.__FAILED_PRELOAD__  = {};
Role('Scope.Provider.Role.WithDOM', {
    
    requires    : [ 'getDocument', 'create', 'getPreload', 'isAlreadySetUp', 'setViewportSize' ],
    
    has : {
        useStrictMode   : true,
        sourceURL       : null,
        
        innerHtmlHead   : null,
        innerHtmlBody   : null,
        
        minViewportSize : null,
        
        parentWindow    : function () { return window },
        scopeId         : function () { return Math.round(Math.random() * 1e10) },
        
        failOnResourceLoadError     : false,
        
        //                init function
        attachToOnError : function () {
            
            // returns the value of the attribute
            // the "handler" argument is no longer used, its now being taken from the __ONERROR__ handler every time
            return function (window, scopeId, handler, preventDefault, failOnResourceLoadError) {
                handler     = (window.opener || window.parent).Scope.Provider.__ONERROR__[ scopeId  ]
                
                if (failOnResourceLoadError && ("ErrorEvent" in window)) {
//                    if (window.ErrorEvent.__SIESTA_HOOK_INSTALLED__) return
                    
                    // http://stackoverflow.com/questions/8504673/how-to-detect-on-page-404-errors-using-javascript
                    window.addEventListener('error', handler, true)
                    
//                    window.ErrorEvent.__SIESTA_HOOK_INSTALLED__ = true
                } else {
                    var prevHandler         = window.onerror
                    if (prevHandler && prevHandler.__SP_MANAGED__) return
                    
                    // this, "managed" handler is basically a wrapper around the current value in the "__ONERROR__" hash
                    window.onerror = function (message, url, lineNumber) {
                        // prevent recursive calls if other authors politely has not overwrite the handler and call it
                        if (handler.__CALLING__) return
                        
                        handler.__CALLING__ = true
                        
                        prevHandler && prevHandler.apply(this, arguments)
                    
                        handler.apply(this, arguments)
                        
                        handler.__CALLING__ = false
                        
                        // in FF/IE need to return `true` to prevent default action
                        if (preventDefault !== false) return window.WebKitPoint ? false : true 
                    }
                    
                    window.onerror.__SP_MANAGED__ = true
                }
            } 
        },
        
        // this is a "cached" onerror handler - a handler which was provided before the scope
        // has started the creation process - should be installed ASAP in the creation process
        // to allow catching of the exceptions in the scope with `sourceURL` 
        cachedOnError   : null
    },
    
    
    override : {
        
        cleanup : function () {
            var onErrorHandler  = this.cachedOnError
            
            this.cachedOnError  = null
            
            // can throw exceptions for cross-domain case
            try {
                var scope       = this.scope
                
                if (scope.ErrorEvent && scope.ErrorEvent.__SIESTA_HOOK_INSTALLED__) scope.removeEventListener('error', onErrorHandler)
                
                scope.onerror  = null
            } catch (e) {
            }
            
            this.SUPERARG(arguments)
            
            this.scope          = null
        }
    },
    
    
    methods : {
        
        cleanupHanlders : function () {
            var scopeProvider   = this.parentWindow.Scope.Provider
            var scopeId         = this.scopeId
            
            delete scopeProvider.__ONLOAD__[ scopeId ]
            delete scopeProvider.__ONERROR__[ scopeId ]
            delete scopeProvider.__FAILED_PRELOAD__[ scopeId ]
        },
        
        
        getHead : function () {
            return this.getDocument().getElementsByTagName('head')[ 0 ]
        },
        
        
        installOnErrorHandler : function (handler) {
            if (!this.isAlreadySetUp()) throw "Scope should be already set up"
            
            this.attachToOnError(this.scope, this.scopeId, handler, false, this.failOnResourceLoadError)
        },
        
        
        addOnErrorHandler : function (handler, preventDefault) {
            handler.__SP_MANAGED__  = true
            
            this.cachedOnError      = handler
            
            var scopeId     = this.scopeId
            
            this.parentWindow.Scope.Provider.__ONERROR__[ scopeId ] = handler
            
            var attachToOnError = ';(' + this.attachToOnError.toString() + ')(window, ' 
                + scopeId 
                + ', (window.opener || window.parent).Scope.Provider.__ONERROR__[ ' + scopeId + ' ], ' 
                + preventDefault + ', ' 
                + this.failOnResourceLoadError 
            + ');'
            
            if (this.isAlreadySetUp()) 
                this.runCode(attachToOnError)
            else {
                // this is a fallback - run the "attachToOnError" from inside of scope
                this.getPreload().unshift({
                    type        : 'js',
                    content     : attachToOnError,
                    unordered   : true
                })
            }
        },
        
        
        addSeedingToPreload : function () {
            var preload             = this.getPreload()
                
            if (this.seedingCode) preload.unshift({
                type        : 'js',
                content     : this.seedingCode
            })
            
            if (this.seedingScript) preload.push({
                type        : 'js',
                url         : this.seedingScript
            })
        },
        
        
        setup : function (callback) {
            var isIE                = 'v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)
//            var isOpera             = Object.prototype.toString.call(this.parentWindow.opera) == '[object Opera]'
            var hasInlineScript     = false
            
            Joose.A.each(this.getPreload(), function (preloadDesc) {
                // IE will execute the inline scripts ASAP, this might be not what we want (inline script might be need executed only after some url script)
                // its however ok in some cases (like adding `onerror` handler
                // such inline scripts should be marked with `unordered` - true
                if (preloadDesc.type == 'js' && preloadDesc.content && !preloadDesc.unordered) {
                    hasInlineScript = true
                    
                    return false
                } 
            })
            
            var me          = this
            
            var cont        = function () {
                callback && callback(me, me.parentWindow.Scope.Provider.__FAILED_PRELOAD__[ me.scopeId ])
            }
            
            this.parentWindow.Scope.Provider.__FAILED_PRELOAD__[ this.scopeId ] = {}
            
            if (this.sourceURL || isIE && hasInlineScript) {
                this.addSeedingToPreload()
                
                this.setupIncrementally(cont)
                
            } else {
                // for sane browsers just add the seeding code and seeding script to preloads
                if (!isIE) this.addSeedingToPreload()
                
                // seeding scripts are included only for sane browsers (not IE)
                this.setupWithDocWrite(cont, isIE)
            }
        },
        
        
        setupWithDocWrite : function (callback, needToSeed) {
            var html        = []
            var me          = this
            
            Joose.A.each(this.getPreload(), function (preloadDesc) {
                
                if (preloadDesc.type == 'js') 
                    html.push(me.getScriptTagString(preloadDesc.url, preloadDesc.content))
                    
                else if (preloadDesc.type == 'css') 
                    html.push(me.getLinkTagString(preloadDesc.url, preloadDesc.content))
                
                else throw "Incorrect preload descriptor " + preloadDesc
            })
            
            // no need to wait for DOM ready - we'll overwrite it anyway
            this.create()
            
            var scopeId              = this.scopeId
            
            this.parentWindow.Scope.Provider.__ONLOAD__[ scopeId ]    = function () {
                var cont = function () { callback && callback() }
                
                // sane browsers - seeding code and script has been already added
                if (!needToSeed) { cont(); return }
                
                // our beloved IE - manually seeding the scope
                
                if (me.seedingCode) me.runCode(me.seedingCode)
                
                if (me.seedingScript) 
                    me.runScript(me.seedingScript, cont)
                else
                    cont()
            }
            
            var doc             = this.getDocument()
            
            doc.open()
            
            doc.write([
                this.useStrictMode ? '<!DOCTYPE html>' : '',
                '<html style="width: 100%; height: 100%; margin : 0; padding : 0;">',
                    '<head>',
                        this.innerHtmlHead || '',
                        html.join(''),
                    '</head>',
    
                    // delay here is for IE9 - the "onerror" handlers of the <script> tags are fired _after_ <body> onload otherwise
                    '<body style="margin : 0; padding : 0; width: 100%; height: 100%" onload="setTimeout(function () { (window.opener || window.parent).Scope.Provider.__ONLOAD__[' + scopeId + ']() }, 0)">',
                        this.innerHtmlBody || '',
                    '</body>',
                '</html>'
            ].join(''))
            
            doc.close()
            
            // Chrome (Webkit?) will clear the `onerror` after "doc.open()/.close()" so need to re-install it
            if (me.cachedOnError) me.installOnErrorHandler(me.cachedOnError)
        },
        
        
        setupIncrementally : function (callback) {
            var me      = this
            
            // here the "onerror" should be included early in the "preloads" 
            this.create(function () {
                if (!me.sourceURL) {
                    var doc     = me.getDocument()
                    
                    if (me.innerHtmlHead) {
                        var head    = me.getHead()
                        
                        // IE9 throws exception when accessing innerHTML of the <head> - its read only 
                        try {
                            head.innerHTML  = me.innerHtmlHead
                        } catch (e) {
                            var div         = doc.createElement('div')
                            
                            div.innerHTML   = me.innerHtmlHead
                            
                            for (var i = 0; i < div.children.length; i++) head.appendChild(div.children[ i ])
                        }
                    }
                    
                    if (me.innerHtmlBody) doc.body.innerHTML = me.innerHtmlBody
                }
                
                var loadScripts     = function (preloads, callback) {
                    
                    var cont = function () {
                        // cleanup can happen in the middle of setup
                        if (me.scope) loadScripts(preloads, callback) 
                    }
                    
                    if (!preloads.length) 
                        callback && callback()
                    else {
                        var preloadDesc     = preloads.shift()
                        
                        if (preloadDesc.url) 
                            me.runScript(preloadDesc.url, cont)
                        else 
                            if (preloadDesc.type == 'js')
                                me.runCode(preloadDesc.content, cont)
                            else {
                                me.addStyleTag(preloadDesc.content)
                                
                                cont()
                            }
                    }
                }
                
                // cleanup can happen in the middle of setup
                if (me.scope) loadScripts(me.getPreload().slice(), callback)
            })
        },        
        
        
        getScriptTagString : function (url, text) {
            var res = '<script type="text/javascript"'
            
            var onerror = '(window.opener || window.parent).Scope.Provider.__FAILED_PRELOAD__[ scopeId ][ url ] = true'
            
            onerror     = onerror.replace(/scopeId/, "'" + this.scopeId + "'").replace(/url/, "'" + url + "'")
            
            if (url) 
                res     += ' src="' + url + '" onerror="' + onerror + '"></script>'
            else
                res     += '>' + text.replace(/<\/script>/gi, '\\x3C/script>') + '</script>'
                
            return res
        },
        
        
        getLinkTagString : function (url, text) {
            if (url) return '<link href="' + url + '" rel="stylesheet" type="text/css" />'
            
            if (text) return '<style>' + text + '</style>'
        },
        
        

        loadCSS : function (url, callback) {
            var doc         = this.getDocument()
            var link        = doc.createElement('link')
            
            link.type       = 'text/css'
            link.rel        = 'stylesheet'
            link.href       = url
        
            this.getHead().appendChild(link)
            
            var hasContinued    = false
            
            var cont            = function () {
                // just in case some crazy JS engine calls `onerror` even after node removal
                if (hasContinued) return
                hasContinued    = true
                clearTimeout(forcedTimeout)
                
                if (callback) callback()
                
                doc.body.removeChild(img)
            }
            
            var forcedTimeout   = setTimeout(cont, 3000)
        
            var img             = doc.createElement('img')
            
            img.onerror         = cont
        
            doc.body.appendChild(img)
            
            img.src             = url
        },
        
        
        runCode : function (text, callback) {
            this.getHead().appendChild(this.createScriptTag(text))
            
            callback && callback()
        },
        
        
        runScript : function (url, callback) {
            var scopeId     = this.scopeId
            
            if (this.isCSS(url))
                this.loadCSS(url, callback)
            else {
                var onerror = function () {
                    this.onerror    = null
                    
                    var doc         = this.ownerDocument
                    var win         = doc.defaultView || doc.parentWindow
                    
                    ;(win.opener || win.parent).Scope.Provider.__FAILED_PRELOAD__[ scopeId ][ url ] = true
                    
                    callback()
                }
                
                this.getHead().appendChild(this.createScriptTag(null, url, callback, onerror))
            }
        },
        
        
        createScriptTag : function (text, url, callback, errback) {
            var node = this.getDocument().createElement("script")
            
            node.setAttribute("type", "text/javascript")
            
            if (url) node.setAttribute("src", url)
            
            if (text) node.text = text
            
            if (callback) node.onload = node.onreadystatechange = function() {
                if (!node.readyState || node.readyState == "loaded" || node.readyState == "complete" || node.readyState == 4 && node.status == 200) {
                    node.onload = node.onreadystatechange = null
                    
                    //surely for IE6..
                    if ('v' == '\v') 
                        setTimeout(callback, 0)
                    else
                        callback()
                }
            }
            
            if (errback) node.onerror = errback
            
            return node
        },
        
        
        addStyleTag : function (text) {
            var document    = this.getDocument()
            var node        = document.createElement('style')
            
            node.setAttribute("type", "text/css")
            
            var head = document.getElementsByTagName('head')[0]
            head.appendChild(node)
            
            if (node.styleSheet) {   // IE
                node.styleSheet.cssText = text
            } else {                // the world
                node.appendChild(document.createTextNode(text))
            }
        }        
    }
})


/**

Name
====

Scope.Provider.Role.WithDOM - role for scope provider, which uses `script` tag for running the code.


SYNOPSIS
========

        Class('Scope.Provider.IFrame', {
            
            isa     : Scope.Provider,
            
            does    : Scope.Provider.Role.WithDOM,
            
            ...
        })

DESCRIPTION
===========

`Scope.Provider.Role.WithDOM` requires the implementation of the `getDocument` method, which should return the
document into which the `script` tags will be created.

In return, this role provides the implementation of `runCode` and `runScript`.




GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

For general Joose questions you can also visit [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1) 
on irc.freenode.org or the forum at: <http://joose.it/forum>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
Class('Scope.Provider.IFrame', {
    
    isa     : Scope.Provider,
    
    does    : Scope.Provider.Role.WithDOM,
    
    
    have : {
        iframe          : null,
        cls             : null,
        
        performWrap     : false,
        wrapCls         : null,
        wrapper         : null,
        
        // should be inside of the `wrapper` el
        iframeParentEl  : null,
        parentEl        : null,
        
        cleanupDelay    : 1000
    },
    

    methods : {
        
        getDocument : function () {
            return this.iframe.contentWindow.document
        },
        
        
        setViewportSize : function (width, height) {
            var iframe              = this.iframe
            
            if (!iframe) return
            
            iframe.style.width      = width + 'px'
            iframe.style.height     = height + 'px'
        },
        
        
        create : function (onLoadCallback) {
            var me                  = this
            var doc                 = this.parentWindow.document
            var iframe              = this.iframe = doc.createElement('iframe')
            
            var minViewportSize     = this.minViewportSize
            
            iframe.className        = this.cls || ''
            iframe.style.width      = (minViewportSize && minViewportSize.width || 1024) + 'px'
            iframe.style.height     = (minViewportSize && minViewportSize.height || 768) + 'px'
            iframe.setAttribute('frameborder', 0)
            
            if (this.name) iframe.setAttribute('name', this.name)

            var ignoreOnLoad        = false    
            
            var callback = function () {
                if (ignoreOnLoad) return
                
                if (iframe.detachEvent) 
                    iframe.detachEvent('onload', callback)
                else
                    iframe.onload = null
                
                onLoadCallback && onLoadCallback(me)
            }
            
            if (iframe.attachEvent) 
                iframe.attachEvent('onload', callback)
            else
                iframe.onload   = callback
            
            iframe.src = this.sourceURL || 'about:blank'
            
            if (this.performWrap) {
                var wrapper             = this.wrapper
                
                if (!wrapper) {
                    wrapper             = this.wrapper = doc.createElement('div')
                    wrapper.className   = this.wrapCls || ''
                }
                
                ;(this.iframeParentEl || wrapper).appendChild(iframe)
                
                // no required anymore, since whole wrapper will be removed
                this.iframeParentEl     = null
            } 
            
            ;(this.parentEl || doc.body).appendChild(wrapper || iframe)
            
            var scope   = this.scope = iframe.contentWindow
            var doc     = this.getDocument()
            
            // dances with tambourine around the IE, somehow fixes the cross-domain limits
            if ('v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)) {
                // only ignore the 1st call to callback when there is a `sourceURL` config
                // which will later be assigned to `iframe.src` and will trigger a new iframe loading
                if (this.sourceURL) ignoreOnLoad = true
                
                doc.open()
                doc.write('')
                doc.close()
                
                ignoreOnLoad = false
                
                iframe.onreadystatechange = function () {
                    if (iframe.readyState == 'complete') iframe.onreadystatechange = null
                    
                    // trying to add the "early" onerror handler on each "readyState" change
                    // for some mystical reasons can't use `me.installOnErrorHandler` need to inline the call
                    if (me.cachedOnError) me.attachToOnError(scope, me.scopeId, me.cachedOnError)
                }
                
                if (this.sourceURL) iframe.src = this.sourceURL
            }
            
            // trying to add the "early" onerror handler - installing it in this stage will only work in FF 
            // (other browsers will clear on varios stages)
            if (me.cachedOnError) me.installOnErrorHandler(me.cachedOnError)
        },
        
        
        cleanup : function () {
            var wrapper     = this.wrapper || this.iframe
            var iframe      = this.iframe
            var me          = this
            
            // remove this property one more time, because sometimes it is not cleared in IE
            // (seems "onreadystatechange" is not fired)
            iframe.onreadystatechange   = null
            
            wrapper.style.display    = 'none'
            
            var onUnloadChecker = function () {
                if (!window.onunload) window.onunload = function () { return 'something' }
            }
            
            // add the `onunload` handler if there's no any - attempting to prevent browser from caching the iframe
            // trying to create the handler from inside of the scope
            this.runCode(';(' + onUnloadChecker.toString() + ')();')

            this.iframe     = null
            this.scope      = null
            this.wrapper    = null

            if (me.beforeCleanupCallback) me.beforeCleanupCallback()
            me.beforeCleanupCallback    = null
            
            // chaging the page, triggering `onunload` and hopefully preventing browser from caching the content of iframe
            iframe.src      = 'javascript:false'
            
            // wait again before removing iframe from the DOM, as recommended by some online sources
            setTimeout(function () {
                ;(me.parentEl || me.parentWindow.document.body).removeChild(wrapper)
                
                wrapper     = null
                iframe      = null
                
                me.parentEl = null
                
                me.cleanupHanlders()
                
                if (me.cleanupCallback) me.cleanupCallback()
                me.cleanupCallback  = null
                
            }, me.cleanupDelay)
        }
    }
})

/**

Name
====

Scope.Provider.IFrame - scope provider, which uses the iframe.


SYNOPSIS
========

        var provider = new Scope.Provider.IFrame()
        
        provider.setup(function () {
        
            if (provider.scope.SOME_GLOBAL == 'some_value') {
                ...
            }
            
            provider.runCode(text, callback)
            
            ...
            
            provider.runScript(url, callback)
            
            ...
            
            provider.cleanup()        
        })


DESCRIPTION
===========

`Scope.Provider.IFrame` is an implementation of the scope provider, which uses the iframe, 
to create a new scope.


ISA
===

[Scope.Provider](../Provider.html)


DOES
====

[Scope.Provider.Role.WithDOM](Role/WithDOM.html)



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)
 
Or the mailing list: <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
Class('Scope.Provider.Window', {
    
    isa     : Scope.Provider,

    does    : Scope.Provider.Role.WithDOM,
    
    
    has     : {
        popupWindow     : null
    },
    

    methods : {
        
        setViewportSize : function (width, height) {
            var popupWindow     = this.popupWindow
            
            if (!popupWindow) return
            
            // is not guaranteed to work
            popupWindow.resizeTo(width, height)
        },
        
        
        create : function (onLoadCallback) {
            var minViewportSize     = this.minViewportSize
            
            var width       = minViewportSize && minViewportSize.width || 1024
            var height      = minViewportSize && minViewportSize.height || 768
            
            var popup       = this.scope = this.popupWindow = this.parentWindow.open(
                // left/top is set to > 0 value with intent to keep the mouse cursor outside of the popup
                // its always recommened to set the mousecursor position to 0, 0 in the automation script
                this.sourceURL || 'about:blank', 
                '_blank', 
                "left=10,top=10,width=" + width + ",height=" + height
            )
            
            if (!popup) {
                alert('Please enable popups for the host with this test suite running: ' + this.parentWindow.location.host)
                throw 'Please enable popups for the host with this test suite running: ' + this.parentWindow.location.host
            }
            
            var isIE = 'v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)
            
            // dances with tambourine around the IE
            if (isIE && !this.sourceURL) {
                var doc = this.getDocument()
                
                doc.open()
                doc.write('')
                doc.close()
            }
            
            // trying to add the "early" onerror handler - will probably only work in FF
            if (this.cachedOnError) this.installOnErrorHandler(this.cachedOnError)
            
            /*!
             * contentloaded.js
             *
             * Author: Diego Perini (diego.perini at gmail.com)
             * Summary: cross-browser wrapper for DOMContentLoaded
             * Updated: 20101020
             * License: MIT
             * Version: 1.2
             *
             * URL:
             * http://javascript.nwbox.com/ContentLoaded/
             * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
             *
             */
            
            // @win window reference
            // @fn function reference
            var contentLoaded = function (win, fn) {
            
                var done = false, top = true,
            
                doc = win.document, root = doc.documentElement,
            
                add = doc.addEventListener ? 'addEventListener' : 'attachEvent',
                rem = doc.addEventListener ? 'removeEventListener' : 'detachEvent',
                pre = doc.addEventListener ? '' : 'on',
            
                init = function(e) {
                    if (e.type == 'readystatechange' && doc.readyState != 'complete') return;
                    
                    (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false);
                    
                    if (!done && (done = true)) fn.call(win, e.type || e);
                },
            
                poll = function() {
                    try { root.doScroll('left'); } catch(e) { setTimeout(poll, 50); return; }
                    
                    init('poll');
                };
                
                if (doc.readyState == 'complete') 
                    fn.call(win, 'lazy');
                else {
                    if (doc.createEventObject && root.doScroll) {
                        try { top = !win.frameElement; } catch(e) { }
                        if (top) poll();
                    }
                    doc[add](pre + 'DOMContentLoaded', init, false);
                    doc[add](pre + 'readystatechange', init, false);
                    win[add](pre + 'load', init, false);
                }
            }
            
            if (this.sourceURL)
                // seems the "doc.readyState" is set before the DOM is created on the page
                // if one will start interact with page immediately he can overwrite the page content
                setTimeout(function () {
                    contentLoaded(popup, onLoadCallback || function () {})    
                }, 10)
            else
                contentLoaded(popup, onLoadCallback || function () {})
        },
        
        
        getDocument : function () {
            return this.popupWindow.document
        },
        
        
        cleanup : function () {
            if (this.beforeCleanupCallback) this.beforeCleanupCallback()
            this.beforeCleanupCallback      = null
            
            this.popupWindow.close()
            
            this.popupWindow = null
            
            this.cleanupHanlders()
            
            if (this.cleanupCallback) this.cleanupCallback()
            this.cleanupCallback            = null
        }
    }
})

/**

Name
====

Scope.Provider.Window - scope provider, which uses the popup browser window.


SYNOPSIS
========

        var provider = new Scope.Provider.Window()
        
        provider.setup(function () {
        
            if (provider.scope.SOME_GLOBAL == 'some_value') {
                ...
            }
            
            provider.runCode(text, callback)
            
            ...
            
            provider.runScript(url, callback)
            
            ...
            
            provider.cleanup()        
        })


DESCRIPTION
===========

`Scope.Provider.Window` is an implementation of the scope provider, which uses the popup browser window, 
to create a new scope.


ISA
===

[Scope.Provider](../Provider.html)


DOES
====

[Scope.Provider.Role.WithDOM](Role/WithDOM.html)



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)
 
Or the mailing list: <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
Class('Scope.Provider.NodeJS', {
    
    isa     : Scope.Provider,

    
    has     : {
        sourceURL       : null
    },
    

    methods : {
        
        compile : function (module, content, filename) {
            var Module    = require('module')
            var path      = require('path')
            
            var self      = module;
            // remove shebang
            content       = content.replace(/^\#\!.*/, '');
        
            var modRequire     = function (path) {
                return self.require(path);
            }
        
            modRequire.resolve = function(request) {
                return Module._resolveFilename(request, self)[1];
            };
        
            Object.defineProperty(modRequire, 'paths', { get: function() {
                throw new Error('modRequire.paths is removed. Use ' +
                            'node_modules folders, or the NODE_PATH '+
                            'environment variable instead.');
            }});
        
            modRequire.main = process.mainModule;
        
            // Enable support to add extra extension types
            modRequire.extensions = Module._extensions;
            modRequire.registerExtension = function() {
                throw new Error('modRequire.registerExtension() removed. Use ' +
                            'modRequire.extensions instead.');
            };
        
            modRequire.cache = Module._cache;
        
            var dirname = path.dirname(filename);
        
            // create wrapper function
            var wrapper = Module.wrap(content);
            
            var compiledWrapper = require('vm').runInContext(wrapper, this.scope, filename);
            
            return compiledWrapper.apply(self.exports, [self.exports, modRequire, self, filename, dirname]);
        },        
        
        
        addOnErrorHandler : function (handler, callback) {
        },

        
        create : function (callback) {
            var vm          = require('vm')
            var sandbox     = {}

            Joose.O.extend(sandbox, {
//                __PROVIDER__    : true,
                
                process         : process,
                
                global          : sandbox,
                root            : root,
                
                setTimeout      : setTimeout,
                clearTimeout    : clearTimeout,
                setInterval     : setInterval,
                clearInterval   : clearInterval
//                ,
//                
//                __filename      : __filename,
//                __dirname       : __dirname,
//                module          : module
            })
            
            var scope       = this.scope    = vm.createContext(sandbox)
            
            callback && callback()
        },
        
        
        setup : function (callback) {
            this.create()
            
            var me      = this
            
            if (this.seedingCode) require('vm').runInContext(this.seedingCode, this.scope)
            
            Joose.A.each(this.getPreload(), function (preloadDesc) {
                
                if (preloadDesc.type == 'js')
                    if (preloadDesc.url)
                        me.runScript(preloadDesc.url)
                    else
                        me.runCode(preloadDesc.content)
            })
            
            if (this.seedingScript) {
                var Module          = require('module')
                var path            = require('path')
                
                var module          = new Module('./' + this.sourceURL, require.main)
                
                var filename        = module.filename = path.join(path.dirname(require.main.filename), this.sourceURL)
                
                var content         = require('fs').readFileSync(filename, 'utf8')
                // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
                // because the buffer-to-string conversion in `fs.readFileSync()`
                // translates it to FEFF, the UTF-16 BOM.
                if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1)
  
                this.compile(module, content, filename)
            }
            
            callback && callback()
        },
        
        
        runCode : function (text, callback) {
            var res = require('vm').runInContext(text, this.scope)
            
            callback && callback(res)
            
            return res
        },
        
        
        runScript : function (url, callback) {
            var content = require('fs').readFileSync(url, 'utf8')
            
            var res = require('vm').runInContext(content, this.scope, url)
            
            callback && callback(res)
            
            return res
        },
        
        
        cleanup : function () {
            if (this.beforeCleanupCallback) this.beforeCleanupCallback()
            if (this.cleanupCallback) this.cleanupCallback()
        }
    }
})


/**

Name
====

Scope.Provider.NodeJS - scope provider, which uses the `Script.runInNewContext` call of the NodeJS.


SYNOPSIS
========

        var provider = new Scope.Provider.NodeJS()
        
        provider.setup(function () {
        
            if (provider.scope.SOME_GLOBAL == 'some_value') {
                ...
            }
            
            provider.runCode(text, callback)
            
            ...
            
            provider.runScript(url, callback)
            
            ...
            
            provider.cleanup()        
        })


DESCRIPTION
===========

`Scope.Provider.NodeJS` is an implementation of the scope provider, 
which uses the `Script.runInNewContext` call of the NodeJS platform.


ISA
===

[Scope.Provider](../Provider.html)



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)
 
Or the mailing list: <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
;
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
;
!function () {
    
    var REF      = 1    

    Class('Data.Visitor2', {
        
        has : {
            seenPlaceholder : {
                init        : {}
            },
            
            outOfDepthPlaceholder : {
                init        : {}
            },
            
            seen            : Joose.I.Object,
            
            maxDepth        : null
        },
            
        methods : {
            
            getClassNameFor : function (object) {
                if (Joose.O.isInstance(object))      return object.meta.name
                
                return Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/\]$/, '')
            },
            
            
            getRefAdr : function () {
                return REF++
            },
            
            
            assignRefAdrTo : function (object) {
                if (!object.__REFADR__) 
                    if (Object.defineProperty)
                        Object.defineProperty(object, '__REFADR__', { value : REF++ })
                    else
                        object.__REFADR__ = REF++
                
                return object.__REFADR__
            },
                
                
            isSeen : function (object) {
                return object.__REFADR__ && this.seen.hasOwnProperty(object.__REFADR__)
            },
            
            
            markSeenAs : function (object, result) {
                return this.seen[ object.__REFADR__ ] = result
            },
            
            
            hasSeenResultFor : function (object) {
                var ref = object.__REFADR__
                
                return this.seen.hasOwnProperty(ref) && this.seen[ ref ] != this.seenPlaceholder
            },
            
            
            visit : function (value, depth) {
                // will be false for NaN values
                if (depth > this.maxDepth)
                    return this.visitOutOfDepthValue(value, depth + 1)
                else
                    if (Object(value) === value)
                        if (this.isSeen(value)) 
                            return this.visitSeen(value, depth + 1)
                        else                        
                            return this.visitNotSeen(value, depth + 1)
                    else
                        return this.visitValue(value, depth + 1)
            },
            
            
            visitOutOfDepthValue : function (value, depth) {
                return this.outOfDepthPlaceholder
            },
            
            
            visitValue : function (value, depth) {
                return value
            },
            
            
            visitSeen : function (value, depth) {
                return this.seen[ value.__REFADR__ ]
            },
            
            
            getInitialSeenMarker : function (object, depth) {
                return this.seenPlaceholder
            },
            
            
            visitNotSeen : function (object, depth) {
                this.assignRefAdrTo(object)
                
                this.markSeenAs(object, this.getInitialSeenMarker(object, depth))
    
                
                if (Joose.O.isInstance(object)) return this.markSeenAs(object, this.visitJooseInstance(object, depth))
                
                
                var methodName = 'visit' + this.getClassNameFor(object)
                
                if (!this.meta.hasMethod(methodName)) methodName = 'visitObject' 
                
                return this.markSeenAs(object, this[ methodName ](object, depth))
            },
            
            
            visitArray  : function (array, depth) {
                Joose.A.each(array, function (value, index) {
                    
                    this.visitArrayEntry(value, index, array, depth)
                    
                }, this)
                
                return array
            },
            
            
            visitArrayEntry  : function (entry, index, array, depth) {
                return this.visit(entry, depth)
            },
            
            
            visitObject : function (object, depth) {
                
                Joose.O.eachOwn(object, function (value, key) {
                    
                    if (key != '__REFADR__') {
                        this.visitObjectKey(key, value, object, depth)
                        this.visitObjectValue(value, key, object, depth)
                    }
                    
                }, this)
                
                return object
            },
            
            
            visitJooseInstance : function (value, depth) {
                return this.visitObject(value, depth)
            },
            
            
            visitObjectKey : function (key, value, object, depth) {
                return this.visitValue(key, depth)
            },
            
            
            visitObjectValue : function (value, key, object, depth) {
                return this.visit(value, depth)
            }
        },
        
        
        my : {
            
            has : {
                HOST        : null
            },
            
            
            methods : {
                
                visit : function (value, maxDepth) {
                    var visitor     = new this.HOST({
                        maxDepth        : maxDepth || Infinity
                    })
                    
                    return visitor.visit(value, 0)
                }
            }
        }
    })    
    
}()


;
;
;
Class('Siesta.Util.Serializer', {
    
    isa : Data.Visitor2,
    
    has     : {
        result                  : Joose.I.Array,
        manualEnum              : function () {
            for (var i in { toString : 1 }) return false
            
            return true
        }
    },
    
    
    methods : {
        
        assignRefAdrTo : function (object) {
            try {
                return this.SUPER(object)
            } catch (e) {
                if (!object.__REFADR__) object.__REFADR__ = this.getRefAdr()
            }
            
            return object.__REFADR__
        },
        
        
        write : function (str) {
            this.result.push(str)
        },
        
        
        visitOutOfDepthValue : function (value, depth) {
            this.write('...')
        },
        
        
        visitValue : function (value) {
            if (value == null)
                // `null` and `undefined`
                this.write(value + '')
            else
                this.write(typeof value == 'string' ? '"' + value.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"' : value + '')
        },
        
        
        visitObjectKey : function (key, value, object) {
            this.write('"' + key + '": ')
        },
        
        
        getClassNameFor : function (object) {
            if (object.nodeType != null && object.nodeName != null && object.tagName) return 'DOMElement'
            
            // trying to detect and not dive into global window
            if (object.document != null && object.location != null && object.location.href != null) return 'Window'
            
            return this.SUPER(object)
        },
        
        
        visitSeen : function (value, depth) {
            this.write('[Circular]')
        },
        
        
        visitRegExp : function (value, depth) {
            this.write(value + '')
        },
        
        
        visitFunction : function (value, depth) {
            this.write('function ' + (value.name || '') + '() { ... }')
        },
        
        
        visitDate : function (value, depth) {
            this.write('"' + value + '"')
        },
        

        // safer alternative to parent's implementation of `visitObject` - some host objects has no "hasOwnProperty" method
        visitObject : function (object, depth) {
            for (var key in object) {
                if (key != '__REFADR__' && (!object.hasOwnProperty || object.hasOwnProperty(key))) {
                    var value   = object[ key ]
                    
                    this.visitObjectKey(key, value, object, depth)
                    this.visitObjectValue(value, key, object, depth)
                }
            }

            var me  = this
            
            if (this.manualEnum) 
                Joose.A.each([ 'hasOwnProperty', 'valueOf', 'toString', 'constructor' ], function (key) {
                    if (object.hasOwnProperty && object.hasOwnProperty(key)) {
                        var value   = object[ key ]
                        
                        me.visitObjectKey(key, value, object, depth)
                        me.visitObjectValue(value, key, object, depth)
                    }
                })
            
            return object
        },
        
        
        visitJooseInstance : function (value, depth) {
            if (value.meta.hasMethod('toString')) {
                this.write(value.toString())
                
                return value
            }
            
            return this.SUPERARG(arguments)
        },
        
        
        visitDOMElement : function (object, depth) {
            var output  = '&lt;' + object.tagName
            
            if (object.id) output += ' id="' + object.id + '"'
            if (object.className) output += ' class="' + object.className + '"'
            
            this.write(output + '&gt;')
        },
        
        
        visitDOMStringMap : function () {
            this.write('[DOMStringMap]')
        },
        
        
        // the Object.prototype.toString.call(window) for FF
        visitWindow : function () {
            this.write('[window]')
        },
        
        
        // window.location type in FF
        visitLocation : function () {
            this.write('[window.location]')
        }
    },
    
    
    before : {
        visitObject : function () {
            this.write('{')
        },
        
        
        visitArray : function () {
            this.write('[')
        }
    },
    
    
    after : {
        visitObject : function () {
            var result = this.result
            
            if (result[ result.length - 1 ] == ', ') result.pop()
            
            this.write('}')
        },
        
        
        visitArray : function () {
            var result = this.result
            
            if (result[ result.length - 1 ] == ', ') result.pop()
            
            this.write(']')
        },
        
        
        visitObjectValue : function () {
            this.write(', ')
        },
        
        
        visitArrayEntry : function () {
            this.write(', ')
        }
    },
    
    
    my : {
        
        has : {
            HOST        : null
        },
        
        
        methods : {
            
            stringify : function (value, maxDepth) {
                try {
                    if (value.foobar) visitor = null
                } catch (e) {
                    if (value) return 'Value from cross-domain context'
                }
                
                var visitor     = new this.HOST({
                    maxDepth        : maxDepth || 4
                })
                
                visitor.visit(value, 0)
                
                return visitor.result.join('')
            }
        }
    }
})
;
Role('Siesta.Util.Role.CanFormatStrings', {
    
    has     : {
        serializeFormatingPlaceholders      : true
    },
    
    methods : {
        
        formatString: function (string, data) {
            if (!data) return string
            
            var match
            var variables           = []
            var isRaw               = []
            var regexp              = /\{(\!)?((?:\w|-|_)+?)\}/g
            
            while (match = regexp.exec(string)) {
                isRaw.push(match[ 1 ])
                variables.push(match[ 2 ])
            }
            
            var result              = string
            
            Joose.A.each(variables, function (variable, index) {
                var varIsRaw        = isRaw[ index ]
                
                result              = result.replace(
                    new RegExp('\\{' + (varIsRaw ? '!' : '') + variable + '\\}', 'g'), 
                    data.hasOwnProperty(variable) ? 
                        varIsRaw || !this.serializeFormatingPlaceholders ? data[ variable ] + '' : Siesta.Util.Serializer.stringify(data[ variable ]) 
                    : 
                        ''
                )
            }, this)
            
            return result
        }
    }
})
;
Role('Siesta.Util.Role.CanGetType', {
    
    methods : {
        
        /**
         * This method returns a result of `Object.prototype.toString` applied to the passed argument. The `[object` and trailing `]` are trimmed.
         *
         * @param {Mixed} object
         * @return {String} The name of the "type" for this object.
         */
        typeOf : function (object) {
            return Object.prototype.toString.call(object).slice(8, -1)
        }
    }
})
;
/**
@class Siesta.Util.Role.CanCompareObjects

A mixin, providing the "compareObjects" method. 

*/
Role('Siesta.Util.Role.CanCompareObjects', {
    
    does    : [
        Siesta.Util.Role.CanGetType
    ],
    
    methods : {
        
        countKeys : function (object) {
            var counter = 0

            Joose.O.eachOwn(object, function () {
                counter++
            })

            return counter
        },


        /**
         * This method performs a deep comparison of the passed JSON objects. Objects must not contain cyclic references.
         * You can use this method in your own assertions.
         *
         * @param {Mixed} obj1 The 1st object to compare
         * @param {Mixed} obj2 The 2nd object to compare
         * @param {Boolean} strict When passed the `true` value, the comparison of the primitive values will be performed with the
         * `===` operator (so [ 1 ] and [ "1" ] object will be different). Additionally, when this flag is set to `true`, then
         * when comparing Function, RegExp and Date instances, additional check that objects contains the same set of own properties ("hasOwnProperty")
         * will be performed.
         * @param {Boolean} onlyPrimitives When set to `true`, the function will not recurse into composite objects (like [] or {}) and will just report that
         * objects are different. Use this mode when you are only interested in comparison of primitive values (numbers, strings, etc).
         * @param {Boolean} asObjects When set to `true`, the function will compare various special Object instances, like Functions, RegExp etc,
         * by comparison of their properties only and not taking the anything else into account.
         * @return {Boolean} `true` if the passed objects are equal
         */
        compareObjects : function (obj1, obj2, strict, onlyPrimitives, asObjects) {
            var obj1IsPlaceholder       = Joose.O.isInstance(obj1) && obj1.meta.does(Siesta.Test.Role.Placeholder)
            var obj2IsPlaceholder       = Joose.O.isInstance(obj2) && obj2.meta.does(Siesta.Test.Role.Placeholder)

            if (strict) {
                if (obj1 === obj2) return true
            } else
                if (obj1 == obj2) return true

            if (obj1IsPlaceholder && obj2IsPlaceholder)
                return obj1.equalsTo(obj2)
            else if (obj2IsPlaceholder)
                return obj2.equalsTo(obj1)
            else if (obj1IsPlaceholder)
                return obj1.equalsTo(obj2)

            if (onlyPrimitives) return false

            var type1 = this.typeOf(obj1)
            var type2 = this.typeOf(obj2)

            if (type1 != type2) return false

            var me = this

            if (type1 == 'Object' || asObjects)
                if (this.countKeys(obj1) != this.countKeys(obj2))
                    return false
                else {
                    var res = Joose.O.eachOwn(obj1, function (value, name) {

                        if (!me.compareObjects(value, obj2[ name ], strict)) return false
                    })

                    return res === false ? false : true
                }

            if (type1 == 'Array')
                if (obj1.length != obj2.length)
                    return false
                else {
                    for (var i = 0; i < obj1.length; i++)
                        if (!this.compareObjects(obj1[ i ], obj2[ i ], strict)) return false

                    return true
                }

            if (type1 == 'Function')
                return obj1.toString() == obj2.toString() && (!strict || this.compareObjects(obj1, obj2, strict, false, true))

            if (type1 == 'RegExp')
                return obj1.source == obj2.source && obj1.global == obj2.global && obj1.ignoreCase == obj2.ignoreCase
                    && obj1.multiline == obj2.multiline && (!strict || this.compareObjects(obj1, obj2, strict, false, true))

            if (type1 == 'Date') return !Boolean(obj1 - obj2) && (!strict || this.compareObjects(obj1, obj2, strict, false, true))

            return false
        }
    }
})
;
Role('Siesta.Util.Role.CanEscapeRegExp', {
    
    methods : {
        
        escapeRegExp : function (str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
        }
    }
})
;
!function () {
/* header */
    
var id      = 1

Role('Siesta.Util.Role.HasUniqueGeneratedId', {
    
    has : {
        id                      : {
            is      : 'ro',
            init    : function () { return id++ }
        }
    }
})

/* footer */
}();
Class('Siesta.Util.Queue', {
    
    has     : {
        // array of Objects, each containing arbitrary data about queue step. Possibly keys:
        // `processor` - an individual processor function for this step
        // can also be provided for whole queue
        // will receive the: (stepData, index, queue)
        // `isAsync` - when provided, the `next` function will be also embedded,
        // which should be called manually
        // `interval` - the delay after step (except for asynchronous)
        steps                   : Joose.I.Array,

        interval                : 100,
        callbackDelay           : 0,
        // setTimeout
        deferer                 : { required : true },
        // clearTimeout - only required when "abort" is planned / possible
        deferClearer            : null,
        
        processor               : null,
        processorScope          : null,
        
        currentTimeout          : null,
        callback                : null,
        scope                   : null,
        isAborted               : false,
        
        observeTest             : null,

        currentDelayStepId      : null,
        
        isDestroyed             : false
    },
    
    
    methods : {
        
        // step is an object with
        // { 
        //      processor : func, 
        //      processorScope : obj,
        //      next : func (in case of async step, will be populated by queue)
        // }
        
        addStep : function (stepData) {
            this.addSyncStep(stepData)
        },
        
        
        addSyncStep : function (stepData) {
            this.steps.push(stepData)
        },
        
        
        addAsyncStep : function (stepData) {
            stepData.isAsync = true
            
            this.steps.push(stepData)
        },

        addDelayStep : function (delayMs) {
            var origSetTimeout = this.deferer;
            var me = this;

            this.addAsyncStep({
                processor : function(data) {
                    me.currentDelayStepId = origSetTimeout(data.next, delayMs || 500);
                }
            });
        },
        
        
        run : function (callback, scope) {
            this.callback   = callback
            this.scope      = scope
            
            // abort the queue, if the provided test instance has finalized (probably because of exception)
            this.observeTest && this.observeTest.on('testfinalize', function () { this.abort(true) }, this, { single : true })
            
            this.doSteps(this.steps.slice(), callback, scope)
        },
        
        
        abort : function (ignoreCallback) {
            if (this.isDestroyed) return
            
            this.isAborted      = true
            
            var deferClearer    = this.deferClearer
            
            if (!deferClearer) throw "Need `deferClearer` to be able to `abort` the queue"

            deferClearer(this.currentDelayStepId);
            deferClearer(this.currentTimeout)
            
            if (!ignoreCallback) this.callback.call(this.scope || this)
            
            this.destroy()
        },
        
        
        doSteps : function (steps, callback, scope) {
            this.currentTimeout = null
            
            var me          = this
            var deferer     = this.deferer
            var step        = steps.shift()
            
            if (this.isAborted) return
            
            if (step) {
                // Normally, the `doSteps` is called recursively for every step in the chain
                // but, steps may complete synchronously, which means, stack will grow
                // since some version, FF has smaller stack size than other browsers
                // and it starts behaving unstable when stack grows
                // because of that, we perform a special check if step has completed synchronously
                // and processing the next step in the same `doStep` context (in the loop), avoiding recursion
                
                // if `doOneStep` has returned `true`, then step has completed synchronously
                // and the flow did not recurse into `doSteps`
                // in this case we continue processing to the next step
                while (this.doOneStep(step, steps, callback, scope) && !this.isAborted) {
                    if (steps.length)
                        step = steps.shift()
                    else {
                        this.doSteps(steps, callback, scope)
                        break;
                    }
                }
            } else {
                if (callback)
                    if (this.callbackDelay)
                        deferer(function () {
                            if (!me.isAborted) { callback.call(scope || this); me.destroy() }
                        }, this.callbackDelay)
                    else {
                        callback.call(scope || this)
                        me.destroy()
                    }
            }
        },
        
        
        doOneStep : function (step, steps, callback, scope) {
            var me              = this
            var deferer         = this.deferer
            
            var processor       = step.processor || this.processor
            var processorScope  = step.processorScope || this.processorScope
            
            var index           = this.steps.length - steps.length - 1
            
            if (!processor) throw new Error("No process function found for step: " + index)
            
            if (step.isAsync) {
                var stepHasCompletedSynchronously   = false
                var processorHasCompleted           = false
                
                var next = step.next = function () {
                    // if at this point `processorHasCompleted` is still `false`, that means that "next" function
                    // has been called before the `processor` function has returned, and thus, step has completed 
                    // synchronously
                    // see the comment in `doSteps` why we treat this case differently
                    if (!processorHasCompleted)
                        stepHasCompletedSynchronously   = true
                    else
                        me.doSteps(steps, callback, scope)
                }
                
                // processor should call `next` to continue
                processor.call(processorScope || me, step, index, this, next)
                
                processorHasCompleted               = true
                
                if (stepHasCompletedSynchronously) return true
            } else {
                processor.call(processorScope || me, step, index, this)
                
                if (this.isAborted) return
                
                var interval = step.interval || me.interval
                
                if (interval) 
                    this.currentTimeout = deferer(function () {
                        me.doSteps(steps, callback, scope)    
                    }, interval)
                else
                    me.doSteps(steps, callback, scope)
            }
        },
        
        
        // help garbage collector to release the memory 
        destroy : function () {
            if (this.isDestroyed) return
            
            this.callback   = this.observeTest      = this.deferer = this.deferClearer = null
            this.processor  = this.processorScope   = null
            
            // cleanup paranoya, this shouldn't matter in general, since "next" here is from the same context
            for (var i = 0; i < this.steps.length; i++) this.steps[ i ].next = null
            this.steps          = null
            
            this.isDestroyed    = true
        }
    }
})
;
Class('Siesta.Util.XMLNode', {
    
    has     : {
        children        : Joose.I.Array,
        
        tag             : { required : true },
        attributes      : Joose.I.Object,
        
        textContent     : null,
        
        escapeTable     : {
            
            init    : {
                '&'     : '&amp;', 
                '<'     : '&lt;', 
                '>'     : '&gt;', 
                '"'     : '&quot;'
            }
        }
        
    },
    
    
    methods : {
        
        escapeXml : function (s) {
            var me = this
            
            return typeof s != 'string' ? s : s.replace(/[&<>"]/g, function (match) {
                return me.escapeTable[ match ]
            })
        },
        
        
        toString : function () {
            var me                  = this
            var childrenContent     = []
            
            Joose.A.each(this.children, function (child) {
                childrenContent.push(child.toString())
            })
            
            var attributesContent       = []
            
            Joose.O.each(this.attributes, function (value, name) {
                attributesContent.push(name + '="' + me.escapeXml(value) + '"')
            })
            
            // to have predictable order of attributes in tests
            attributesContent.sort()
            
            attributesContent.unshift(this.tag)
            
            
            return '<' + attributesContent.join(' ') + '>' + (this.textContent != null ? this.escapeXml(this.textContent) : '') + childrenContent.join('') + '</' + this.tag + '>' 
        },
        
        
        appendChild : function (child) {
            if (child instanceof Siesta.Util.XMLNode)
                child.parent    = this
            else
                child           = new Siesta.Util.XMLNode(Joose.O.extend(child, { parent : this }))
                
            this.children.push(child)
            
            return child
        },
        
        
        setAttribute : function (name, value) {
            this.attributes[ name ] = value
        }
    }
})
;
Class('Siesta.Util.Rect', {
    
    has     : {
        left            : null,
        top             : null,
        width           : null,
        height          : null,
        
        right           : null,
        bottom          : null
    },
    
    
    methods : {
        
        initialize : function () {
            var left        = this.left
            var width       = this.width
            var right       = this.right
            
            if (right == null && left != null && width != null) this.right = left + width - 1
            
            if (width == null && left != null && right != null) this.width = right - left + 1
            
            var top         = this.top
            var height      = this.height
            var bottom      = this.bottom
            
            if (bottom == null && top != null && height != null) this.bottom = top + height - 1
            
            if (height == null && top != null && bottom != null) this.height = bottom - top + 1
        },
        
        
        isEmpty : function () {
            return this.left == null
        },
        
        
        intersect : function (rect) {
            if (
                rect.isEmpty() || this.isEmpty()
                    ||
                rect.left > this.right || rect.right < this.left
                    ||
                rect.top > this.bottom || rect.bottom < this.top
            ) return this.my.getEmpty()
            
            return new this.constructor({
                left        : Math.max(this.left, rect.left),
                right       : Math.min(this.right, rect.right),
                top         : Math.max(this.top, rect.top),
                bottom      : Math.min(this.bottom, rect.bottom)
            })
        },
        
        
        contains : function (left, top) {
            return this.left <= left && left <= this.right 
                    && 
                this.top <= top && top <= this.bottom
        },
        
        
        cropLeftRight : function (rect) {
            return this.intersect(new this.constructor({
                left        : rect.left,
                right       : rect.right,
                top         : this.top,
                bottom      : this.bottom
            }))
        },
        
        
        cropTopBottom : function (rect) {
            return this.intersect(new this.constructor({
                left        : this.left,
                right       : this.right,
                top         : rect.top,
                bottom      : rect.bottom
            }))
        },
        
        
        equalsTo : function (rect) {
            return this.left == rect.left && this.right == rect.right && this.top == rect.top && this.bottom == rect.bottom
        }
    },
    
    
    // static methods/props
    my : {
        has : {
            HOST        : null
        }, 
        
        methods : {
            
            getEmpty : function () {
                return new this.HOST()
            }
        }
    }
})
;
Class('Siesta.Content.Resource', {
    
    has : {
        url             : null,
        
        content         : null
    },
    
    
    methods : {
        
        asHTML : function () {
            throw "Abstract method called"
        },
        
        
        asDescriptor : function () {
            throw "Abstract method called"
        },
        
        
        // todo should check same-origin 
        canCache : function () {
        }
        
    }
        
})
//eof Siesta.Result

;
Class('Siesta.Content.Resource.CSS', {
    
    isa     : Siesta.Content.Resource,
    
    has     : {
    },
    
    
    methods : {
        
        asHTML : function () {
        },
        
        
        asDescriptor : function () {
            var res = {
                type        : 'css'
            }
            
            if (this.url)       res.url         = this.url
            if (this.content)   res.content     = this.content
            
            return res
        }
    }
        
})
//eof Siesta.Result

;
Class('Siesta.Content.Resource.JavaScript', {
    
    isa     : Siesta.Content.Resource,
    
    has     : {
        instrument          : false
    },
    
    
    methods : {
        
        asHTML : function () {
        },
        
        
        asDescriptor : function () {
            var res = {
                type        : 'js'
            }
            
            if (this.url)       res.url         = this.url
            if (this.content)   res.content     = this.content
            
            return res
        }
    }
        
})
//eof Siesta.Result

;
Class('Siesta.Content.Preset', {
    
    has : {
        preload                 : Joose.I.Array,
        
        resources               : Joose.I.Array
    },
    
    
    methods : {
        
        initialize : function () {
            var me              = this
            
            Joose.A.each(this.preload, function (preloadDesc) {
                
                me.addResource(preloadDesc)
            })
        },
        
        
        isCSS : function (url) {
            return /\.css(\?.*)?$/i.test(url)
        },
        
        
        getResourceFromDescriptor : function (desc) {
            var constructor, config
            
            var CSS
            
            if (typeof desc == 'string') {
                constructor     = this.isCSS(desc) ? Siesta.Content.Resource.CSS : Siesta.Content.Resource.JavaScript
                
                config          = { url     : desc }
            } else if (desc.text) {
                constructor     = Siesta.Content.Resource.JavaScript
                config          = { content : desc.text }
                
            } else {
                if (!desc.url && !desc.content) throw "Incorrect preload descriptor:" + desc
                
                constructor     = desc.type && desc.type == 'css' || this.isCSS(desc.url) ? Siesta.Content.Resource.CSS : Siesta.Content.Resource.JavaScript
                
                config          = {}
                
                if (desc.url)           config.url          = desc.url
                if (desc.content)       config.content      = desc.content
                if (desc.instrument)    config.instrument   = desc.instrument
            }
            
            return new constructor(config)
        },
        
        
        addResource : function (desc) {
            var resource    = (desc instanceof Siesta.Content.Resource) && desc || this.getResourceFromDescriptor(desc)
            
            this.resources.push(resource)
            
            return resource
        },
        
        
        eachResource : function (func, scope) {
            return Joose.A.each(this.resources, func, scope || this)
        },
        
        
        // deprecated - seems preset doesn't need to know about scope providers
        prepareScope : function (scopeProvider, contentManager) {
            
            this.eachResource(function (resource) {
                
                if (contentManager.hasContentOf(resource))
                    scopeProvider.addPreload({
                        type        : (resource instanceof Siesta.Content.Resource.CSS) ? 'css' : 'js', 
                        content     : contentManager.getContentOf(resource)
                    })
                else 
                    scopeProvider.addPreload(resource.asDescriptor())
            })
        }
    }
        
})

;
Class('Siesta.Content.Manager', {
    
    has : {
        disabled        : false,
        
        presets         : {
            required    : true
        },
        
        urls            : Joose.I.Object,
        
        maxLoads        : 5,
        
        harness         : null
    },
    
    
    methods : {
        
        cache : function (callback, errback, ignoreErrors) {
            if (this.disabled) {
                callback && callback()
                
                return
            }
            
            var urls    = this.urls
            var me      = this
            
            Joose.A.each(this.presets, function (preset) {
                preset.eachResource(function (resource) {
                    if (resource.url) urls[ resource.url ] = null
                })
            })
            
            var loadCount   = 0
            var errorCount  = 0
            
            var urlsArray   = []
            
            Joose.O.each(urls, function (value, url) {
                // if some content has been already provided - skip it from caching
                if (!me.hasContentOf(url)) urlsArray.push(url) 
            })
            
            var total       = urlsArray.length
            
            if (total) {
                
                var loadSingle = function () {
                    if (!urlsArray.length) return
                    
                    var url     = urlsArray.shift()
                    
                    me.load(url, function (content) {
                        if (errorCount) return
                        
                        urls[ url ] = content
                        
                        if (++loadCount == total) 
                            callback && callback()
                        else
                            loadSingle()
                    
                    }, ignoreErrors ? function () {
                        
                        if (++loadCount == total) 
                            callback && callback()
                        else
                            loadSingle()
                        
                    } : function () {
                        errorCount++
                        
                        errback && errback(url)
                    })
                }
                
                // running only `maxLoads` "loading threads" at the same time
                for (var i = 0; i < this.maxLoads; i++) loadSingle()
                
            } else
                callback && callback()
        },
        
        
        load : function (url, callback, errback) {
            throw "abstract method `load` called"
        },
        
        
        addContent : function (url, content) {
            this.urls[ url ]    = content
        },
        
        
        hasContentOf : function (url) {
            if (url instanceof Siesta.Content.Resource) url = url.url
            
            return typeof this.urls[ url ] == 'string'
        },
        
        
        getContentOf : function (url) {
            if (url instanceof Siesta.Content.Resource) url = url.url
            
            return this.urls[ url ]
        }
    }
})

;
;
Class('Siesta', {
    /*PKGVERSION*/VERSION : '4.0.6',

    // "my" should been named "static"
    my : {
        
        has : {
            config          : null,
            activeHarness   : null
        },
        
        methods : {
        
            getConfigForTestScript : function (text) {
                try {
                    eval(text)
                    
                    return this.config
                } catch (e) {
                    return null
                }
            },
            
            
            StartTest : function (arg1, arg2) {
                if (typeof arg1 == 'object') 
                    this.config = arg1
                else if (typeof arg2 == 'object')
                    this.config = arg2
                else
                    this.config = null
            }
        }
    }
})

// fake StartTest function to extract test configs
if (typeof StartTest == 'undefined') StartTest = Siesta.StartTest
if (typeof startTest == 'undefined') startTest = Siesta.StartTest
if (typeof describe == 'undefined') describe = Siesta.StartTest

// from MDN
// this polyfill is required by Ext, since Ext adds it to own context and after that assumes every function
// used as a callback has "bind" method
if (!Function.prototype.bind) {
    Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }

        var aArgs       = Array.prototype.slice.call(arguments, 1),
            fToBind     = this,
            fNOP        = function () {},
            fBound      = function () {
                return fToBind.apply(
                    this instanceof fNOP ? this : oThis,
                    aArgs.concat(Array.prototype.slice.call(arguments))
                );
            };

        fNOP.prototype      = this.prototype;
        fBound.prototype    = new fNOP();

        return fBound;
    };
};
Siesta.CurrentLocale = Siesta.CurrentLocale || {

    "Siesta.Harness" : {
        preloadHasFailed            : 'Preload of {url} has failed',
        preloadHasFailedForTest     : 'Preload of {url} has failed for test {test}',
        staticDeprecationWarning    : 'You are calling static method `{methodName}` of the harness class {harnessClass}. Such usage is deprecated now, please switch to creation of the harness class instance: `var harness = new {harnessClass}()`',
        resourceFailedToLoad        : 'Loading of a {nodeName} resource failed'
    },
    
    "Siesta.Harness.Browser.UI.AboutWindow" : {

        upgradeText : 'Upgrade to Siesta Standard',
        closeText   : 'Close',
        titleText   : 'ABOUT SIESTA (v. {VERSION})',

        bodyText    : '<img height="35" src="http://www.bryntum.com/bryntum-logo.png"/>\
             <p>Siesta is a JavaScript unit and functional test tool made by <a target="_blank" href="http://www.bryntum.com">Bryntum</a>. You can test any web page or JavaScript code, including Ext JS, jQuery or NodeJS. \
             Siesta comes in two versions: <strong>Lite</strong> and <strong>Standard</strong>. With Lite, you can launch your tests in the browser UI. \
             With the Standard version, you can also automate your tests and use the automation scripts together with tools like PhantomJS or Selenium WebDriver. </p>\
             Siesta would not be possible without these awesome products & libraries: <br>\
                     <ul style="padding:0 0 0 30px">\
                       <li><a href="http://sencha.com/extjs">Ext JS</a></li> \
                       <li><a href="http://jquery.com">jQuery</a></li> \
                       <li><a href="http://http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></li> \
                       <li><a href="http://joose.it/">Joose</a></li> \
                       <li><a href="https://github.com/gotwarlost/istanbul">Istanbul</a></li> \
                    </ul>'
    },

    "Siesta.Harness.Browser.UI.AssertionGrid" : {
        initializingText    : 'Initializing test...'
    },

    "Siesta.Harness.Browser.UI.CoverageReport" : {
        closeText               : 'Close',
        showText                : 'Show: ',
        lowText                 : 'Low',
        mediumText              : 'Med',
        highText                : 'High',
        statementsText          : 'Statements',
        branchesText            : 'Branches',
        functionsText           : 'Functions',
        linesText               : 'Lines',
        loadingText             : "Loading coverage data...",
        loadingErrorText        : 'Loading error',
        loadingErrorMessageText : 'Could not load the report data from this url: ',
        globalNamespaceText     : '[Global namespace]'
    },

    "Siesta.Harness.Browser.UI.DomContainer" : {
        title                   : 'DOM Panel',
        viewDocsText            : 'View documentation for ',
        docsUrlText             : 'http://docs.sencha.com/{0}/apidocs/#!/api/{1}'
    },

    "Siesta.Harness.Browser.UI.ResultPanel" : {
        rerunText               : 'Run test',
        toggleDomVisibleText    : 'Toggle DOM visible',
        viewSourceText          : 'View source',
        showFailedOnlyText      : 'Show failed only',
        componentInspectorText  : 'Toggle Ext Component Inspector',
        eventRecorderText       : 'Event Recorder',
        closeText               : 'Close'
    },

    "Siesta.Harness.Browser.UI.TestGrid" : {
        title                   : 'Test list',
        nameText                : 'Name',
        filterTestsText         : 'Filter tests',
        expandCollapseAllText   : 'Expand / Collapse all',
        runCheckedText          : 'Run checked',
        runFailedText           : 'Run failed',
        runAllText              : 'Run all',
        showCoverageReportText  : 'Show coverage report',
        passText                : 'Pass',
        failText                : 'Fail',
        optionsText             : 'Options...',
        todoPassedText          : 'todo assertion(s) passed',
        todoFailedText          : 'todo assertion(s) failed',
        viewDomText             : 'View DOM',
        transparentExText       : 'Transparent exceptions',
        cachePreloadsText       : 'Cache preloads',
        autoLaunchText          : 'Auto launch',
        speedRunText            : 'Speed run',
        breakOnFailText         : 'Break on fail',
        debuggerOnFailText      : 'Debugger on fail',
        aboutText               : 'About Siesta',
        documentationText       : 'Siesta Documentation',
        siestaDocsUrl           : 'http://bryntum.com/docs/siesta',
        filterFieldTooltip      : 'Supported formats for tests filtering:\n1) TERM1 TERM2 - both "TERM1" and "TERM2" should present in the test url\n' +
            '2) TERM1 TERM2 | TERM3 TERM4 | ... - both "TERM1" and "TERM2" should present in the test url, OR both TERM3 and TERM4, etc, can be ' +
            'repeated indefinitely\n' +
            '3) GROUP_TERM > TEST_TERM - filters only withing the specified `group`',
        landscape               : 'Landscape'
    },

    "Siesta.Harness.Browser.UI.VersionUpdateButton" : {

        newUpdateText           : 'New Update Available...',
        updateWindowTitleText   : 'New version available for download! Current version: ',
        cancelText              : 'Cancel',
        changelogLoadFailedText : 'Bummer! Failed to fetch changelog.',
        downloadText            : 'Download ',
        liteText                : ' (Lite)',
        standardText            : ' (Standard)',
        loadingChangelogText    : 'Loading changelog...'
    },

    "Siesta.Harness.Browser.UI.Viewport" : {
        apiLinkText       : 'API Documentation',
        apiLinkUrl        : 'http://bryntum.com/docs/siesta',
        uncheckOthersText : 'Uncheck others (and check this)',
        uncheckAllText    : 'Uncheck all',
        checkAllText      : 'Check all',
        runThisText       : 'Run this',
        expandAll           : 'Expand all',
        collapseAll         : 'Collapse all',
        filterToCurrentGroup    : 'Filter to current group',
        filterToFailed          : 'Filter to failed',
        httpWarningTitle  : 'You must use a web server',
        httpWarningDesc   : 'You must run Siesta in a web server context, and not using the file:/// protocol',
        viewSource        : 'View source'
    },


    "Siesta.Harness.Browser" : {
        codeCoverageWarningText : "Can not enable code coverage - did you forget to include the `siesta-coverage-all.js` on the harness page?",
        noJasmine               : "No `jasmine` object found on spec runner page",
        noJasmineSiestaReporter : "Can't find SiestaReporter in Jasmine. \nDid you add the `siesta/bin/jasmine-siesta-reporter.js` file to your spec runner page?"
    },

    "Siesta.Result.Assertion" : {
        todoText        : 'TODO: ',
        passText        : 'ok',
        failText        : 'fail'
    },

    "Siesta.Role.ConsoleReporter" : {
        passText            : 'PASS',
        failText            : 'FAIL',
        warnText            : 'WARN',
        errorText           : 'ERROR',
        missingFileText     : 'Test file [{URL}] not found.',
        allTestsPassedText  : 'All tests passed',
        failuresFoundText   : 'There are failures'
    },

    "Siesta.Test.Action.Drag" : {
        byOrToMissingText   : 'Either "to" or "by" configuration option is required for "drag" step',
        byAndToDefinedText  : 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
    },

    "Siesta.Test.Action.Eval" : {
        invalidMethodNameText : "Invalid method name: ",
        wrongFormatText       : "Wrong format of the action string: ",
        parseErrorText        : "Can't parse arguments: "
    },

    "Siesta.Test.Action.Wait" : {
        missingMethodText     : 'Could not find a waitFor method named '
    },

    "Siesta.Test.BDD.Expectation" : {
        expectText                  : 'Expect',
        needNotText                 : 'Need not',
        needText                    : 'Need',
        needMatchingText            : 'Need matching',
        needNotMatchingText         : 'Need not matching',
        needStringNotContainingText : 'Need string not containing',
        needStringContainingText    : 'Need string containing',
        needArrayNotContainingText  : 'Need array not containing',
        needArrayContainingText     : 'Need array containing',
        needGreaterEqualThanText    : 'Need value greater or equal than',
        needGreaterThanText         : 'Need value greater than',
        needLessThanText            : 'Need value less than',
        needLessEqualThanText       : 'Need value less or equal than',
        needValueNotCloseToText     : 'Need value not close to',
        needValueCloseToText        : 'Need value close to',
        toBeText                    : 'to be',
        toBeDefinedText             : 'to be defined',
        toBeUndefinedText           : 'to be undefined',
        toBeEqualToText             : 'to be equal to',
        toBeTruthyText              : 'to be truthy',
        toBeFalsyText               : 'to be falsy',
        toMatchText                 : 'to match',
        toContainText               : 'to contain',
        toBeLessThanText            : 'to be less than',
        toBeGreaterThanText         : 'to be greater than',
        toBeCloseToText             : 'to be close to',
        toThrowText                 : 'to throw exception',
        thresholdIsText             : 'Threshold is ',
        exactMatchText              : 'Exact match text',
        thrownExceptionText         : 'Thrown exception',
        noExceptionThrownText       : 'No exception thrown',
        wrongSpy                    : 'Incorrect spy instance',
        toHaveBeenCalledDescTpl     : 'Expect method {methodName} to have been called {need} times',
        actualNbrOfCalls            : 'Actual number of calls',
        expectedNbrOfCalls          : 'Expected number of calls',
        toHaveBeenCalledWithDescTpl : 'Expect method {methodName} to have been called at least once with the specified arguments'
    },

    "Siesta.Test.ExtJS.Ajax"        : {
        ajaxIsLoading               : 'An Ajax call is currently loading',
        allAjaxRequestsToComplete   : 'all ajax requests to complete',
        ajaxRequest                 : 'ajax request',
        toComplete                  : 'to complete'
    },

    "Siesta.Test.ExtJS.Component"   : {
        badInputText                : 'Expected an Ext.Component, got',
        toBeVisible                 : 'to be visible',
        toNotBeVisible              : 'to not be visible',
        component                   : 'component',
        Component                   : 'Component',
        componentQuery              : 'componentQuery',
        compositeQuery              : 'composite query',
        toReturnEmptyArray          : 'to return an empty array',
        toReturnEmpty               : 'to return empty',
        toReturnAVisibleComponent   : 'to return a visible component',
        toReturnHiddenCmp           : 'to return a hidden/missing component',
        invalidDestroysOkInput      : 'No components provided, or component query returned empty result',
        exception                   : 'Exception',
        exceptionAnnotation         : 'Exception thrown while calling "destroy" method of',
        destroyFailed               : 'was not destroyed (probably destroy was canceled in the `beforedestroy` listener)',
        destroyPassed               : 'All passed components were destroyed ok'
    },

    "Siesta.Test.ExtJS.DataView"    : {
        view                        : 'view',
        toRender                    : 'to render'
    },

    "Siesta.Test.ExtJS.Element"     : {
        top                         : 'top',
        left                        : 'left',
        bottom                      : 'bottom',
        right                       : 'right'
    },

    "Siesta.Test.ExtJS.Grid"     : {
        waitForRowsVisible          : 'rows to show for panel with id',
        waitForCellEmpty            : 'cell to be empty'
    },

    "Siesta.Test.ExtJS.Observable" : {
        hasListenerInvalid           : '1st argument for `t.hasListener` should be an observable instance',
        hasListenerPass              : 'Observable has listener for {eventName}',
        hasListenerFail              : 'Provided observable has no listeners for event',

        isFiredWithSignatureNotFired : 'event was not fired during the test"',
        observableFired              : 'Observable fired',
        correctSignature             : 'with correct signature',
        incorrectSignature           : 'with incorrect signature'
    },

    "Siesta.Test.ExtJS.Store"        : {
        storesToLoad                 : 'stores to load',
        failedToLoadStore            : 'Failed to load the store',
        URL                          : 'URL'
    },

    "Siesta.Test.Action"             : {
        missingTestAction            : 'Action [{0}] requires `{1}` method in your test class'
    },

    "Siesta.Test.BDD"                : {
        codeBodyMissing              : 'Code body is not provided for',
        codeBodyOf                   : 'Code body of',
        missingFirstArg              : 'does not declare a test instance as 1st argument',
        iitFound                     : 't.iit should only be used during debugging',
        noObject                     : 'No object to spy on'
    },

    "Siesta.Test.BDD.Spy"                : {
        spyingNotOnFunction          : 'Trying to create a spy over a non-function property'
    },
    
    "Siesta.Test.Browser"            : {
        popupsDisabled                  : 'Failed to open the popup for url: {url}. Enable the popups in the browser settings.',
        noDomElementFound            : 'No DOM element found for CSS selector',
        noActionTargetFound          : 'No action target found for',
        waitForEvent                 : 'observable to fire its',
        event                        : 'event',
        wrongFormat                  : 'Wrong format for expected number of events',
        unrecognizedSignature        : 'Unrecognized signature for `firesOk`',
        observableFired              : 'Observable fired',
        observableFiredOk            : 'Observable fired expected number of',
        actualNbrEvents              : 'Actual number of events',
        expectedNbrEvents            : 'Expected number of events',
        events                       : 'events',
        noElementFound               : 'Could not find any element at',
        targetElementOfAction        : 'Target element of action',
        targetElementOfSomeAction    : 'Target element of some action',
        isNotVisible                 : 'is not visible or not reachable',
        text                         : 'text',
        toBePresent                  : 'to be present',
        toNotBePresent               : 'to not be present',
        target                       : 'target',
        toAppear                     : 'to appear',
        targetMoved                  : 'Moving target detected, retargeting initiated',
        alertMethodNotCalled         : 'Expected a call to alert()',
        focusLostWarning             : 'Focus has left the test window {url}',
        focusLostWarningLauncher     : 'Focus has left the test window {url}, it will be restarted. This behavior is controled with the --restart-on-blur option.'
    },

    "Siesta.Test.Date"               :  {
        isEqualTo                    : 'is equal to',
        Got                          : 'Got'
    },

    "Siesta.Test.Element"            : {
        elementContent               : 'element content',
        toAppear                     : 'to appear',
        toDisappear                  : 'to disappear',
        toAppearAt                   : 'to appear at',
        monkeyException              : 'Monkey testing action did not complete properly - probably an exception was thrown',
        monkeyNoExceptions           : 'No exceptions thrown during monkey test',
        monkeyActionLog              : 'Monkey action log',
        elementHasClass              : 'Element has the CSS class',
        elementHasNoClass            : 'Element has no CSS class',
        elementClasses               : 'Classes of element',
        needClass                    : 'Need CSS class',

        hasStyleDescTpl              : 'Element has correct {value} for CSS style {property}',
        elementStyles                : 'Styles of element',
        needStyle                    : 'Need style',

        hasNotStyleDescTpl           : 'Element does not have: {value} for CSS style {property}',
        hasTheStyle                  : 'Element has the style',

        element                      : 'element',
        toBeTopEl                    : 'to be the top element at its position',
        toNotBeTopEl                 : 'to not be the top element at its position',

        selector                     : 'selector',
        selectors                    : 'selectors',
        noCssSelector                : 'A CSS selector must be supplied',

        waitForSelectorsBadInput     : 'An array of CSS selectors must be supplied',

        Position                     : 'Position',
        noElementAtPosition          : 'No element found at the specified position',
        elementIsAtDescTpl           : 'DOM element or its child is at [ {x}, {y} ] coordinates',
        topElement                   : 'Top element',
        elementIsAtPassTpl           : 'DOM element is at [ {x}, {y} ] coordinates',
        allowChildrenDesc            : 'Need exactly this or its child',
        allowChildrenAnnotation      : 'Passed element is not the top-most one and not the child of one',
        shouldBe                     : 'Should be',
        noChildrenFailAnnotation     : 'Passed element is not the top-most one',

        topLeft                      : '(t-l)',
        bottomLeft                   : '(b-l)',
        topRight                     : '(t-r)',
        bottomRight                  : '(b-r)',

        elementIsNotTopElementPassTpl: 'Element is not the top element on the screen',
        selectorIsAtPassTpl          : 'Found element matching CSS selector {selector} at [ {xy} ]',
        elementMatching              : 'Element matching',
        selectorIsAtFailAnnotation   : 'Passed selector does not match any selector at',
        selectorExistsFailTpl        : 'No element matching the passed selector found',
        selectorExistsPassTpl        : 'Found DOM element(s) matching CSS selector {selector}',

        selectorNotExistsFailTpl     : 'Elements found matching the passed selector',
        selectorNotExistsPassTpl     : 'Did not find any DOM element(s) matching CSS selector {selector}',

        toChangeForElement           : 'to change for element',

        selectorCountIsPassTpl       : 'Found exactly {count} elements matching {selector}',
        selectorCountIsFailTpl       : 'Found {got} elements matching the selector {selector}, expected {need}',
        isInViewPassTpl              : 'Passed element is within the visible viewport',

        toAppearInTheViewport        : 'to appear in the viewport',

        elementIsEmptyPassTpl        : 'Passed element is empty',
        elementIsNotEmptyPassTpl     : 'Passed element is not empty',
        elementToBeEmpty             : 'element to be empty',
        elementToNotBeEmpty          : 'element to not be empty'
    },

    "Siesta.Test.ExtJS"              : {
        bundleUrlNotFound                   : 'Cannot find Ext JS bundle url',
        assertNoGlobalExtOverridesInvalid   : 'Was not able to find the Ext JS bundle URL in the `assertNoGlobalExtOverrides` assertion',
        assertNoGlobalExtOverridesPassTpl   : 'No global Ext overrides found',
        assertNoGlobalExtOverridesGotDesc   : 'Number of overrides found',
        foundOverridesFor                   : 'Found overrides for',
        animationsToFinalize                : 'animations to finalize',
        extOverridesInvalid                 : 'Was not able to find the ExtJS bundle URL in the `assertMaxNumberOfGlobalExtOverrides` assertion)',
        foundLessOrEqualThan                : 'Found less or equal than',
        nbrOverridesFound                   : 'Number of overrides found',
        globalOverrides                     : 'Ext JS global overrides'
    },

    "Siesta.Test.ExtJSCore"          : {
        waitedForRequires           : 'Waiting for required classes took too long - \nCheck the `Net` tab in Firebug and the `loaderPath` config',
        waitedForExt                 : 'Waiting for Ext.onReady took too long - probably some dependency could not be loaded. \nCheck the `Net` tab in Firebug and the `loaderPath` config',
        waitedForApp                 : 'Waiting for MVC application launch took too long - no MVC application on test page? \nYou may need to disable the `waitForAppReady` config option',
        noComponentMatch             : 'Your component query: "{component}" returned no components',
        multipleComponentMatch       : 'Your component query: "{component}" returned more than 1 component',
        noComponentFound             : 'No component found for CQ',
        knownBugIn                   : 'Known bug in',
        Class                        : 'Class',
        wasLoaded                    : 'was loaded',
        wasNotLoaded                 : 'was not loaded',
        invalidCompositeQuery        : 'Invalid composite query selector',
        ComponentQuery               : 'ComponentQuery',
        CompositeQuery               : 'CompositeQuery',
        matchedNoCmp                 : 'matched no Ext.Component',
        messageBoxVisible            : 'Message box is visible',
        messageBoxHidden             : 'Message box is hidden',
        waitedForComponentQuery      : 'Waiting too long for Ext.ComponentQuery'
    },

    "Siesta.Test.Function"           : {
        Need                         : 'need',
        atLeast                      : 'at least',
        exactly                      : 'exactly',
        methodCalledExactly          : 'method was called exactly {n} times',
        exceptionEvalutingClass      : 'Exception [{e}] caught while evaluating the class name'
    },

    "Siesta.Test.More"               : {
        isGreaterPassTpl             : '`{value1}` is greater than `{value2}`',
        isLessPassTpl                : '`{value1}` is less than `{value2}`',
        isGreaterEqualPassTpl        : '`{value1}` is greater or equal to`{value2}`',
        isLessEqualPassTpl           : '`{value1}` is less or equal to`{value2}`',
        isApproxToPassTpl            : '`{value1}` is approximately equal to `{value2}`',

        needGreaterThan              : 'Need greater than',
        needGreaterEqualTo           : 'Need greater or equal to',
        needLessThan                 : 'Need less than',
        needLessEqualTo              : 'Need less or equal to',

        exactMatch                   : 'Exact match',
        withinThreshold              : 'Match within treshhold',
        needApprox                   : 'Need approx',
        thresholdIs                  : 'Threshold is',

        stringMatchesRe              : '`{string}` matches regexp {regex}',
        stringNotMatchesRe           : '`{string}` does not match regexp {regex}',
        needStringMatching           : 'Need string matching',
        needStringNotMatching        : 'Need string not matching',
        needStringContaining         : 'Need string containing',
        needStringNotContaining      : 'Need string not containing',
        stringHasSubstring           : '`{string}` has a substring: `{regex}`',
        stringHasNoSubstring         : '`{string}` does not have a substring: `{regex}`',

        throwsOkInvalid              : 'throws_ok accepts a function as 1st argument',
        didntThrow                   : 'Function did not throw an exception',
        exMatchesRe                  : 'Function throws exception matching to {expected}',
        exceptionStringifiesTo       : 'Exception stringifies to',
        exContainsSubstring          : 'Function throws exception containing a substring: {expected}',

        fnDoesntThrow                : 'Function does not throw any exceptions',
        fnThrew                      : 'Function threw an exception',

        isInstanceOfPass             : 'Object is an instance of the specified class',
        needInstanceOf               : 'Need instance of',
        isAString                    : '{value} is a string',
        aStringValue                 : 'AStringValue',
        isAnObject                   : '{value} is an object',
        anObject                     : 'An object value',
        isAnArray                    : '{value} is an array',
        anArrayValue                 : 'An array value',
        isANumber                    : '{value} is a number',
        aNumberValue                 : 'a number value',
        isABoolean                   : '{value} is a boolean',
        aBooleanValue                : 'a number value',
        isADate                      : '{value} is a date',
        aDateValue                   : 'a date value',
        isARe                        : '{value} is a regular expression',
        aReValue                     : 'a regular expression',
        isAFunction                  : '{value} is a function',
        aFunctionValue               : 'a function',
        isDeeplyPassTpl              : '{obj1} is deeply equal to {obj2}',
        isDeeplyStrictPassTpl        : '{obj1} is strictly deeply equal to {obj2}',
        globalCheckNotSupported      : 'Testing leakage of global variables is not supported on this platform',
        globalVariables              : 'Global Variables',
        noGlobalsFound               : 'No unexpected global variables found',
        globalFound                  : 'Unexpected global found',
        globalName                   : 'Global name',
        value                        : 'value',

        conditionToBeFulfilled       : 'condition to be fulfilled',
        pageToLoad                   : 'page to load',
        ms                           : 'ms',
        waitingFor                   : 'Waiting for',
        waitedTooLong                : 'Waited too long for',
        conditionNotFulfilled        : 'Condition was not fullfilled during',
        waitingAborted               : 'Waiting aborted',
        Waited                       : 'Waited',
        checkerException             : 'checker threw an exception',
        Exception                    : 'Exception',
        msFor                        : 'ms for',
        forcedWaitFinalization       : 'Forced finalization of waiting for',
        chainStepNotCompleted        : 'The step in `t.chain()` call did not complete within required timeframe, chain can not proceed',
        stepNumber                   : 'Step number',
        oneBased                     : '(1-based)',
        atLine                       : 'At line',
        chainStepEx                  : 'Chain step threw an exception',
        stepFn                       : 'Step function',
        notUsingNext                 : 'does not use the provided "next" function anywhere',
        calledMoreThanOnce           : 'The `next` callback of {num} step (1-based) of `t.chain()` call at line {line} is called more than once.',
        tooManyDifferences           : 'Showing {num} of {total} differences'
    },


    "Siesta.Test.SenchaTouch"               : {
        STSetupFailed                       : 'Waiting for Ext.setup took too long - some dependency could not be loaded? Check the `Net` tab in Firebug',
        invalidSwipeDir                     : 'Invalid swipe direction',
        moveFingerByInvalidInput            : 'Trying to call moveFingerBy without relative distances',
        scrollUntilFailed                   : 'scrollUntil failed to achieve its mission',
        scrollUntilElementVisibleInvalid    : 'scrollUntilElementVisible: target or scrollable not provided',
        scrollerReachPos                    : 'scroller to reach position'
    },

    "Siesta.Test"                           : {
        noCodeProvidedToTest                : 'No code provided to test',
        addingAssertionsAfterDone           : 'Adding assertions after the test has finished',
        testFailedAndAborted                : 'Assertion failed, test execution aborted',
        atLine                              : 'at line',
        of                                  : 'of',
        character                           : 'character',
        isTruthy                            : '`{value}` is a "truthy" value',
        needTruthy                          : 'Need "truthy" value',
        isFalsy                             : '`{value}` is a "falsy" value',
        needFalsy                           : 'Need "falsy" value',
        isEqualTo                           : '`{got}` is equal to `{expected}`',
        isNotEqualTo                        : '`{got}` is not equal to `{expected}`',
        needNot                             : 'Need not',
        isStrictlyEqual                     : '`{got}` is strictly equal to `{expected}`',
        needStrictly                        : 'Need strictly',
        isStrictlyNotEqual                  : '`{got}` is strictly not equal to `{expected}`',
        needStrictlyNot                     : 'Need strictly not',
        alreadyWaiting                      : 'Already waiting with title',
        noOngoingWait                       : 'There is no ongoing `wait` action with title',
        noMatchingEndAsync                  : 'No matching `endAsync` call within',
        endAsyncMisuse                      : 'Calls to endAsync without argument should only be performed if you have single beginAsync statement',
        codeBodyMissingForSubTest           : 'Code body is not provided for sub test',
        codeBodyMissingTestArg              : 'Code body of sub test [{name}] does not declare a test instance as 1st argument',
        Subtest                             : 'Subtest',
        Test                                : 'Test',
        failedToFinishWithin                : 'failed to finish within',
        threwException                      : 'threw an exception',
        testAlreadyStarted                  : 'Test has already been started',
        setupTookTooLong                    : '`setup` method took too long to complete',
        errorBeforeTestStarted              : 'Error happened before the test started',
        testStillRunning                    : 'Your test is still considered to be running, if this is unexpected please see console for more information',
        testNotFinalized                    : 'Your test [{url}] has not finalized, most likely since a timer (setTimeout) is still active. ' +
                                              'If this is the expected behavior, try setting "overrideSetTimeout : false" on your Harness configuration.',
        missingDoneCall                     : 'Test has completed, but there was no `t.done()` call. Add it at the bottom, or use `t.beginAsync()` for asynchronous code',
        allTestsPassed                      : 'All tests passed',
        
        'Snoozed until'                     : 'Snoozed until',
        testTearDownTimeout                 : "Test's tear down process has timeout out"
    },

    "Siesta.Recorder.UI.Editor.Code"           : {
        invalidSyntax                       : 'Invalid syntax'
    },

    "Siesta.Recorder.UI.Editor.DragTarget"     : {
        targetLabel                         : 'Target',
        toLabel                             : 'To',
        byLabel                             : 'By',
        cancelButtonText                    : 'Cancel',
        saveButtonText                      : 'Save',
        
        dragVariantTitle                    : 'Edit `drag` action',
        moveCursorVariantTitle              : 'Edit `moveCursor` action'
    },

    "Siesta.Recorder.UI.RecorderPanel"      : {
        actionColumnHeader                  : 'Action',
        offsetColumnHeader                  : 'Offset',
        queryMatchesNothing                 : 'Query matches no DOM elements or components',
        queryMatchesMultiple                : 'Query matches multiple components',
        noVisibleElsFound                   : 'No visible elements found for target',
        noTestDetected                      : 'No test detected',
        noTestStarted                       : 'You need to run a test first, or provide a Page URL',
        recordTooltip                       : 'Record',
        stopTooltip                         : 'Stop',
        playTooltip                         : 'Play',
        clearTooltip                        : 'Clear all',
        codeWindowTitle                     : 'Code',
        addNewTooltip                       : 'Add a new step',
        removeAllPromptTitle                : 'Remove all?',
        removeAllPromptMessage              : 'Do you want to clear the recorded events?',
        Error                               : 'Error',
        showSource                          : 'Show source',
        showSourceInNewWindow               : 'Show source in new window',
        newRecording                        : 'New recording...',
        pageUrl                             : 'Page URL'
    },

    "Siesta.Recorder.UI.TargetColumn"       : {
        headerText                          : 'Target / Value',
        by                                  : 'by',
        to                                  : 'to',
        coordinateTargetWarning             : 'Siesta was unable to find a stable selector for this target. Using coordinates as locator is not recommended.'
    }
};

;
// Localization helper
Siesta.Resource = (function () {
    
    var cacheByNamespace    = {}
    
    var Resource    = Class({
        does    : Siesta.Util.Role.CanFormatStrings,
        
        has     : {
            dict        : null
        },
        
        methods : {
            'get' : function (key, data) {
                var text = this.dict[ key ];
        
                if (text) return this.formatString(text, data);
        
                if (window.console && console.error) {
                    window.top.console.error('TEXT_NOT_DEFINED: ' + key);
                }
        
                return 'TEXT_NOT_DEFINED: ' + key;
            }
        }
    
    })
    

    return function (namespace, key, data) {
        var dictionary  = Siesta.CurrentLocale[ namespace ];

        if (!dictionary) {
            throw 'Missing dictionary for namespace: ' + namespace;
        }
        
        var resource    = cacheByNamespace[ namespace ]
        
        if (!resource) {
            resource    = cacheByNamespace[ namespace ] = new Resource({ dict : dictionary, serializeFormatingPlaceholders : false })
        }

        if (key) return resource.get(key, data)

        return resource
    }
})();
;
;(function () {
    
var ID = 0

Class('Siesta.Result', {
    
    has : {
        description     : null,
        
        children        : Joose.I.Array,
        
        length          : 0,
        
        id              : function () {
            return ++ID
        },
        
        parent          : null
    },
    
    
    methods : {
        
        itemAt : function (i) {
            return this.children[ i ]
        },
        
        
        push        : function (result) {
            this.children.push(result)
            
            result.parent   = this
            
            this.length     = this.children.length
        },
        
        
        each : function (func, scope) {
            var children        = this.children
            
            if (func.call(scope || this, this) === false) return false
            
            for (var i = 0; i < children.length; i++)
                if (children[ i ].each(func, scope) === false) return false
        },
        
        
        eachChild : function (func, scope) {
            var children        = this.children
            
            for (var i = 0; i < children.length; i++)
                if (func.call(scope, children[ i ]) === false) return false
        },
        
        
        toString : function () {
            return this.description
        },
        
        
        toJSON : function () {
            return {
                type        : this.meta.name,
                description : this.description
            }
        },
        
        
        findChildById : function (id) {
            var child
            
            this.each(function (node) {
                if (node.id == id) { child = node; return false } 
            })
            
            return child
        }
    },
    
    // used for self-testing when we need different ids for outer context and context being tested
    my : {
        methods     : {
            seedID : function (value) {
                ID          = value
            }
        }
    }
        
})


})();
Class('Siesta.Result.Diagnostic', {
    
    isa : Siesta.Result,
    
    has : {
        isWarning           : false
    },

    methods : {
        
        toString : function () {
            return '# ' + this.description
        },
        
        
        toJSON : function () {
            var info        = {
                type            : this.meta.name,
                description     : this.description
            }
            
            if (this.isWarning) info.isWarning = true
            
            return info
        }
    }    
});

;
Class('Siesta.Result.Summary', {
    
    isa         : Siesta.Result,
    
    has         : {
        isFailed            : false
    },
    
    methods : {
        
        // summary should belong only to the top level Siesta.Result.SubTest instance
        getTest : function () {
            return this.parent.test
        },
        
        
        toString : function () {
            
        }
    }    
});

;
Class('Siesta.Result.Assertion', {
    
    isa : Siesta.Result,

    has : {
        name            : null,
        
        passed          : null,
        
        annotation      : null,
        
        index           : null,
        // stored as string
        sourceLine      : null,
        
        isTodo          : false,
        
        isException     : false,
        exceptionType   : null,

        isWaitFor       : false,
        completed       : false      // for waitFor assertions
    },
    
    
    methods : {

        isPassed : function (raw) {
            if (raw) return this.passed
            
            if (this.isTodo) return true
            
            if (this.isWaitFor && !this.completed) return true
            
            return this.passed
        },
        
        
        toString : function () {
            var R       = Siesta.Resource('Siesta.Result.Assertion');
            
            var text    = (this.isTodo ? R.get('todoText') : '') + 
                (this.passed ? R.get('passText') : R.get('failText')) + ' ' + this.index + ' - ' + this.description
            
            if (this.annotation) text += '\n' + this.annotation
            
            return text
        },
        
        
        toJSON : function () {
            var me      = this
            
            var info    = {
                type            : this.meta.name,
                passed          : this.passed,
                index           : this.index,
                description     : String(this.description) || 'No description'
            }
            
            if (this.annotation) info.annotation = String(this.annotation)
            
            // copy if true
            Joose.A.each([ 'isTodo', 'isWaitFor', 'isException', 'sourceLine', 'name' ], function (name) {
                if (me[ name ]) info[ name ] = me[ name ]
            })
            
            if (this.isException)   {
                info.exceptionType  = this.exceptionType
            }
            
            return info
        }
    }
})

;
Class('Siesta.Result.SubTest', {
    
    isa : Siesta.Result,
    

    has : {
        // reference to a test it belongs to
        // SubTests result instances will be set as `results` for sub tests instances
        test            : null
    },
    
    
    methods : {
        
        isWorking : function () {
            return !this.test.isFinished()
        },
        
        
        toJSON : function () {
            var test            = this.test
            
            // a flag that test instance does not belongs to the current context
            // this only happens during self-testing
            // if this is the case, in IE, calling any method from the test context will throw exception
            // "can't execute script from freed context", so we avoid calling any methods on the test in such case
            // accessing properties is ok though
            var isCrossContext  = !(test instanceof Object)
            
            var report      = {
                type            : this.meta.name,
                name            : test.name,
                
                startDate       : test.startDate,
                endDate         : test.endDate || (new Date() - 0),
                
                passed          : isCrossContext ? null : test.isPassed()
            }
            
            // top level test
            if (!test.parent)   {
                report.automationElementId  = test.automationElementId
                report.url                  = test.url
                report.jUnitClass           = test.getJUnitClass()
                report.groups               = test.groups
            }
            
            if (test.specType)  report.bddSpecType  = test.specType
            
            var isFailed    = false
            var assertions  = []
            
            Joose.A.each(this.children, function (result) {
                if ((result instanceof Siesta.Result.Assertion) || (result instanceof Siesta.Result.Diagnostic) || (result instanceof Siesta.Result.SubTest)) {
                    var assertion   = result.toJSON()
                    
                    if (!assertion.passed && !assertion.isTodo) isFailed = true
                    
                    assertions.push(assertion)
                }
            })
            
            report.assertions       = assertions
            
            // see a comment above
            if (isCrossContext) {
                report.passed       = !(isFailed || test.failed || !test.endDate)
            }
            
            return report
        }
        
    }
})

;
/**
@class Siesta.Test.Function

This is a mixin, with helper methods for testing functionality relating to Functions (such as spies). This mixin is consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Function', {
    
    methods : {
         /**
         * This assertion passes if the function is called at least one time during the test life span.
         * 
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {String} [desc] The description of the assertion.
         */
        isCalled : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 1, desc, true);
        },

        /**
         * This assertion passes if the function is called exactly one time during the test life span.
         *
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {String} [desc] The description of the assertion.
         */
        isCalledOnce : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 1, desc, false);
        },

        /**
         * This assertion passes if the function is called exactly (n) times during the test life span.
         * 
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {Number} n The expected number of calls
         * @param {String} [desc] The description of the assertion.
         */
        isCalledNTimes : function(fn, obj, n, desc, isGreaterEqual) {
            var me      = this,
                prop    = typeof fn === "string" ? fn : me.getPropertyName(obj, fn);

            var counter = 0;
            var R       = Siesta.Resource('Siesta.Test.Function');

            desc        = desc ? (desc + ' ') : '';

            this.on('beforetestfinalizeearly', function () {
                if (counter === n || (isGreaterEqual && counter > n)) {
                    me.pass(desc || (prop + ' ' + R.get('methodCalledExactly').replace('{n}', n)));
                } else {

                    me.fail(desc || prop, {
                        assertionName       : 'isCalledNTimes ' + prop,
                        got                 : counter, 
                        need                : n,
                        needDesc            : R.get("Need") + " " + (isGreaterEqual ? R.get('atLeast') : R.get('exactly')) + " "
                    });
                }
            });

            fn = obj[prop];
            obj[prop] = function () { counter++; return fn.apply(this, arguments); };
        },

        /**
         * This assertion passes if the function is not called during the test life span.
         * 
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {Number} n The expected number of calls
         * @param {String} [desc] The description of the assertion.
         */
        isntCalled : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 0, desc);
        },

        getPropertyName : function(host, obj) {
            for (var o in host) {
                if (host[o] === obj) return o;
            }
        },

        /**
         * This assertion passes when the supplied class method is called exactly (n) times during the test life span.
         * Under "class method" here we mean the function in the prototype. Note, that this assertion counts calls to the method in *any* class instance.
         * 
         * The `className` parameter can be supplied as a class constructor function or as a string, representing the class
         * name. In the latter case the `class` will be eval'ed to get a reference to the class constructor.
         * 
         * For example:

    StartTest(function (t) {
    
        function machine(type, version) {
            this.machineInfo = {
                type        : type,
                version     : version
            };
        };
        
        machine.prototype.update = function (type, version) {
            this.setVersion(type);
            this.setType(version);
        };
        
        machine.prototype.setVersion = function (data) {
            this.machineInfo.version = data;
        };
        
        machine.prototype.setType = function (data) {
            this.machineInfo.type = data;
        };
        
        t.methodIsCalled("setVersion", machine, "Checking if method 'setVersion' has been called");
        t.methodIsCalled("setType", machine, "Checking if method 'setType' has been called");
        
        var m = new machine('rover', '0.1.2');
        
        m.update('3.2.1', 'New Rover');
    });
    
         *
         * This assertion is useful when testing for example an Ext JS class where event listeners are added during
         * class instantiation time, which means you need to observe the prototype method before instantiation.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The constructor function or the name of the class that contains the method
         * @param {Number} n The expected number of calls
         * @param {String} [desc] The description of the assertion
         */
        methodIsCalledNTimes: function(fn, className, n, desc, isGreaterEqual){
            var me          = this,
                counter     = 0;
            var R           = Siesta.Resource('Siesta.Test.Function');

            desc            = desc ? (desc + ' ') : '';
            
            try {
                if (me.typeOf(className) == 'String') className = me.global.eval(className)
            } catch (e) {
                me.fail(desc, {
                    assertionName       : 'isMethodCalled',
                    annotation          : R.get('exceptionEvalutingClass').replace('{e}', e) + "[" + className + "]"
                })

                return
            }

            var prototype   = className.prototype;
            var prop        = typeof fn === "string" ? fn : me.getPropertyName(prototype, fn);

            me.on('beforetestfinalizeearly', function () {
                if (counter === n || (isGreaterEqual && counter > n)) {
                    me.pass(desc || (prop + ' ' + R.get('methodCalledExactly').replace('{n}', n)));
                } else {
                    me.fail(desc || prop, {
                        assertionName       : 'methodIsCalledNTimes ' + prop,
                        got                 : counter,
                        need                : n ,
                        needDesc            : R.get("Need") + " " + (isGreaterEqual ? R.get('atLeast') : R.get('exactly')) + " "
                    });
                }
            });

            fn                  = prototype[ prop ];
            prototype[ prop ]   = function () { counter++; return fn.apply(this, arguments); };
        },

        /**
         * This assertion passes if the class method is called at least one time during the test life span.
         * 
         * See {@link #methodIsCalledNTimes} for more details.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The class constructor function or name of the class that contains the method
         * @param {String} [desc] The description of the assertion.
         */
        methodIsCalled : function(fn, className, desc) {
            this.methodIsCalledNTimes(fn, className, 1, desc, true);
        },

        /**
         * This assertion passes if the class method is not called during the test life span.
         * 
         * See {@link #methodIsCalledNTimes} for more details.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The class constructor function or name of the class that contains the method
         * @param {String} [desc] The description of the assertion.
         */
        methodIsntCalled : function(fn, className, desc) {
            this.methodIsCalledNTimes(fn, className, 0, desc);
        }
    }
});
;
/**
@class Siesta.Test.Date

A mixin with the additinal assertions for dates. Being consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Date', {
    
    methods : {
        
        isDateEq: function (got, expectedDate, description) {
            this.isDateEqual.apply(this, arguments);
        },

        
        /**
         * This assertion passes when the 2 provided dates are equal and fails otherwise.
         * 
         * It has a synonym: `isDateEq`
         * 
         * @param {Date} got The 1st date to compare
         * @param {Date} expectedDate The 2nd date to compare
         * @param {String} [description] The description of the assertion
         */
        isDateEqual: function (got, expectedDate, description) {
            var R = Siesta.Resource('Siesta.Test.Date');

            if (got - expectedDate === 0) {
                this.pass(description, {
                    descTpl         : '{got} ' + R.get('isEqualTo') + ' {expectedDate}',
                    got             : got,
                    expectedDate    : expectedDate
                });
            } else {
                this.fail(description, {
                    assertionName   : 'isDateEqual',
                    
                    got             : got ? got.toString() : '',
                    gotDesc         : R.get('Got'),
                    
                    need            : expectedDate.toString()
                });
            }
        }
    }
});
;
/**
@class Siesta.Test.More

A mixin with additional generic assertion methods, which can work cross-platform between browsers and NodeJS. 
Is being consumed by {@link Siesta.Test}, so all of them are available in all tests. 

*/
Role('Siesta.Test.More', {
    
    requires        : [ 'isFailed', 'typeOf', 'on' ],
    
    
    has : {
        autoCheckGlobals        : false,
        expectedGlobals         : Joose.I.Array,

        disableGlobalsCheck     : false,
        
        browserGlobals : { 
            init : [
                'console',
                'getInterface',
                'ExtBox1',
                '__IE_DEVTOOLBAR_CONSOLE_COMMAND_LINE',
                /__BROWSERTOOLS/, // IE11 with console open
                'seleniumAlert',
                '_phantom', // phantomJS
                'callPhantom', // phantomJS
                'onload',
                'onerror', 
                'StartTest',
                'startTest',
                '__loaderInstrumentationHookInstalled__',
                'describe',
                // will be reported in IE8 after overriding
                'setTimeout',
                'clearTimeout',
                'requestAnimationFrame',
                'cancelAnimationFrame',
                '__coverage__',
                /__cov_\d+/
            ]
        },
        
        /**
         * @cfg {Number} waitForTimeout Default timeout for `waitFor` (in milliseconds). Default value is 10000. 
         */
        waitForTimeout                  : 10000,
        
        waitForPollInterval             : 100,

        suppressPassedWaitForAssertion  : false
    },
    
    
    methods : {
        
        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `>` operator will return `true` and fails otherwise. 
         * 
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isGreater : function (value1, value2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (value1 > value2)
                this.pass(desc, {
                    descTpl             : R.get('isGreaterPassTpl'),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isGreater',
                    
                    got                 : value1,
                    need                : value2,
                    
                    needDesc            : R.get('needGreaterThan')
                })
        },
        
        
        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `<` operator will return `true` and fails otherwise. 
         * 
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isLess : function (value1, value2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (value1 < value2)
                this.pass(desc, {
                    descTpl             : R.get('isLessPassTpl'),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isLess',
                    
                    got                 : value1,
                    need                : value2,
                    
                    needDesc            : R.get('needLessThan')
                })
        },
        

        isGE : function () {
            this.isGreaterOrEqual.apply(this, arguments)
        },
        
        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `>=` operator will return `true` and fails otherwise. 
         * 
         * It has a synonym - `isGE`.
         * 
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isGreaterOrEqual : function (value1, value2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (value1 >= value2)
                this.pass(desc, {
                    descTpl             : R.get('isGreaterEqualPassTpl'),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isGreaterOrEqual',
                    
                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get('needGreaterEqualTo')
                })
        },
        

        
        isLE : function () {
            this.isLessOrEqual.apply(this, arguments)
        },
        
        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `<=` operator will return `true` and fails otherwise. 
         * 
         * It has a synonym - `isLE`.
         * 
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isLessOrEqual : function (value1, value2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (value1 <= value2)
                this.pass(desc, {
                    descTpl             : R.get('isLessEqualPassTpl'),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isLessOrEqual',
                    
                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get('needLessEqualTo')
                })
        },
        
        
        /**
         * This assertion suppose to compare the numeric values. It passes when the passed values are approximately the same (the difference 
         * is withing a threshold). A threshold can be provided explicitly (when assertion is called with 4 arguments), 
         * or it will be set to 5% from the 1st value (when calling assertion with 3 arguments).
         * 
         * @param {Number} value1 The 1st value to compare
         * @param {Number} value2 The 2nd value to compare
         * @param {Number} threshHold The maximum allowed difference between values. This argument can be omited. 
         * @param {String} [desc] The description of the assertion
         */
        isApprox : function (value1, value2, threshHold, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (arguments.length == 2) threshHold  = Math.abs(value1 * 0.05)
            
            if (arguments.length == 3) {
                if (this.typeOf(threshHold) == 'String') {
                    desc            = threshHold
                    threshHold      = Math.abs(value1 * 0.05)
                }
            }
            
            // this function normalizes the fractional numbers to fixed point presentation
            // for example in JS: 1.05 - 1 = 0.050000000000000044
            // so what we do is: (1.05 * 10^2 - 1 * 10^2) / 10^2 = (105 - 100) / 100 = 0.05
            var subtract    = function (value1, value2) {
                var fractionalLength    = function (v) {
                    var afterPointPart = (v + '').split('.')[ 1 ]
                    
                    return afterPointPart && afterPointPart.length || 0
                }
                
                var maxLength           = Math.max(fractionalLength(value1), fractionalLength(value2))
                var k                   = Math.pow(10, maxLength);

                return (value1 * k - value2 * k) / k;
            };            
            
            if (Math.abs(subtract(value2, value1)) <= threshHold)
                this.pass(desc, {
                    descTpl             : R.get('isApproxToPassTpl'),
                    value1              : value1,
                    value2              : value2,
                    annotation          : value2 == value1 ? R.get('exactMatch') : (R.get('withinThreshold') + ': ' + threshHold)
                })
            else
                this.fail(desc, {
                    assertionName       : 'isApprox', 
                    got                 : value1, 
                    need                : value2, 
                    needDesc            : R.get('needApprox'),
                    annotation          : R.get('thresholdIs') + ': ' + threshHold
                })
        },
        
        
        /**
         * This assertion passes when the passed `string` matches to a regular expression `regex`. When `regex` is a string, 
         * assertion will check that it is a substring of `string`
         * 
         * @param {String} string The string to check for "likeness"
         * @param {String/RegExp} regex The regex against which to test the string, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        like : function (string, regex, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(regex) == "RegExp")
            
                if (string.match(regex))
                    this.pass(desc, {
                        descTpl             : R.get('stringMatchesRe'),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'like', 
                        got                 : string, 
                        need                : regex, 
                        needDesc            : R.get('needStringMatching')
                    })
            else
             
                if (string.indexOf(regex) != -1)
                    this.pass(desc, {
                        descTpl             : R.get('stringHasSubstring'),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'like', 
                        got                 : string, 
                        need                : regex, 
                        needDesc            : R.get('needStringContaining')
                    })
        },
        
        /**
         * This method is the opposite of 'like', it adds failed assertion, when the string matches the passed regex.
         * 
         * @param {String} string The string to check for "unlikeness"
         * @param {String/RegExp} regex The regex against which to test the string, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        unlike : function(string, regex, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(regex) == "RegExp")
            
                if (!string.match(regex))
                    this.pass(desc, {
                        descTpl             : R.get('stringNotMatchesRe'),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'unlike', 
                        got                 : string, 
                        need                : regex, 
                        needDesc            : R.get('needStringNotMatching')
                    })
            else
             
                if (string.indexOf(regex) == -1)
                    this.pass(desc, {
                        descTpl             : R.get('stringHasNoSubstring'),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'unlike', 
                        got                 : string, 
                        need                : regex, 
                        needDesc            : R.get('needStringNotContaining')
                    })
        },
        
        
        "throws" : function () {
            this.throwsOk.apply(this, arguments)
        },
        
        throws_ok : function () {
            this.throwsOk.apply(this, arguments)
        },
        
        /**
         * This assertion passes if the `func` function throws an exception during executing, and the
         * stringified exception passes the 'like' assertion (with 'expected' parameter).
         * 
         * It has synonyms - `throws_ok` and `throws`.
         *
         *      t.throwsOk(function(){
         *          throw "oopsie";
         *      }, 'oopsie', 'Some description text');
         *
         * @param {Function} func The function which should throw an exception
         * @param {String/RegExp} expected The regex against which to test the stringified exception, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        throwsOk : function (func, expected, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(func) != 'Function') throw new Error(R.get('throwsOkInvalid'))
            
            var e = this.getExceptionCatcher()(func)
            
            // assuming no one will throw undefined exception..
            if (e === undefined) {
                this.fail(desc, {
                    assertionName       : 'throws_ok', 
                    annotation          : R.get('didntThrow')
                })
                
                return
            }
            
            if (e instanceof this.getTestErrorClass())
                //IE uses non-standard 'description' property for error msg
                e = e.message || e.description
                
            e = '' + e
                
            if (this.typeOf(expected) == "RegExp")
            
                if (e.match(expected))
                    this.pass(desc, {
                        descTpl             : R.get('exMatchesRe'),
                        expected            : expected
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'throws_ok', 
                        got                 : e, 
                        gotDesc             : R.get('exceptionStringifiesTo'),
                        need                : expected, 
                        needDesc            : R.get('needStringMatching')
                    })
            else
             
                if (e.indexOf(expected) != -1)
                    this.pass(desc, {
                        descTpl             : R.get('exContainsSubstring'),
                        expected            : expected
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'throws_ok', 
                        got                 : e,
                        gotDesc             : R.get('exceptionStringifiesTo'),
                        need                : expected,
                        needDesc            : R.get('needStringContaining')
                    })
        },
        
        
        
        lives_ok : function () {
            this.livesOk.apply(this, arguments)
        },
        
        lives : function () {
            this.livesOk.apply(this, arguments)
        },
        
        /**
         * This assertion passes, when the supplied `func` function doesn't throw an exception during execution.
         * 
         * This method has two synonyms: `lives_ok` and `lives`
         * 
         * @param {Function} func The function which is not supposed to throw an exception
         * @param {String} [desc] The description of the assertion
         */
        livesOk : function (func, desc) {
            if (this.typeOf(func) != 'Function') {
                func = [ desc, desc = func ][ 0 ]
            }

            var R       = Siesta.Resource('Siesta.Test.More');
            var e       = this.getExceptionCatcher()(func)
            
            if (e === undefined) 
                this.pass(desc, {
                    descTpl             : R.get('fnDoesntThrow')
                })
            else
                this.fail(desc, {
                    assertionName       : 'lives_ok', 
                    annotation          : R.get('fnThrew') + ': ' + e
                })
        },
        
        
        isa_ok : function (value, className, desc) {
            this.isInstanceOf(value, className, desc)
        },
        

        isaOk : function (value, className, desc) {
            this.isInstanceOf(value, className, desc)
        },
        
        /**
         * This assertion passes, when the supplied `value` is the instance of the `className`. The check is performed with
         * `instanceof` operator. The `className` parameter can be supplied as class constructor or as string, representing the class
         * name. In the latter case the `class` will eval'ed to receive the class constructor.
         * 
         * This method has synonyms: `isaOk`, `isa_ok`
         * 
         * @param {Mixed} value The value to check for 'isa' relationship
         * @param {Class/String} className The class to check for 'isa' relationship with `value`
         * @param {String} [desc] The description of the assertion
         */
        isInstanceOf : function (value, className, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            try {
                if (this.typeOf(className) == 'String') className = this.global.eval(className)
            } catch (e) {
                this.fail(desc, {
                    assertionName       : 'isa_ok', 
                    annotation          : Siesta.Resource('Siesta.Test.Function', 'exceptionEvalutingClass')
                })
                
                return
            }
            
            if (value instanceof className) 
                this.pass(desc, {
                    descTpl             : R.get('isInstanceOfPass')
                })
            else
                this.fail(desc, {
                    assertionName       : 'isa_ok', 
                    got                 : value, 
                    need                : String(className), 
                    needDesc            : R.get('needInstanceOf')
                })
        },
        
        
        /**
         * This assertion passes, if supplied value is a String.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isString : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'String')
                this.pass(desc, {
                    descTpl     : R.get('isAString'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aStringValue')
                })
        },
        
        
        /**
         * This assertion passes, if supplied value is an Object
         * 
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isObject : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Object')
                this.pass(desc, {
                    descTpl     : R.get('isAnObject'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('anObject')
                })
        },
        

        /**
         * This assertion passes, if supplied value is an Array
         * 
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isArray : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Array')
                this.pass(desc, {
                    descTpl     : R.get('isAnArray'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('anArrayValue')
                })
        },


        /**
         * This assertion passes, if supplied value is a Number.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isNumber : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Number')
                this.pass(desc, {
                    descTpl     : R.get('isANumber'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aNumberValue')
                })
        },


        /**
         * This assertion passes, if supplied value is a Boolean.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isBoolean : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Boolean')
                this.pass(desc, {
                    descTpl     : R.get('isABoolean'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aBooleanValue')
                })
        },

        
        /**
         * This assertion passes, if supplied value is a Date.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isDate : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Date')
                this.pass(desc, {
                    descTpl     : R.get('isADate'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aDateValue')
                })
        },

        
        /**
         * This assertion passes, if supplied value is a RegExp.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isRegExp : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'RegExp')
                this.pass(desc, {
                    descTpl     : R.get('isARe'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aReValue')
                })
        },
        
        
        /**
         * This assertion passes, if supplied value is a Function.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isFunction : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Function')
                this.pass(desc, {
                    descTpl     : R.get('isAFunction'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aFunctionValue')
                })
        },        
        
        
        is_deeply : function (obj1, obj2, desc) {
            this.isDeeply.apply(this, arguments)
        },
        
        /**
         * This assertion passes when in-depth comparison of 1st and 2nd arguments (which are assumed to be JSON objects) shows that they are equal.
         * Comparison is performed with '==' operator, so `[ 1 ]` and `[ "1" ] objects will be equal. The objects should not contain cyclic references.
         * 
         * This method works correctly with the *placeholders* generated with method {@link #any}.
         * 
         * This method has a synonym: `is_deeply`
         * 
         * @param {Object} obj1 The 1st object to compare
         * @param {Object} obj2 The 2nd object to compare
         * @param {String} [desc] The description of the assertion
         */
        isDeeply : function (obj1, obj2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(obj1) === this.typeOf(obj2) && this.compareObjects(obj1, obj2)) {

                this.pass(desc, {
                    descTpl             : R.get('isDeeplyPassTpl'),
                    obj1                : obj1,
                    obj2                : obj2
                })
            }
            // Not supported in IE8
            else if (window.DeepDiff) {

                var diff = DeepDiff(obj1, obj2);

                if (diff.length > 5) {
                    this.diag(R.get('tooManyDifferences', { num : 5, total : diff.length}))
                }

                for (var i = 0; i < Math.min(diff.length, 5); i++) {
                    var diffItem = diff[i];
                    var path     = (diffItem.path || []).join('.');
                    var saw      = path ? (path + ': ' + diffItem.lhs) : obj1;
                    var expected = path ? (path + ': ' + diffItem.rhs) : obj2;

                    this.fail(desc, {
                        assertionName       : 'isDeeply',
                        got                 : saw,
                        need                : expected
                    })

                    // Also log it to console for easy inspection
                    window.console && console.log('DIFF RESULT:', diffItem);
                }

            } else {
                this.fail(desc, {
                    assertionName       : 'isDeeply',
                    got                 : obj1,
                    need                : obj2
                })
            }
        },
        
        
        /**
         * This assertion passes when in-depth comparison of 1st and 2nd arguments (which are assumed to be JSON objects) shows that they are equal.
         * Comparison is performed with '===' operator, so `[ 1 ]` and `[ "1" ] objects will be different. The objects should not contain cyclic references.
         * 
         * This method works correctly with the *placeholders* generated with method {@link #any}.
         * 
         * @param {Object} obj1 The 1st object to compare
         * @param {Object} obj2 The 2nd object to compare
         * @param {String} [desc] The description of the assertion
         */
        isDeeplyStrict : function (obj1, obj2, desc) {
            if (this.typeOf(obj1) === this.typeOf(obj2) && this.compareObjects(obj1, obj2, true)) {

                var R       = Siesta.Resource('Siesta.Test.More');

                this.pass(desc, {
                    descTpl             : R.get('isDeeplyStrictPassTpl'),
                    obj1                : obj1,
                    obj2                : obj2
                })
            }
            else
                this.fail(desc, {
                    assertionName       : 'isDeeplyStrict', 
                    got                 : obj1, 
                    need                : obj2 
                })
        },
        
        expectGlobal : function () {
            this.expectGlobals.apply(this, arguments)
        },
        
        
        /**
         * This method accepts a variable number of names of expected properties in the global scope. When verifying the globals with {@link #verifyGlobals}
         * assertions, the expected gloabls will not be counted as failed assertions.
         * 
         * This method has a synonym with singular name: `expectGlobal`
         * 
         * @param {String/RegExp} name1 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} name2 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} nameN The name of global property or the regular expression to match several properties
         */
        expectGlobals : function () {
            this.expectedGlobals.push.apply(this.expectedGlobals, arguments)
        },
        
        
        isGlobalExpected : function (name, index) {
            var me                  = this
            
            if (!index || index && !index.expectedStrings) {
                if (!index) index   = {}
                
                Joose.O.extend(index, {
                    expectedStrings     : {},
                    expectedRegExps     : []
                })
                
                Joose.A.each(this.expectedGlobals.concat(this.browserGlobals), function (value) {
                    if (me.typeOf(value) == 'RegExp')
                        index.expectedRegExps.push(value)
                    else
                        index.expectedStrings[ value ] = true 
                })
            }
            
            if (index.expectedStrings[ name ]) return true
            
            var imageWithIdCreatesGlobalEnumerable  = Siesta.Harness.Browser.FeatureSupport().supports.imageWithIdCreatesGlobalEnumerable;
            
            // remove after https://bugzilla.mozilla.org/show_bug.cgi?id=959992 will be fixed
            if (imageWithIdCreatesGlobalEnumerable) {
                var domEl       = this.global.document.getElementById(name)
                
                if (domEl && domEl.tagName.toLowerCase() == 'img') return true;
            }
                
            for (var i = 0; i < index.expectedRegExps.length; i++)
                if (index.expectedRegExps[ i ].test(name)) return true
            
            return false
        },
        
        
        forEachUnexpectedGlobal : function (func, scope) {
            scope                   = scope || this
            
            var index               = {}
            
            for (var name in this.global) 
                if (!this.isGlobalExpected(name, index)) {
                    if (func.call(scope, name) === false) {
                        break;
                    }
                }
        },
        
        
        /**
         * This method accepts a variable number of names of expected properties in the global scope and then performs a globals check. 
         *
         * It will scan all globals properties in the scope of test and compare them with the list of expected globals. Expected globals can be provided with:
         * {@link #expectGlobals} method or {@link Siesta.Harness#expectedGlobals expectedGlobals} configuration option of harness.
         * 
         * You can enable this assertion to automatically happen at the end of each test, using {@link Siesta.Harness#autoCheckGlobals autoCheckGlobals} option of the harness.
         * 
         * @param {String/RegExp} name1 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} name2 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} nameN The name of global property or the regular expression to match several properties
         */
        verifyGlobals : function () {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.disableGlobalsCheck) {
                this.diag(R.get('globalCheckNotSupported'));
                
                return
            }
            
            this.expectGlobals.apply(this, arguments)
            
            this.diag(R.get('globalVariables'))
            
            var failed          = false
            var i               = 0
            this.forEachUnexpectedGlobal(function (name) {
                this.fail(
                    R.get('globalFound'), 
                    R.get('globalName') + ': ' + name + ', ' + R.get('value') + ': ' + Siesta.Util.Serializer.stringify(this.global[ name ])
                )
                
                failed      = true
                return i++ < 50 // Only report first 50 globals to protect against legacy apps with thousands of globals
            })
            
            if (!failed) this.pass(R.get('noGlobalsFound'))
        },
        
        
        // will create a half-realized, "phantom", "isWaitFor" assertion, which is only purposed
        // for user to get the instant feedback about "waitFor" actions
        // this assertion will be "finalized" and added to the test results in the "finalizeWaiting"
        startWaiting : function (description, sourceLine) {
            var result = new Siesta.Result.Assertion({
                description     : description,
                isWaitFor       : true,
                sourceLine      : sourceLine
            });
            
            this.fireEvent('testupdate', this, result, this.getResults())
            
            return result;
        },
        
        
        finalizeWaiting : function (result, passed, desc, annotation, errback, suppressPassedAssertion) {
            // Treat this is an ordinary assertion from now on
            result.completed = true;

            if (passed) {
                if (this.suppressPassedWaitForAssertion || suppressPassedAssertion) {
                    // Make sure UI is updated and the "noise" is removed
                    this.fireEvent('assertiondiscard', this, result)
                } else {
                    this.pass(desc, annotation, result)
                }
            }
            else {
                this.fail(desc, annotation, result);
                
                errback && errback()
            }
        },
        
        
        /**
         * Waits for passed checker method to return true (or any non-false value, like for example DOM element or array), and calls the callback when this happens.
         * As an additional feature, the callback will receive the result from the checker method as the 1st argument.
         * 

    t.waitFor(
        function () { return document.getElementById('someEl') },
        function (el) {
            // waited for element #someEl to appear
            // element will be available in the callback as 1st argument "el"
        }
    )

         * You can also call this method with a single Object having the following properties: `method`, `callback`, `scope`, `timeout`, `interval`:

    t.waitFor({
        method      : function () { return document.getElementById('someEl') },
        callback    : function (el) {
            // waited for element #someEl to appear
            // element will be available in the callback as 1st argument "el"
        }
    })

         * 
         * @param {Object/Function/Number} method Either a function which should return true when a certain condition has been fulfilled, or a number of ms to wait before calling the callback. 
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled. 
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test. 
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         * 
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback). 
         * No call to checker will be performed and callback will not receive a result from it. 
         */
        waitFor : function (method, callback, scope, timeout, interval)  {
            var R                       = Siesta.Resource('Siesta.Test.More');
            var description             = ' ' + R.get('conditionToBeFulfilled');
            var assertionName           = 'waitFor';
            var me                      = this;
            var sourceLine              = me.getSourceLine();
            var originalSetTimeout      = me.originalSetTimeout;
            var originalClearTimeout    = me.originalClearTimeout;
            var errback;
            var suppressAssertion;

            if (arguments.length === 1 && this.typeOf(method) == 'Object') {
                var options         = method;
                
                method              = options.method;
                callback            = options.callback;
                scope               = options.scope;
                timeout             = options.timeout;
                interval            = options.interval
                
                description         = options.description || description;
                assertionName       = options.assertionName || assertionName;
                suppressAssertion   = options.suppressAssertion;

                // errback is called in case "waitFor" has failed
                errback             = options.errback
            }

            var isWaitingForTime        = this.typeOf(method) == 'Number'

            callback                    = callback || function () {}
            description                 = isWaitingForTime ? (method + ' ' + R.get('ms')) : description;

            var pollTimeout
            
            // early notification about the started "waitFor" operation
            var waitAssertion           = me.startWaiting(R.get('waitingFor') + ' ' + description, sourceLine);
            
            interval                    = interval || this.waitForPollInterval
            timeout                     = timeout || this.waitForTimeout
            
            // this async frame is not supposed to fail, because it's delayed to `timeout + 3 * interval`
            // failure supposed to be generated in the "pollFunc" and this async frame to be closed
            // however, in IE the async frame may end earlier than failure from "pollFunc"
            // in such case we report the same error as in "pollFunc"
            var async                   = this.beginAsync((isWaitingForTime ? method : timeout) + 3 * interval, function () {
                isDone      = true
                
                originalClearTimeout(pollTimeout)
                
                me.finalizeWaiting(waitAssertion, false, R.get('waitedTooLong') + ': ' + description, {
                    assertionName       : assertionName,
                    annotation          : R.get('conditionNotFulfilled') + ' ' + timeout + R.get('ms')
                }, errback, suppressAssertion)
                
                return true
            })

            var isDone      = false

            // stop polling, if this test instance has finalized (probably because of exception)
            this.on('beforetestfinalize', function () {
                if (!isDone) {
                    isDone      = true
                    
                    me.finalizeWaiting(waitAssertion, false, R.get('waitingAborted'), null, null, suppressAssertion);
                    me.endAsync(async)
                    
                    originalClearTimeout(pollTimeout)
                }
            }, null, { single : true })

            if (isWaitingForTime) {
                if (method < 0) {
                    throw 'Cannot wait for a negative amount of time';
                }
                pollTimeout = originalSetTimeout(function() {
                    isDone      = true

                    me.finalizeWaiting(waitAssertion, true, R.get('Waited') + ' ' + method + ' ' + R.get('ms'), null, null, suppressAssertion || method === 0);
                    me.endAsync(async);
                    me.processCallbackFromTest(callback, [], scope || me)
                }, method);
                
            } else {

                var result;
                var startDate   = new Date()
            
                var pollFunc    = function () {
                    var time = new Date() - startDate;
                    
                    if (time > timeout) {
                        me.endAsync(async);

                        me.finalizeWaiting(waitAssertion, false, R.get('waitedTooLong') + ': ' + description, {
                            assertionName       : assertionName,
                            annotation          : R.get('conditionNotFulfilled') + ' ' + timeout + R.get('ms')
                        }, errback, suppressAssertion)
                        
                        isDone      = true
                    
                        return
                    }
                
                    try {
                        result = method.call(scope || me);
                    } catch (e) {
                        me.endAsync(async);
                    
                        me.finalizeWaiting(waitAssertion, false, assertionName + ' ' + R.get('checkerException'), {
                            assertionName       : assertionName,
                            got                 : e.toString(),
                            gotDesc             : R.get('Exception')
                        }, errback, suppressAssertion)
                    
                        isDone      = true
                        
                        return
                    }
                
                    if (result != null && result !== false) {
                        me.endAsync(async);
                        
                        isDone      = true
                        me.finalizeWaiting(waitAssertion, true, R.get('Waited') + ' ' + time + ' ' + R.get('msFor') + ' ' + description, null, null, suppressAssertion || time === 0);
                        
                        me.processCallbackFromTest(callback, [ result ], scope || me)
                    } else 
                        pollTimeout = originalSetTimeout(pollFunc, interval)
                }
            
                pollFunc()
            }
            
            return {
                force : function () {
                    // wait operation already completed 
                    if (isDone) return
                    
                    isDone      = true
                    
                    originalClearTimeout(pollTimeout)
                    
                    me.endAsync(async);
                    
                    me.finalizeWaiting(waitAssertion, true, R.get('forcedWaitFinalization') + ' ' + description, null, null, suppressAssertion);
                    
                    me.processCallbackFromTest(callback, [], scope || me)
                }
            }
        },

        /**
         * Waits for the number of a number millseconds and calls the callback when after waiting. This is just a convenience synonym for the {@link #waitFor} method.

         t.waitForMs(1500, callback)

         *
         * @param {Number} method The number of ms to wait before calling the callback.
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitForMs : function() {
            return this.waitFor.apply(this, arguments);
        },
        

        /**
         * Waits for the passed checker method to return true (or any non-false value, like for example DOM element or array), and calls the callback when this happens.
         * This is just a convenience synonym for the {@link #waitFor} method.
         *

         t.waitForFn(function() { return true; }, callback)

         *
         * @param {Function} fn The checker function.
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitForFn : function() {
            return this.waitFor.apply(this, arguments);
        },
        
        // takes the step function and tries to analyze if it is missing the call to "next"
        // returns "true" if "next" is used, 
        analyzeChainStep : function (func) {
            var sources         = func.toString()
            var firstArg        = sources.match(/function\s*[^(]*\(\s*(.*?)\s*(?:,|\))/)[ 1 ]
                        
            if (!firstArg) return false
            
            var body            = sources.match(/\{([\s\S]*)\}/)[ 1 ]
            
            return body.indexOf(firstArg) != -1
        },
        
        
        /**
         * This method accepts a variable number of steps, either as individual arguments or as a single array containing them. Steps and arrays
         * of steps are handled just fine, and any step-arrays passed will be flattened. Each step should be either a function or configuration 
         * object for {@link Siesta.Test.Action test actions}. These functions / actions will be executed in order.
         * 
         * 1) For a function step, it will receive a callback as the 1st argument, to call when the step is completed.
         * As the 2nd and further arguments, the step function will receive the arguments passed to the previous callback.
         * 
         * The last step will receive a no-op callback, which can be ignored or still called. **Note**, that last step is assumed to
         * complete synchronously! If you need to launch some asynchronous process in the last step, you may need to add another empty function step
         * to the end of the chain.
         * 
         * 2) For Siesta.Test.Action objects, the callback will be called by the action class automatically,
         * there's no need to provide any callback manually. The configuration object should contain an "action" property, specifying the action class
         * along with other config options depending on the action class. For brevity, instead of using the "action" property, the configuration
         * object can contain the property corresponding to the action name itself, with the action's target (or even a test method with arguments).
         * See the following examples and also refer to the documentation of the action classes. 
         * 
         * If the configuration object will contain a "desc" property, a passing assertion with its value will be added to the test, after this step has completed.
         * 
         * 3) If a step is a sub test instance, created with {@link #getSubTest} method, then the step will launch it.
         * 
         * It's better to see how it works in action. For example, when using using only functions:
         
    t.chain(
        // function receives a callback as 1st argument
        function (next) {
            // we pass that callback to the "click" method
            t.click(buttonEl, next)
        },
        function (next) {
            t.type(fieldEl, 'Something', next)
        },
        function (next) {
            t.is(fieldEl.value == 'Something', 'Correct value in the field')
            
            // call the callback with some arguments
            next('foo', 'bar')  
        }, 
        // those arguments are now available as arguments of next step
        function (next, value1, value2) {
            t.is(value1, 'foo', 'The arguments for the callback are translated to the arguments of the step')
            t.is(value2, 'bar', 'The arguments for the callback are translated to the arguments of the step')
        }
    )

         * 
         * The same example, using action configuration objects for first 2 steps. For the list of available actions 
         * please refer to the classes in the `Siesta.Test.Action` namespace.
         
    t.chain(
        {
            action      : 'click',
            target      : buttonEl,
            desc        : "Clicked on the button"
        },
        // or
        {
            click       : buttonEl,
            desc        : "Clicked on the button"
        },

        {
            action      : 'type',
            target      : fieldEl,
            text        : 'Something',
            desc        : "Typed in the field"
        },
        // or
        {
            type        : 'Something',
            target      : fieldEl,
            desc        : "Typed in the field"
        },
        
        {
            waitFor     : 'Selector',
            args        : '.selector'
        }
        // or, using Siesta.Test.Action.MethodCall notation:
        {
            waitForSelector : '.selector'
        }
        
        function (next) {
            t.is(fieldEl.value == 'Something', 'Correct value in the field')
            
            next('foo', 'bar')  
        }, 
        ...
    )
    
         * Please note, that by default, each step is expected to complete within the {@link Siesta.Harness#defaultTimeout} time. 
         * You can change this with the `timeout` property of the step configuration object, allowing some steps to last longer.
         * Steps with sub-tests are expected to complete within {@link Siesta.Harness#subTestTimeout}.
         * 
         * In a special case, `action` property of the step configuration object can be a function. In this case you can also 
         * provide a `timeout` property, otherwise this case is identical to using functions:
         *  

    t.chain(
        {
            action      : function (next) { ... },
            // allow 50s for the function to call "next" before step will be considered timed-out
            timeout     : 50000
        },
        ...
    )
    
         *  **Tip**:
         *  
         *  If a step is presented with a `null` or `undefined` value it will be ignored. Additionally, a step can be
         *  an array of steps - all arrays passed to t.chain will be flattened.
         *  
         *  These tips allows us to implement conditional steps processing, like this:
         *  

    var el1IsInDom          = t.$('.some-class1')[ 0 ]
    var el2IsInDom          = t.$('.some-class2')[ 0 ]
    
    t.chain(
        { click : '.some-other-el' },
        
        el1IsInDom ? [
            { click : el1IsInDom },
            
            el2IsInDom ? [
                { click : el1IsInDom }
            ] : null,
        ] : null,
        
        ...
    )

         *
         *  See also : {@link #chainForArray}.
         *  
         *  @param {Function/Object/Array} step1 The function to execute or action configuration, or an array of steps
         *  @param {Function/Object} step2 The function to execute or action configuration
         *  @param {Function/Object} stepN The function to execute or action configuration
         */
        chain : function () {
            // inline any arrays in the arguments into one array
            var steps       = this.flattenArray(arguments)
            var R           = Siesta.Resource('Siesta.Test.More');

            var nonEmpty    = []
            Joose.A.each(steps, function (step) { if (step) nonEmpty.push(step) })
            
            steps           = nonEmpty
            
            var len         = steps.length
            
            // do nothing
            if (!len) return;
            
            var me          = this
            var self        = arguments.callee
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : self.hasOwnProperty('actionDelay') ? self.actionDelay : this.actionDelay,
                
                observeTest     : this
            })
            
            // hack to allow configuration of `actionDelay`...
            delete self.actionDelay
            
            var sourceLine  = me.getSourceLine();
            
            var args        = []
            
            Joose.A.each(steps, function (step, index) {
                
                var isLast      = index == len - 1
                
                queue.addAsyncStep({
                    processor : function (data) {
                        var initStep = function (stepHasOwnAsyncFrame) {
                            
                            if (!stepHasOwnAsyncFrame) {
                                var timeout     = step.timeout || me.defaultTimeout
                                
                                // + 100 to allow `waitFor` steps (which will be waiting the `timeout` time) to
                                // generate their own failures
                                var async       = me.beginAsync(timeout + 100, function () {
                                    me.fail(
                                        R.get('chainStepNotCompleted'),
                                        {
                                            sourceLine      : sourceLine,
                                            annotation      : R.get('stepNumber') + ': ' + (index + 1) + ' ' + R.get('oneBased') + (sourceLine ? ('\n' + R.get('atLine') + ': ' + sourceLine) : ''),
                                            ownTextOnly     : true
                                        }
                                    )
                                    
                                    return true
                                })
                            }
                            
                            return {
                                next    : function () {
                                    var self    = arguments.callee
                                    if (self.__CALLED__) me.fail(R.get('calledMoreThanOnce', { num : index + 1, line : sourceLine }))
                                    
                                    self.__CALLED__ = true
                                    
                                    if (!stepHasOwnAsyncFrame) me.endAsync(async)
                                    
                                    args        =  Array.prototype.slice.call(arguments);
                                    
                                    if (step.desc) me.pass(step.desc)
                                    
                                    data.next()
                                },
                                async   : async
                            }
                        }
                        
                        if (step instanceof Siesta.Test) {
                            me.launchSubTest(step, initStep(true).next)
                        } else if (me.typeOf(step) == 'Function' || me.typeOf(step.action) == 'Function') {
                            var func    = me.typeOf(step) == 'Function' ? step : step.action
                            
                            var stepInitData    = initStep(false)
                            
                            // if the last step is a function - then provide "null" as the "next" callback for it
                            args.unshift(isLast ? function () {} : stepInitData.next)
                            
                            if (!isLast && !me.analyzeChainStep(func)) me.fail(R.get('stepFn') + ' [' + func.toString() + '] ' + R.get('notUsingNext'))
                            
                            if (me.transparentEx)
                                func.apply(me, args)
                            else {
                                var e = me.getExceptionCatcher()(function () {
                                    func.apply(me, args)
                                })
                                
                                if (e !== undefined) {
                                    me.fail(R.get('chainStepEx'), { annotation : me.stringifyException(e) })
                                }
                            }
                            
                            // and finalize the async frame manually, as the "nextFunc" for last step will never be called
                            if (isLast) {
                                me.endAsync(stepInitData.async)
                                
                                if (step.desc) me.pass(step.desc)
                            }
                            
                        } else if (me.typeOf(step) == 'String') {
                            var action      = new Siesta.Test.Action.Eval({
                                actionString        : step,
                                next                : initStep(false).next,
                                test                : me
                            })
                            
                            action.process()
                            
                        } else {
                            var action      = Siesta.Test.ActionRegistry().create(step, me, args, initStep)
                            
                            action.process()
                        }
                    } 
                })
            })
            
            queue.run()
        },
        
        
        /**
         * This is a wrapper around the {@link #chain} method, which allows you to run the chain over the steps, generated from the elements
         * of some array. For example, if in some step of outer chain, we need to click the elements with ids, given as the array, we can do:
         *

    function (next) {
        var ids     = [ 'button-1', 'button-2', 'button-3' ]
        
        t.chainForArray(ids, function (elId) {
            return { click : '#' + elId }
        }, next)
    }
         * 
         * @param {Array} array An array with arbitrary elements
         * @param {Function} generator A function, which will be called for every element of the `array`. It should return
         * a chain step, generated from that element. This function can return an array of steps as well. If generator will return `null` or 
         * `undefined` nothing will be added to the chain.
         * @param {Function} generator.el An element of the `array`
         * @param {Function} generator.index An index of the element
         * @param {Function} [callback] A function to call, once the chain is completed.
         */
        chainForArray : function (array, generator, callback, reverse) {
            var me          = this
            var steps       = []
            
            Joose.A[ reverse ? 'eachR' : 'each' ](array, function (el, index) {
                var res     = generator.call(me, el, index)
                
                if (me.typeOf(res) == 'Array') 
                    steps.push.apply(steps, res)
                else
                    if (res) steps.push(res)
            })
            
            if (callback) steps.push(function () {
                me.processCallbackFromTest(callback)
            })
            
            this.chain(steps)
        },
        
        
        verifyExpectedNumber : function (actual, expected) {
            var operator        = '=='
            
            if (this.typeOf(expected) == 'String') {
                var match       = /([<>=]=?)\s*(\d+)/.exec(expected)
                var R               = Siesta.Resource('Siesta.Test.Browser');

                if (!match) throw new Error(R.get('wrongFormat')  + ": " + expected)
                
                operator        = match[ 1 ]
                expected        = Number(match[ 2 ])
            }
            
            switch (operator) {
                case '==' : return actual == expected
                case '<=' : return actual <= expected
                case '>=' : return actual >= expected
                case '<' : return actual < expected
                case '>' : return actual > expected
            }
        },

        
        getMaximalTimeout : function () {
            return Math.max(this.waitForTimeout, this.defaultTimeout, this.subTestTimeout, this.timeout || 0, this.isReadyTimeout)
        }        
    },
    
    
    after : {
        
        onBeforeTestFinalize : function () {
            if (this.autoCheckGlobals && !this.isFailed() && !this.parent) this.verifyGlobals()
        }
    }
})
//eof Siesta.Test.More
;
Role('Siesta.Test.Role.Placeholder', {
    
    requires    : [
        'equalsTo'
    ]
})
;
/**
@class Siesta.Test.BDD.Spy

This class implements a "spy" - function wrapper which tracks the calls to itself. Spy can be installed
instead of a method in some object or can be used standalone.

Note, that spies "belongs" to a spec and once the spec is completed all spies that were installed during it
will be removed. 

*/
Class('Siesta.Test.BDD.Spy', {
    
    does        : [
        Siesta.Util.Role.CanGetType
    ],

    has         : {
        name                    : null,
        
        processor               : {
            lazy        : 'this.buildProcessor'
        },
        
        hostObject              : null,
        propertyName            : null,
        
        hasOwnOriginalValue     : false,
        originalValue           : null,
        
        strategy                : 'returnValue',
        
        returnValueObj          : undefined,
        fakeFunc                : null,
        throwErrorObj           : null,
        
        // array of { object : scope, args : [], returnValue : }
        callsLog                : Joose.I.Array,
        
        /**
         * @property {Object} calls This is an object property with several helper methods, related to the calls 
         * tracking information. It is assigned to the wrapper function of spy.
         * 
         * @property {Function} calls.any Returns `true` if spy was called at least once, `false` otherwise
         * @property {Function} calls.count Returns the number of times this spy was called
         * @property {Function} calls.argsFor Accepts an number of the call (0-based) and return an array of arguments 
         * for that call. 
         * @property {Function} calls.allArgs Returns an array with the arguments for every tracked function call. 
         * Every element of the array is, in turn, an array of arguments. 
         * @property {Function} calls.all Returns an array with the context for every tracked function call. 
         * Every element of the array is an object of the following structure:

    { object : this, args : [ 0, 1, 2 ], returnValue : undefined }

         * @property {Function} calls.mostRecent Returns a context object of the most-recent tracked function call. 
         * @property {Function} calls.first Returns a context object of the first tracked function call. 
         * @property {Function} calls.reset Reset all tracking data.
         *
         * 
         * Example:

    t.spyOn(obj, 'someMethod').callThrough()
    
    obj.someMethod(0, 1)
    obj.someMethod(1, 2)
    
    t.expect(obj.someMethod.calls.any()).toBe(true)
    t.expect(obj.someMethod.calls.count()).toBe(2)
    t.expect(obj.someMethod.calls.first()).toEqual({ object : obj, args : [ 0, 1 ], returnValue : undefined })

         */
        calls                   : null,
        
        t                       : null,
        
        /**
         * @property {Siesta.Test.BDD.Spy} and This is just a reference to itself, to add some syntax sugar. 
         * 
         * This property is also assigned to the wrapper function of spy.
         * 

    t.spyOn(obj, 'someMethod').callThrough()

    // same thing as above
    t.spyOn(obj, 'someMethod').and.callThrough()
    
    // returns spy instance
    obj.someMethod.and 

         */
        and                     : function () { return this }
    },
    
    
    methods     : {
        
        initialize : function () {
            var me              = this
            
            this.calls          = {
                any         : function () { return me.callsLog.length > 0 },
                count       : function () { return me.callsLog.length },
                argsFor     : function (i) { return me.callsLog[ i ].args },
                
                allArgs     : function (i) { return Joose.A.map(me.callsLog, function (call) { return call.args } ) },
                all         : function () { return me.callsLog },
                
                mostRecent  : function () { return me.callsLog[ me.callsLog.length - 1 ] },
                first       : function () { return me.callsLog[ 0 ] },
                
                reset       : function () { me.reset() }
            }
            
            var R       = Siesta.Resource('Siesta.Test.BDD.Spy')
            
            var hostObject      = this.hostObject
            var propertyName    = this.propertyName
            
            if (hostObject) {
                if (this.typeOf(hostObject[ propertyName ]) != 'Function') throw R.get("spyingNotOnFunction")
                
                this.hasOwnOriginalValue    = hostObject.hasOwnProperty(propertyName)
                this.originalValue          = hostObject[ propertyName ]
                
                if (this.originalValue.__SIESTA_SPY__) this.originalValue.__SIESTA_SPY__.remove()
                
                hostObject[ propertyName ]  = this.getProcessor()
            }
            
            if (this.t) this.t.spies.push(this)
        },
        
        
        buildProcessor : function () {
            var me          = this
            
            var processor   = function () {
                var args        = Array.prototype.slice.call(arguments)
                var log         = { object : this, args : args }
                
                me.callsLog.push(log)
                
                return log.returnValue = me[ me.strategy + 'Strategy' ](this, args) 
            }
            
            processor.__SIESTA_SPY__    = processor.and = me
            processor.calls             = me.calls
            
            return processor
        },
        
        
        returnValueStrategy : function (obj, args) {
            return this.returnValueObj
        },
        
        
        callThroughStrategy : function (obj, args) {
            return this.originalValue.apply(obj, args)
        },
        
        
        callFakeStrategy : function (obj, args) {
            return this.fakeFunc.apply(obj, args)
        },
        
        
        throwErrorStrategy : function (obj, args) {
            var error       = this.throwErrorObj
            var ERROR       = this.t && this.t.global ? this.t.global.Error : Error
            
            if (!(error instanceof ERROR)) error = new ERROR(error)
            
            throw error
        },
        
        
        /**
         * This method makes the spy to also execute the original function it has been installed over. The
         * value returned from original function is returned from the spy.
         * 
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        callThrough : function () {
            if (!this.hostObject) throw "Need the host object to call through to original method"
            
            this.strategy       = 'callThrough'
            
            return this
        },
        
        
        /**
         * This method makes the spy to just return `undefined` and not execute the original function.
         * 
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        stub : function () {
            this.returnValue()
            
            return this
        },
        
        
        /**
         * This method makes the spy to return the value provided and not execute the original function.
         * 
         * @param {Object} value The value that will be returned from the spy.
         * 
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        returnValue : function (value) {
            this.strategy       = 'returnValue'
            
            this.returnValueObj = value
            
            return this
        },

        
        /**
         * This method makes the spy to call the provided function and return the value from it, instead of the original function.
         * 
         * @param {Function} func The function to call instead of the original function
         * 
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        callFake : function (func) {
            this.strategy   = 'callFake'
            
            this.fakeFunc   = func
            
            return this
        },
        
        
        /**
         * This method makes the spy to throw the specified `error` value (instead of calling the original function).
         * 
         * @param {Object} error The error value to throw. If it is not an `Error` instance, it will be passed to `Error` constructor first.
         * 
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        throwError : function (error) {
            this.strategy       = 'throwError'
            
            this.throwErrorObj  = error
            
            return this
        },
        
        
        remove : function () {
            var hostObject      = this.hostObject
            
            if (hostObject) {
                if (this.hasOwnOriginalValue) 
                    hostObject[ this.propertyName ] = this.originalValue
                else
                    delete hostObject[ this.propertyName ]
            }
            
            // cleanup paranoya
            this.originalValue  = this.hostObject = hostObject = null
            this.callsLog       = []
            
            this.returnValueObj = this.fakeFunc = this.throwErrorObj = null
            
            var processor       = this.getProcessor()
            processor.and       = processor.calls   = processor.__SIESTA_SPY__ = null
            
            this.processor      = null
        },
        
        
        /**
         * This method resets all calls tracking data. Spy will report as it has never been called yet. 
         */
        reset : function () {
            this.callsLog      = []
        }
    }
})
;
Class('Siesta.Test.BDD.Placeholder', {
    
    does        : Siesta.Test.Role.Placeholder,
    
    has         : {
        clsConstructor  : { required : true },
        t               : null,
        context         : null,
        
        globals         : {
            init            : [
                'String',
                'Boolean',
                'Number',
                'Date',
                'RegExp',
                'Function',
                'Array',
                'Object'
            ]
        }
    },
    
    
    methods     : {
        
        getClassName : function (onlyGlobals) {
            var clsConstructor      = this.getClassConstructor()
            var context             = this.context

            var clsName
            
            Joose.A.each(this.globals, function (property) {
                if (clsConstructor == context[ property ]) { clsName = property; return false }    
            })
            
            return onlyGlobals ? clsName : clsName || (clsConstructor ? clsConstructor + '' : '')
        },
        
        
        getClassConstructor : function () {
            return this.clsConstructor
        },
        
        
        equalsTo : function (value) {
            var clsConstructor      = this.getClassConstructor()
            
            if (!clsConstructor) return true
            
            if (value instanceof Siesta.Test.BDD.Placeholder) {
                var ownClassName    = this.getClassName(true)
                
                if (
                    value.getClassName(true) == 'Object' && (
                        ownClassName == 'Date' ||
                        ownClassName == 'RegExp' ||
                        ownClassName == 'Function'||
                        ownClassName == 'Array'
                    )
                ) {
                    return true
                }
                
                return clsConstructor == value.getClassConstructor()
            }
            
            var isEqual             = false
            
            var globalCls           = this.getClassName(true)
            
            if (globalCls)
                isEqual             = this.t.typeOf(value) == globalCls || (value instanceof this.context[ globalCls ])
            
            return isEqual || (value instanceof clsConstructor)
        },
        
        
        toString : function () {
            return 'any ' + (this.getClassName() || 'value')
        }
    }
})
;
Class('Siesta.Test.BDD.NumberPlaceholder', {
    
    does        : Siesta.Test.Role.Placeholder,
    
    has         : {
        value           : { required : true },
        threshold       : null
    },
    
    
    methods     : {
        
        initialize : function () {
            if (this.threshold == null) this.threshold = this.value * 0.05
        },
        
        
        equalsTo : function (value) {
            return Math.abs(value - this.value) <= this.threshold
        },
        
        
        toString : function () {
            return 'any number approximately equal to ' + this.value
        }
    }
})
;
Class('Siesta.Test.BDD.StringPlaceholder', {
    
    does        : Siesta.Test.Role.Placeholder,
    
    has         : {
        value           : { required : true }
    },
    
    
    methods     : {
        
        equalsTo : function (string) {
            if (Object.prototype.toString(this.value) == '[object RegExp]')
                return this.value.test(string)
            else
                return String(string).indexOf(this.value) > -1
        },
        
        
        toString : function () {
            if (Object.prototype.toString(this.value) == '[object RegExp]')
                return 'any string matching: ' + this.value
            else
                return 'any string containing: ' + this.value
        }
    }
})
;
/**
@class Siesta.Test.BDD.Expectation

This class is the central point for writing assertions in BDD style. Instances of this class can be generated with the {@link Siesta.Test#expect expect}
method. Then, calling some method on the instance will create a new assertion in the test.

* **Note**, that to negate any assertion, you can use a special property {@link #not}, that contains an expectation instance with the opposite meaning.

For example:

    t.expect(1).toBe(1)
    t.expect(1).not.toBe(2)
    
    t.expect('Foo').toContain('oo')
    t.expect('Foo').not.toContain('bar')


*/
Class('Siesta.Test.BDD.Expectation', {
    
    does        : [
        Siesta.Util.Role.CanGetType
    ],

    has         : {
        value           : null,
        
        isNot           : false,
        
        /**
         * @property {Siesta.Test.BDD.Expectation} not Another expectation instance with the negated meaning. 
         */
        not             : null,
        
        t               : null
    },
    
    
    methods     : {
        
        initialize : function () {

            if (!this.isNot) this.not = new this.constructor({
                isNot           : true,
                t               : this.t,
                
                value           : this.value
            })
        },
        
        
        process : function (passed, config) {
            var isNot       = this.isNot
            config          = config || {}
            
            config.not      = config.not || isNot ? 'not ' : ''
            config.got      = config.hasOwnProperty('got') ? config.got : this.value
            
            if (config.noGot) delete config.got
            
            var assertionName   = config.assertionName
            
            if (assertionName && isNot) config.assertionName = assertionName.replace(/^(expect\(.+?\)\.)/, '$1not.')
            
            passed          = isNot ? !passed : passed
            
            this.t[ passed ? 'pass' : 'fail' ](null, config)
        },
        
        
        /**
         * This assertion compares the value provided to the {@link Siesta.Test#expect expect} method with the `expectedValue` argument.
         * Comparison is done with `===` operator, so it should be used only with the primitivies - numbers, strings, booleans etc.
         * To deeply compare JSON objects and arrays, use {@link #toEqual} method.
         * 
         * This method works correctly with the placeholders generated with {@link Siesta.Test#any any} method
         * 
         * @param {Primitive} expectedValue An expected value 
         */
        toBe : function (expectedValue) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.t.compareObjects(this.value, expectedValue, true, true), {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeText') + ' {need}',
                assertionName       : 'expect(got).toBe(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needNotText') : R.get('needText')
            })
        },
        
        
        /**
         * This assertion compares the value provided to the {@link Siesta.Test#expect expect} method with the `expectedValue` argument.
         * Comparison works for JSON objects and/or arrays, it is performed "deeply". Right now the values should not contain cyclic references.
         * 
         * This method works correctly with the placeholders generated with {@link Siesta.Test#any any} method
         * 
         * @param {Mixed} expectedValue An expected value 
         */
        toEqual : function (expectedValue) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.t.compareObjects(this.value, expectedValue, true), {
                descTpl             : R.get('expectText') +' {got} {!not}' + R.get('toBeEqualToText') + ' {need}',
                assertionName       : 'expect(got).toEqual(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needNotText') : R.get('needText')
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is `null`.
         */
        toBeNull : function () {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.t.compareObjects(this.value, null, true, true), {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeText') + ' null',
                assertionName       : 'expect(got).toBeNull()',
                need                : null,
                needDesc            : this.isNot ? R.get('needNotText') : R.get('needText')
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is `NaN`.
         */
        toBeNaN : function () {
            var value   = this.value
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.t.typeOf(value) == 'Number' && value != value, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeText') + ' NaN',
                assertionName       : 'expect(got).toBeNaN()',
                need                : NaN,
                needDesc            : this.isNot ? R.get('needNotText') : R.get('needText')
            })
        },

        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is not the `undefined` value.
         */
        toBeDefined : function () {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value !== undefined, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeDefinedText'),
                assertionName       : 'expect(got).toBeDefined()'
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is the `undefined` value.
         */
        toBeUndefined : function (value) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value === undefined, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeUndefinedText'),
                assertionName       : 'expect(got).toBeUndefined()'
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is "truthy" - evaluates to `true`.
         * For example - non empty strings, numbers except the 0, objects, arrays etc.
         */
        toBeTruthy : function () {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeTruthyText'),
                assertionName       : 'expect(got).toBeTruthy()'
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is "falsy" - evaluates to `false`.
         * For example - empty strings, number 0, `null`, `undefined`, etc.
         */
        toBeFalsy : function () {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(!this.value, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeFalsyText'),
                assertionName       : 'expect(got).toBeFalsy()'
            })
        },
        
        
        /**
         * This assertion passes, when the string provided to the {@link Siesta.Test#expect expect} method matches the regular expression.
         * 
         * @param {RegExp} regexp The regular expression to match the string against
         */
        toMatch : function (regexp) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            if (this.t.typeOf(regexp) != 'RegExp') throw new Error("`expect().toMatch()` matcher expects a regular expression")
            
            this.process(new RegExp(regexp).test(this.value), {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toMatchText') + ' {need}',
                assertionName       : 'expect(got).toMatch(need)',
                need                : regexp,
                needDesc            : this.isNot ? R.get('needNotMatchingText') : R.get('needMatchingText')
            })
        },
        
        
        /**
         * This assertion passes in 2 cases:
         * 
         * 1) When the value provided to the {@link Siesta.Test#expect expect} method is a string, and it contains a passed substring.
         * 2) When the value provided to the {@link Siesta.Test#expect expect} method is an array (or array-like), and it contains a passed element.
         * 
         * @param {String/Mixed} element The element of the array or a sub-string
         */
        toContain : function (element) {
            var value       = this.value
            var t           = this.t
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            var passed      = false

            if (t.typeOf(value) == 'String') {
                this.process(value.indexOf(element) >= 0, {
                    descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toContainText') + ' {need}',
                    assertionName       : 'expect(got).toContain(need)',
                    need                : element,
                    needDesc            : this.isNot ? R.get('needStringNotContainingText') : R.get('needStringContainingText')
                })
            } else {
                // Normalize to allow NodeList, Arguments etc.
                value = Array.prototype.slice.call(value);

                for (var i = 0; i < value.length; i++)
                    if (t.compareObjects(element, value[ i ], true)) {
                        passed      = true
                        break
                    }

                this.process(passed, {
                    descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toContainText') + ' {need}',
                    assertionName       : 'expect(got).toContain(need)',
                    need                : element,
                    needDesc            : this.isNot ? R.get('needArrayNotContainingText') : R.get('needArrayContainingText')
                })

            }
        },
        
        
        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is less than the
         * expected number.
         * 
         * @param {Number} expectedValue The number to compare with
         */
        toBeLessThan : function (expectedValue) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value < expectedValue, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeLessThanText') + ' {need}',
                assertionName       : 'expect(got).toBeLessThan(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needGreaterEqualThanText') : R.get('needLessThanText')
            })
        },
        
        
        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is greater than the
         * expected number.
         * 
         * @param {Number} expectedValue The number to compare with
         */
        toBeGreaterThan : function (expectedValue) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value > expectedValue, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeGreaterThanText') + ' {need}',
                assertionName       : 'expect(got).toBeGreaterThan(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needLessEqualThanText') : R.get('needGreaterThanText')
            })
        },
        
        
        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is approximately equal
         * the given number. The proximity can be defined as the `precision` argument  
         * 
         * @param {Number} expectedValue The number to compare with
         * @param {Number} [precision=2] The number of digits after dot (comma) that should be same in both numbers.
         */
        toBeCloseTo : function (expectedValue, precision) {
            precision       = precision != null ? precision : 2
            
            // not sure why we divide the precision by 2, but jasmine does that for some reason
            var threshold   = Math.pow(10, -precision) / 2
            var delta       = Math.abs(this.value - expectedValue)
            var R           = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(delta < threshold, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeCloseToText') +' {need}',
                assertionName       : 'expect(got).toBeCloseTo(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needValueNotCloseToText') : R.get('needValueCloseToText'),
                annotation          : delta ? R.get('thresholdIsText') + threshold : R.get('exactMatchText')
            })        
        },
        
        
        /**
         * This assertion passes when the function provided to the {@link Siesta.Test#expect expect} method, throws an exception
         * during its execution.
         *
         * t.expect(function(){
         *     throw "oopsie";
         * }).toThrow());
         *
         */
        toThrow : function () {
            var func    = this.value
            var t       = this.t
            var R       = Siesta.Resource('Siesta.Test.BDD.Expectation');

            if (t.typeOf(func) != 'Function') throw new Error("`expect().toMatch()` matcher expects a function")
            
            var e       = t.getExceptionCatcher()(func)
            
            if (e instanceof t.getTestErrorClass())
                //IE uses non-standard 'description' property for error msg
                e = e.message || e.description
                
            this.process(e !== undefined, {
                descTpl             : R.get('expectText') + ' function {!not}' + R.get('toThrowText'),
                assertionName       : 'expect(func).toThrow()',
                annotation          : e ? (R.get('thrownExceptionText') + ': ' + Siesta.Util.Serializer.stringify(e)) : R.get('noExceptionThrownText'),
                
                noGot               : true
            })
        },
        
        
        /**
         * This assertion passes, if a spy, provided to the {@link Siesta.Test#expect expect} method have been 
         * called expected number of times. The expected number of times can be provided as the 1st argument and by default
         * is 1.
         * 
         * One can also provide the function, spied on, to the {@link Siesta.Test#expect expect} method.
         * 
         * Examples:
         * 
    var spy = t.spyOn(obj, 'process')
    
    // call the method 2 times
    obj.process()
    obj.process()

    // following 2 calls are equivalent
    t.expect(spy).toHaveBeenCalled();
    t.expect(obj.process).toHaveBeenCalled();
    
    // one can also use exact number of calls or comparison operators
    t.expect(obj.process).toHaveBeenCalled(2);
    t.expect(obj.process).toHaveBeenCalled('>1');
    t.expect(obj.process).toHaveBeenCalled('<3');

         * 
         * See also {@link #toHaveBeenCalledWith}
         * 
         * @param {Number/String} expectedNumber Expected number of calls. Can be either a number, specifying the exact
         * number of calls, or a string. In the latter case one can include a comparison operator in front of the number.
         * 
         */
        toHaveBeenCalled : function (expectedNumber) {
            expectedNumber  = expectedNumber != null ? expectedNumber : '>=1'
            
            var spy         = this.value
            var t           = this.t
            var R           = Siesta.Resource('Siesta.Test.BDD.Expectation');

            if (this.typeOf(spy) == 'Function') {
                if (!spy.__SIESTA_SPY__) throw new Error(R.get('wrongSpy'))
                
                spy         = spy.__SIESTA_SPY__
            }
            
            if (!(spy instanceof Siesta.Test.BDD.Spy)) throw new Error(R.get('wrongSpy'))
            
            this.process(t.verifyExpectedNumber(spy.callsLog.length, expectedNumber), {
                descTpl             : R.get('toHaveBeenCalledDescTpl'),
                assertionName       : 'expect(func).toHaveBeenCalled()',
                methodName          : spy.propertyName,
                got                 : spy.callsLog.length,
                gotDesc             : R.get('actualNbrOfCalls'),
                need                : expectedNumber,
                needDesc            : R.get('expectedNbrOfCalls')
            })
        },
        
        
        /**
         * This assertion passes, if a spy, provided to the {@link Siesta.Test#expect expect} method have been 
         * called at least once with the specified arguments. 
         * 
         * One can also provide the function, spied on, to the {@link Siesta.Test#expect expect} method.
         * 
         * One can use placeholders, generated with the {@link Siesta.Test.BDD#any any} method to verify the arguments.
         * 
         * Example:
         * 

    var spy = t.spyOn(obj, 'process')
    
    // call the method 2 times with different arguments
    obj.build('development', '1.0.0')
    obj.build('release', '1.0.1')

    t.expect(spy).toHaveBeenCalledWith('development', '1.0.0');
    // or
    t.expect(obj.process).toHaveBeenCalledWith('development', t.any(String));

         * 
         * See also {@link #toHaveBeenCalled}
         * 
         * @param {Object} arg1 Argument to a call
         * @param {Object} arg2 Argument to a call
         * @param {Object} argN Argument to a call
         */
        toHaveBeenCalledWith : function () {
            var spy         = this.value
            var t           = this.t
            var R           = Siesta.Resource('Siesta.Test.BDD.Expectation');

            if (this.typeOf(spy) == 'Function') {
                if (!spy.__SIESTA_SPY__) throw new Error(R.get('wrongSpy'))
                
                spy         = spy.__SIESTA_SPY__
            }
            
            if (!(spy instanceof Siesta.Test.BDD.Spy)) throw new Error(R.get('wrongSpy'))
            
            var args                        = Array.prototype.slice.call(arguments)
            var foundCallWithMatchingArgs   = false
            
            Joose.A.each(spy.callsLog, function (call) {
                if (t.compareObjects(call.args, args)) { foundCallWithMatchingArgs = true; return false }
            })
            
            this.process(foundCallWithMatchingArgs, {
                descTpl             : R.get('toHaveBeenCalledWithDescTpl'),
                assertionName       : 'expect(func).toHaveBeenCalledWith()',
                methodName          : spy.propertyName,
                noGot               : true
            })
        }
    }
})
;
/**
@class Siesta.Test.BDD

A mixin providing a BDD style layer for most of the assertion methods.
It is consumed by {@link Siesta.Test}, so all of its methods are available in all tests. 

*/
Role('Siesta.Test.BDD', {
    
    requires    : [
        'getSubTest', 'chain'
    ],
    
    has         : {
        specType                : null, // `describe` or `it`
        
        beforeEachHooks         : Joose.I.Array,
        afterEachHooks          : Joose.I.Array,
        
        sequentialSubTests      : Joose.I.Array,
        
        // flag, whether the "run" function of the test (containing actual test code) have been already run
        codeProcessed           : false,
        
        launchTimeout           : null,
        
        // Siesta.Test.BDD.Expectation should already present on the page
        expectationClass        : Siesta.Test.BDD.Expectation,
        
        failOnExclusiveSpecsWhenAutomated   : false,
        
        spies                   : Joose.I.Array
    },
    
    
    methods     : {
        
        checkSpecFunction : function (func, type, name) {
            if (!func)          throw new Error(Siesta.Resource('Siesta.Test.BDD', 'codeBodyMissing') + " " + (type == 'describe' ? 'suite' : 'spec') + ' [' + name + ']')
            if (!func.length)   throw new Error(Siesta.Resource('Siesta.Test.BDD', 'codeBodyOf') + " " + (type == 'describe' ? 'suite' : 'spec') + ' [' + name + '] ' + Siesta.Resource('Siesta.Test.BDD', 'missingFirstArg'))
        },
        
        
        /**
         * This is an "exclusive" version of the regular {@link #describe} suite. When such suites presents in some test file,
         * the other regular suites at the same level will not be executed, only "exclusive" ones.
         * 
         * @param {String} name The name or description of the suite
         * @param {Function} code The code function for this suite. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this suite. If not provided {@link Siesta.Harness#subTestTimeout} value is used.
         */
        ddescribe : function (name, code, timeout) {
            this.describe(name, code, timeout, true)
        },
        
        
        /**
         * This is a no-op method, allowing you to quickly ignore some suites. 
         */
        xdescribe : function () {
        },
        
        
        /**
         * This method starts a sub test with *suite* (in BDD terms). Such suite consists from one or more *specs* (see method {@link #it}} or other suites.
         * The number of nesting levels is not limited. All suites of the same nesting level are executed sequentially. 
         * 
         * For example:
         * 
    t.describe('A product', function (t) {
    
        t.it('should have feature X', function (t) {
            ...
        })
        
        t.describe('feature X', function (t) {
            t.it('should be cool', function (t) {
                ...
            })
        })
    })
         *
         * See also {@link #beforeEach}, {@link #afterEach}, {@link #xdescribe}, {@link #ddescribe}
         * 
         * @param {String} name The name or description of the suite
         * @param {Function} code The code function for this suite. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this suite. If not provided {@link Siesta.Harness#subTestTimeout} value is used.
         */
        describe : function (name, code, timeout, isExclusive) {
            this.checkSpecFunction(code, 'describe', name)
            
            var subTest     = this.getSubTest({
                name            : name,
                run             : code,
                
                isExclusive     : isExclusive,
                
                specType        : 'describe',
                timeout         : timeout
            })
            
            if (this.codeProcessed) this.scheduleSpecsLaunch()
            
            this.sequentialSubTests.push(subTest)
        },
        
        
        /**
         * This is an "exclusive" version of the regular {@link #it} spec. When such specs presents in some suite,
         * the other regular specs at the same level will not be executed, only "exclusive" ones. Note, that even "regular" suites (`t.describe`) sections
         * will be ignored, if they are on the same level with the exclusive `iit` section.
         * 
         * @param {String} name The name or description of the spec
         * @param {Function} code The code function for this spec. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this spec. If not provided {@link Siesta.Harness#subTestTimeout} value is used.
         */
        iit : function (name, code, timeout) {
            if (this.harness.isAutomated) {
                if (this.failOnExclusiveSpecsWhenAutomated) this.fail(Siesta.Resource('Siesta.Test.BDD', 'iitFound'));
            }
            this.it(name, code, timeout, true)
        },
        
        
        /**
         * This is a no-op method, allowing you to quickly ignore some specs. 
         */
        xit : function () {
        },
        
        
        /**
         * This method starts a sub test with *spec* (in BDD terms). Such spec consists from one or more assertions (or *expectations*, *matchers*, etc) or other nested specs
         * and/or suites. See the {@link #expect} method. The number of nesting levels is not limited. All specs of the same nesting level are executed sequentially. 
         * 
         * For example:
         * 
    t.describe('A product', function (t) {
    
        t.it('should have feature X', function (t) {
            ...
        })
        
        t.it('should have feature Y', function (t) {
            ...
        })
    })
         *
         * See also {@link #beforeEach}, {@link #afterEach}, {@link #xit}, {@link #iit}
         * 
         * @param {String} name The name or description of the spec
         * @param {Function} code The code function for this spec. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this spec. If not provided {@link Siesta.Harness#subTestTimeout} value is used.
         */
        it : function (name, code, timeout, isExclusive) {
            this.checkSpecFunction(code, 'it', name)
            
            var subTest     = this.getSubTest({
                name            : name,
                run             : code,
                
                isExclusive     : isExclusive,
                
                specType        : 'it',
                timeout         : timeout
            })
            
            if (this.codeProcessed) this.scheduleSpecsLaunch()
            
            this.sequentialSubTests.push(subTest)
        },
        
        
        /**
         * This method returns an "expectation" instance, which can be used to check various assertions about the passed value.
         * 
         * **Note**, that every expectation has a special property `not`, that contains another expectation, but with the negated meaning.
         * 
         * For example:
         * 

    t.expect(1).toBe(1)
    t.expect(1).not.toBe(2)
    
    t.expect('Foo').toContain('oo')
    t.expect('Foo').not.toContain('bar')
 
 
         * Please refer to the documentation of the {@link Siesta.Test.BDD.Expectation} class for the list of available methods.
         * 
         * @param {Mixed} value Any value, that will be assert about
         * @return {Siesta.Test.BDD.Expectation} Expectation instance
         */
        expect : function (value) {
            return new this.expectationClass({
                t           : this,
                value       : value
            })
        },
        
        
        /**
         * This method returns a *placeholder*, denoting any instance of the provided class constructor. Such placeholder can be used in various
         * comparison assertions, like {@link #is}, {@link #isDeeply}, {@link Siesta.Test.BDD.Expectation#toBe expect().toBe()}, 
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toEqual()} and so on.
         * 
         * For example:

    t.is(1, t.any(Number))
    
    t.expect(1).toBe(t.any(Number))
    
    t.isDeeply({ name : 'John', age : 45 }, { name : 'John', age : t.any(Number))
    
    t.expect({ name : 'John', age : 45 }).toEqual({ name : 'John', age : t.any(Number))
    
    t.is(NaN, t.any(), 'When class constructor is not provided `t.any()` should match anything')

         * 
         * See also {@link #anyNumberApprox}, {@link #anyStringLike}.
         * 
         * @param {Function} clsConstructor A class constructor instances of which are denoted with this placeholder. As a special case if this argument
         * is not provided, a placeholder will match any value. 
         * 
         * @return {Object} A placeholder object
         */
        any : function (clsConstructor) {
            return new Siesta.Test.BDD.Placeholder({
                clsConstructor      : clsConstructor,
                t                   : this,
                context             : this.global
            })
        },
        
        /**
         * This method returns a *placeholder*, denoting any number approximately equal to the provided value. 
         * Such placeholder can be used in various comparison assertions, like {@link #is}, {@link #isDeeply}, 
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toBe()}, 
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toEqual()} and so on.
         * 
         * For example:

    t.is(1, t.anyNumberApprox(1.2, 0.5))
    
    t.expect(1).toBe(t.anyNumberApprox(1.2, 0.5))
    
         * 
         * @param {Number} value The approximate value
         * @param {Number} [threshold] The threshold. If omitted, it is set to 5% from the `value`.
         *  
         * @return {Object} A placeholder object
         */
        anyNumberApprox : function (value, threshold) {
            return new Siesta.Test.BDD.NumberPlaceholder({
                value               : value,
                threshold           : threshold
            })
        },
        
        
        /**
         * This method returns a *placeholder*, denoting any string that matches provided value. 
         * Such placeholder can be used in various comparison assertions, like {@link #is}, {@link #isDeeply},
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toBe()}, 
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toEqual()} and so on.
         * 
         * For example:

    t.is('foo', t.anyStringLike('oo'))
    
    t.expect('bar').toBe(t.anyStringLike(/ar$/))
    
         * 
         * @param {String/RegExp} value If given as string will denote a substring a string being checked should contain,
         * if given as RegExp instance then string being checked should match this RegExp
         *  
         * @return {Object} A placeholder object
         */
        anyStringLike : function (value) {
            return new Siesta.Test.BDD.StringPlaceholder({ value : value })
        },
        
        
        scheduleSpecsLaunch : function () {
            if (this.launchTimeout) return
            
            var async                   = this.beginAsync()
            var originalSetTimeout      = this.originalSetTimeout
            var me                      = this
            
            this.launchTimeout          = originalSetTimeout(function () {
                me.endAsync(async)
                me.launchTimeout        = null
                
                me.launchSpecs()
            }, 0)
        },
        
        
        runBeforeSpecHooks : function (sourceTest, done) {
            var me          = this
            
            var runOwnHooks = function (done) {
                me.chainForArray(me.beforeEachHooks, function (hook) {
                    return function (next) {
                        var code        = hook.code
                        
                        if (hook.isAsync) {
                            code(sourceTest, next)
                        } else {
                            code(sourceTest)
                            next()
                        }
                    }
                }, done)                    
            }
            
            if (this.parent)
                this.parent.runBeforeSpecHooks(sourceTest, function () {
                    runOwnHooks(done)
                })
            else
                runOwnHooks(done)
        },
                
            
        runAfterSpecHooks : function (sourceTest, done) {
            var me      = this
            
            me.chainForArray(
                this.afterEachHooks, function (hook) {
                    return function (next) {
                        var code        = hook.code
                        
                        if (hook.isAsync) {
                            code(sourceTest, next)
                        } else {
                            code(sourceTest)
                            next()
                        }
                    }
                }, function () {
                    me.parent ? me.parent.runAfterSpecHooks(sourceTest, done) : done()
                },
                // reverse
                true
            )
        },
        
        
        launchSpecs : function () {
            var me                  = this
            var sequentialSubTests  = this.sequentialSubTests
            
            this.sequentialSubTests = []
            
            // hackish way to pass a config to `t.chain`
            this.chain.actionDelay  = 0
            
            var exclusiveSubTests   = []
            
            Joose.A.each(sequentialSubTests, function (subTest) {
                if (subTest.isExclusive) exclusiveSubTests.push(subTest)
            })
            
            this.chainForArray(exclusiveSubTests.length ? exclusiveSubTests : sequentialSubTests, function (subTest) {
                return [
                    subTest.specType == 'it' ? function (next) { me.runBeforeSpecHooks(subTest, next) } : null,
                    subTest,
                    subTest.specType == 'it' ? function (next) { me.runAfterSpecHooks(subTest, next) } : null
                ]
            })
        },
        
        
        /**
         * This method allows you to execute some "setup" code hook before every spec ("it" block) of the current test. 
         * Such hooks are **not** executed for the "describe" blocks and sub-tests generated with 
         * the {@link Siesta.Test#getSubTest getSubTest} method.
         * 
         * Note, that specs can be nested and all `beforeEach` hooks are executed in order, starting from the outer-most one.
         * 
         * The hook function can be declared with 1 or 2 arguments. The 1st argument is always the test 
         * instance being launched.
         * 
         * If hook is declared with only 1 argument - it is supposed to be synchronous. 
         * 
         * If hook is declared with 2 arguments - it is supposed to be asynchronous (you can also force the asynchronous
         * mode with the `isAsync` argument, see below). The completion callback will be provided as the 2nd argument for the hook.
         *  
         * This method can be called several times, providing several "hook" functions.
         * 
         * For example:

    StartTest(function (t) {
        var baz     = 0
        
        t.beforeEach(function (t) {
            // the `t` instance here is the "t" instance from the "it" block below
            baz     = 0
        })
        
        t.it("This feature should work", function (t) {
            t.expect(myFunction(baz++)).toEqual('someResult')
        })
    })

         * 
         * @param {Function} code A function to execute before every spec
         * @param {Siesta.Test} code.t A test instance being launched
         * @param {Function} code.next A callback to call when the `beforeEach` method completes. This argument is only provided
         * when hook function is declared with 2 arguments (or the `isAsync` argument is passed as `true`)
         * @param {Boolean} isAsync When passed as `true` this argument makes the `beforeEach` method asynchronous. In this case,
         * the `code` function will receive an additional callback argument, which should be called once the method has completed its work.
         * 
         * Note, that `beforeEach` method should complete within {@link Siesta.Test#defaultTimeout defaultTimeout} time, otherwise
         * failing assertion will be added to the test. 
         * 
         * Example of asynchronous hook:

    StartTest(function (t) {
        var baz     = 0
    
        // asynchronous setup code
        t.beforeEach(function (t, next) {
            
            // `beforeEach` will complete in 100ms 
            setTimeout(function () {
                baz     = 0
                next()
            }, 100)
        })
        
        t.describe("This feature should work", function (t) {
            t.expect(myFunction(baz++)).toEqual('someResult')
        })
    })

         */
        beforeEach : function (code, isAsync) {
            this.beforeEachHooks.push({ code : code, isAsync : isAsync || code.length == 2 })
        },
        
        
        /**
         * This method allows you to execute some "setup" code hook after every spec ("it" block) of the current test. 
         * Such hooks are **not** executed for the "describe" blocks and sub-tests generated with 
         * the {@link Siesta.Test#getSubTest getSubTest} method.
         * 
         * Note, that specs can be nested and all `afterEach` hooks are executed in order, starting from the most-nested one.
         * 
         * The hook function can be declared with 1 or 2 arguments. The 1st argument is always the test 
         * instance being launched.
         * 
         * If hook is declared with only 1 argument - it is supposed to be synchronous. 
         * 
         * If hook is declared with 2 arguments - it is supposed to be asynchronous (you can also force the asynchronous
         * mode with the `isAsync` argument, see below). The completion callback will be provided as the 2nd argument for the hook.
         *  
         * This method can be called several times, providing several "hook" functions.
         * 
         * For example:

    StartTest(function (t) {
        var baz     = 0
        
        t.afterEach(function (t) {
            // the `t` instance here is the "t" instance from the "it" block below
            baz     = 0
        })
        
        t.it("This feature should work", function (t) {
            t.expect(myFunction(baz++)).toEqual('someResult')
        })
    })

         * 
         * @param {Function} code A function to execute after every spec
         * @param {Siesta.Test} code.t A test instance being completed
         * @param {Function} code.next A callback to call when the `afterEach` method completes. This argument is only provided
         * when hook function is declared with 2 arguments (or the `isAsync` argument is passed as `true`)
         * @param {Boolean} isAsync When passed as `true` this argument makes the `afterEach` method asynchronous. In this case,
         * the `code` function will receive an additional callback argument, which should be called once the method has completed its work.
         * 
         * Note, that `afterEach` method should complete within {@link Siesta.Test#defaultTimeout defaultTimeout} time, otherwise
         * failing assertion will be added to the test. 
         * 
         * Example of asynchronous hook:

    StartTest(function (t) {
        var baz     = 0
    
        // asynchronous setup code
        t.afterEach(function (t, next) {
            
            // `afterEach` will complete in 100ms 
            setTimeout(function () {
                baz     = 0
                next()
            }, 100)
        })
        
        t.describe("This feature should work", function (t) {
            t.expect(myFunction(baz++)).toEqual('someResult')
        })
    })

         */
        afterEach : function (code, isAsync) {
            this.afterEachHooks.push({ code : code, isAsync : isAsync || code.length == 2 })
        },
        

        /**
         * This method installs a "spy" instead of normal function in some object. The "spy" is basically another function,
         * which tracks the calls to itself. With spies, one can verify that some function was called and that
         * it was called with certain arguments.
         * 
         * Note, that by default, spy will not call the original method. To enable that, use {@link Siesta.Test.BDD.Spy#callThrough} method.
         * 

    var spy = t.spyOn(obj, 'process')
    // or, if you need to call the original 'process' method
    var spy = t.spyOn(obj, 'process').and.callThrough()
    
    // call the method
    obj.process('fast', 1)

    t.expect(spy).toHaveBeenCalled();
    t.expect(spy).toHaveBeenCalledWith('fast', 1);

         *
         * See also {@link #createSpy}, {@link #createSpyObj}, {@link Siesta.Test.BDD.Expectation#toHaveBeenCalled toHaveBeenCalled}, 
         * {@link Siesta.Test.BDD.Expectation#toHaveBeenCalledWith toHaveBeenCalledWith}
         * 
         * See also the {@link Siesta.Test.BDD.Spy} class for additional details.
         * 
         * @param {Object} object An object which property is being spied
         * @param {String} propertyName A name of the property over which to install the spy. 
         * 
         * @return {Siesta.Test.BDD.Spy} spy Created spy instance
         */
        spyOn : function (object, propertyName) {
            var R       = Siesta.Resource('Siesta.Test.BDD')
            
            if (!object) { this.warn(R.get('noObject')); return; }
            
            return new Siesta.Test.BDD.Spy({
                name            : propertyName,
                
                t               : this,
                hostObject      : object,
                propertyName    : propertyName
            })
        },
        
        /**
         * This method create a standalone spy function, which tracks all calls to it. Tracking is done using the associated 
         * spy instance, which is available as `and` property. One can use the {@link Siesta.Test.BDD.Spy} class API to
         * verify the calls to the spy function.
         * 
         * Example:

    var spyFunc     = t.createSpy('onadd listener')
    
    myObservable.addEventListener('add', spyFunc)
    
    // do something that triggers the `add` event on the `myObservable`

    t.expect(spyFunc).toHaveBeenCalled()
    
    t.expect(spyFunc.calls.argsFor(1)).toEqual([ 'Arg1', 'Arg2' ])
    
         * 
         * See also: {@link #spyOn}
         * 
         * @param {String} [spyName='James Bond'] A name of the spy for debugging purposes
         * 
         * @return {Function} Created function. The associated spy instance is assigned to it as the `and` property 
         */
        createSpy : function (spyName) {
            return (new Siesta.Test.BDD.Spy({
                name            : spyName || 'James Bond',
                t               : this
            })).getProcessor()
        },
        
        
        /**
         * This method creates an object, which properties are spy functions. Such object can later be used as a mockup.
         * 
         * This method can be called with one argument only, which should be an array of properties.
         * 
         * Example:

    var mockup      = t.createSpyObj('encoder-mockup', [ 'encode', 'decode' ])
    // or just
    var mockup      = t.createSpyObj([ 'encode', 'decode' ])
    
    mockup.encode('string')
    mockup.decode('string')
    
    t.expect(mockup.encode).toHaveBeenCalled()
    

         * 
         * See also: {@link #createSpy}
         * 
         * @param {String} spyName A name of the spy object. Can be omitted.
         * @param {Array[String]} properties An array of the property names. For each property name a spy function will be created.
         * 
         * @return {Object} A mockup object
         */
        createSpyObj : function (spyName, properties) {
            if (arguments.length == 1) { properties = spyName; spyName = null }
            
            spyName     = spyName || 'spyObject'
            
            var me      = this
            var obj     = {}
            
            Joose.A.each(properties, function (propertyName) {
                obj[ propertyName ] = me.createSpy(spyName) 
            })
            
            return obj
        }
    },
    
    
    override : {
        onTestFinalize : function () {
            Joose.A.each(this.spies, function (spy) { spy.remove() })
            
            this.spies  = null
            
            this.SUPER()
        },
        
        
        afterLaunch : function () {
            this.codeProcessed      = true
            
            this.launchSpecs()
            
            this.SUPERARG(arguments)
        }
    }
        
})
//eof Siesta.Test.BDD
;
Role('Siesta.Test.Sub', {
    
    has : {
        isExclusive         : false,
        parent              : { required : true }
    },
    
    
    methods : {
        
        getExceptionCatcher : function () {
            return this.parent.getExceptionCatcher()
        },
        
        
        getTestErrorClass : function () {
            return this.parent.getTestErrorClass()
        },
        
        
        getStartTestAnchor : function () {
            return this.parent.getStartTestAnchor()
        },
        
        
        expectGlobals : function () {
            return this.parent.expectGlobals.apply(this.parent, arguments)
        }
    }
        
})
;
/**
@class Siesta.Test
@mixin Siesta.Test.More
@mixin Siesta.Test.Date
@mixin Siesta.Test.Function
@mixin Siesta.Test.BDD
@mixin Siesta.Util.Role.CanCompareObjects

`Siesta.Test` is a base testing class in Siesta hierarchy. It's not supposed to be created manually, instead the harness will create it for you.

This file is a reference only, for a getting start guide and manual please refer to the <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

Please note: Each test will be run in **its own**, completely **isolated** and **clean** global scope (created with the iframe).
**There is no need to cleanup anything**.

SYNOPSIS
========

    StartTest(function(t) {
        t.diag("Sanity")

        t.ok($, 'jQuery is here')

        t.ok(Your.Project, 'My project is here')
        t.ok(Your.Project.Util, '.. indeed')

        setTimeout(function () {

            t.ok(true, "True is ok")

        }, 500)
    })


*/

Class('Siesta.Test', {

    does        : [
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Util.Role.CanGetType,
        Siesta.Util.Role.CanCompareObjects,
        Siesta.Util.Role.CanEscapeRegExp,
        
        Siesta.Test.More,
        Siesta.Test.Date,
        Siesta.Test.Function,
        Siesta.Test.BDD,
        
        JooseX.Observable,
        
        // quick "id" attribute, perhaps should be changed later
        Siesta.Util.Role.HasUniqueGeneratedId
    ],


    has        : {
        name                : null,

        /**
         * @property url The url of this test, as given to the {@link Siesta.Harness#start start} method. All subtests of some top-level test shares the same url.
         */
        url                 : { required : true },
        urlExtractRegex     : {
            is      : 'rwc',
            lazy    : function () {
                return new RegExp(this.url.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1") + ':(\\d+)')
            }
        },

        assertPlanned       : null,
        assertCount         : 0,

        // whether this test contains only "todo" assertions
        isTodo              : false,

        results             : {
            lazy    : function () {
                return new Siesta.Result.SubTest({ description  : this.name || 'Root', test : this })
            }
        },

        run                 : null,
        startTestAnchor     : null,
        exceptionCatcher    : null,
        testErrorClass      : null,

        // same number for the whole subtests tree
        generation          : function () {
            return Math.random()
        },
        
        launchId            : null,

        parent              : null,
        harness             : null,

        /**
         * @cfg {Number} isReadyTimeout
         *
         * Timeout in milliseconds to wait for test start. Default value is 10000. See also {@link #isReady}
         */
        isReadyTimeout      : 10000,

        // indicates that a test has thrown an exception (not related to failed assertions)
        failed              : false,
        failedException     : null, // stringified exception
        failedExceptionType : null, // type of exception

        // start and end date are stored as numbers (new Date() - 0)
        // this is to allow sharing date instances between different contexts
        startDate           : null,
        endDate             : null,
        lastActivityDate    : null,
        contentManager      : null,

        // the scope provider for the context of the test page
        scopeProvider       : null,
        // the context of the test page
        global              : null,

        reusingSandbox      : false,
        sandboxCleanup      : true,
        sharedSandboxState  : null,

        // the scope provider for the context of the test script
        // usually the same as the `scopeProvider`, but may be different in case of using `separateContext` option
        scriptScopeProvider : null,

        transparentEx       : false,

        needDone            : false,
        isDone              : false,

        defaultTimeout      : 15000,
        // a default timeout for sub tests
        subTestTimeout      : null,
        // a timeout of this particular test
        timeout             : null,

        timeoutsCount       : function () {
            return { counter : 1 }
        },
        timeoutIds          : Joose.I.Object,
        idsToIndex          : Joose.I.Object,
        waitTitles          : Joose.I.Object,


        // indicates that test function has completed the execution (test may be still running due to async)
        processed           : false,
        // indicates that test has started finalization process ("tearDown" method). At this point, test is considered
        // finished, but the failing assertion (if "tearDown" fails) may still be added
        finalizationStarted : false,

        callback            : null,

        // Nbr of exceptions detected while running the test
        nbrExceptions       : 0,
        testEndReported     : false,

        // only used for testing itself, otherwise should be always `true`
        needToCleanup               : true,

        overrideSetTimeout          : false,

        overrideForSetTimeout       : null,
        overrideForClearTimeout     : null,
        
        originalSetTimeout          : null,
        originalClearTimeout        : null,

        sourceLineForAllAssertions  : false,

        $passCount                  : null,
        $failCount                  : null,

        actionableMethods           : {
            lazy        : 'buildActionableMethods'
        },

        jUnitClass                  : null,
        groups                      : null,
        automationElementId         : null,
        
        enableCodeCoverage          : false,

        // user-provided config values
        config                      : null
    },


    methods : {

        initialize : function () {
            // suppress bubblings of some events (JooseX.Observable does not provide better mechanism for that, yet)
            this.on('teststart', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.on('testfinalize', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.on('beforetestfinalize', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.on('beforetestfinalizeearly', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.subTestTimeout     = this.subTestTimeout || 2 * this.defaultTimeout

            // Potentially may overwrite default properties and break test instance, should be used with care
            if (this.config) Joose.O.extend(this, this.config)
        },

        /**
         * This method allows you to delay the start of the test, for example for performing some asynchronous setup code (like login into an application).
         * Note, that you may want to use the {@link #setup} method instead, as it is a bit simpler to implement.
         *
         * It is supposed to be overridden in a subclass of the Siesta.Test class and should return an object with two properties: "ready" and "reason"
         * ("reason" is only meaningful for the case where "ready : false"). The Test instance will poll this method and will only launch
         * the test after this method returns "ready : true". If waiting for this condition takes longer than {@link #isReadyTimeout}, the test
         * will be launched anyway, but a failing assertion will be added to it.
         *
         * **Important** This method should always check the value returned by a `this.SUPER` call.
         *
         * A typical example of using this method can be seen below:
         *

    Class('My.Test.Class', {

        isa         : Siesta.Test.Browser,

        has         : {
            isCustomSetupDone           : false
        },

        override : {

            isReady : function () {
                var result = this.SUPERARG(arguments);

                if (!result.ready) return result;

                if (!this.isCustomSetupDone) return {
                    ready       : false,
                    reason      : "Waiting for `isCustomSetupDone` took too long - something wrong?"
                }

                return {
                    ready       : true
                }
            },


            start : function () {
                var me      = this;

                Ext.Ajax.request({
                    url     : 'do_login.php',

                    params  : { ... },

                    success : function () {
                        me.isCustomSetupDone    = true
                    }
                })

                this.SUPERARG(arguments)
            }
        },

        ....
    })

         *
         * @return {Object} Object with properties `{ ready : true/false, reason : 'description' }`
         */
        isReady: function() {
            var R = Siesta.Resource('Siesta.Test');

            // this should allow us to wait until the presense of "run" function
            // it will become available after call to StartTest method
            // which some users may call asynchronously, after some delay
            // see https://www.assembla.com/spaces/bryntum/tickets/379
            // in this case test can not be configured using object as 1st argument for StartTest
            this.run    = this.run || this.getStartTestAnchor().args && this.getStartTestAnchor().args[ 0 ]

            return {
                ready   : this.typeOf(this.run) == 'Function',
                reason  : R.get('noCodeProvidedToTest')
            }
        },


        // indicates that the tests identical or from the same tree (one is parent for another)
        isFromTheSameGeneration : function (test2) {
            return this.generation == test2.generation
        },


        toString : function() {
            return this.url
        },


        // deprecated
        plan : function (value) {
            if (this.assertPlanned != null) throw new Error("Test plan can't be changed")

            this.assertPlanned = value
        },


        addResult : function (result) {
            var isAssertion = result instanceof Siesta.Result.Assertion

            if (isAssertion) result.isTodo = this.isTodo

            // only allow to add diagnostic results and todo results after the end of test
            // and only if "needDone" is enabled
            if (isAssertion && (this.isDone || this.isFinished()) && !result.isTodo) {
                if (!this.testEndReported) {
                    this.testEndReported = true
                    var R = Siesta.Resource('Siesta.Test');

                    this.fail(R.get('addingAssertionsAfterDone'))
                }
            }

            if (isAssertion && !result.index) {
                result.index = ++this.assertCount
            }

            this.getResults().push(result)

            // clear the cache
            this.$passCount     = this.$failCount   = null

            /**
             * This event is fired when an individual test case receives a new result (assertion or diagnostic message).
             *
             * This event bubbles up to the {@link Siesta.Harness harness}, so you can observe it on the harness as well.
             *
             * @event testupdate
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has started
             * @param {Siesta.Result} result The new result. Instance of Siesta.Result.Assertion or Siesta.Result.Diagnostic classes
             */
            this.fireEvent('testupdate', this, result, this.getResults())

            this.lastActivityDate = new Date();
        },


        /**
         * This method output the diagnostic message.
         * @param {String} desc The text of diagnostic message
         */
        diag : function (desc, callback) {
            this.addResult(new Siesta.Result.Diagnostic({
                // protection from user passing some arbitrary JSON object instead of string
                // (which can be circular and then test report will fail with "Converting circular structure to JSON"
                description : String(desc || '')
            }))

            callback && callback();
        },


        /**
         * This method add the passed assertion to this test.
         *
         * @param {String} desc The description of the assertion
         * @param {String/Object} [annotation] The string with additional description how exactly this assertion passes. Will be shown with monospace font.
         * Can be also an object with the following properties:
         * @param {String} annotation.annotation The actual annotation text
         * @param {String} annotation.descTpl The template for the default description text. Will be used if user did not provide any description for
         * assertion. Template can contain variables in braces. The values for variables are taken as properties of `annotation` parameters with the same name:
         *

    this.pass(desc, {
        descTpl         : '{value1} sounds like {value2}',
        value1          : '1',
        value2          : 'one
    })

         *
         */
        pass : function (desc, annotation, result) {
            if (annotation && this.typeOf(annotation) != 'String') {
                // create a default assertion description
                if (!desc && annotation.descTpl) desc = this.formatString(annotation.descTpl, annotation)

                // actual annotation
                annotation          = annotation.annotation
            }

            if (result) {
                result.passed       = true
                result.description  = String(desc || '')
                result.annotation   = annotation
            }

            this.addResult(result || new Siesta.Result.Assertion({
                passed          : true,

                // protection from user passing some arbitrary JSON object instead of string
                // (which can be circular and then test report will fail with "Converting circular structure to JSON"
                annotation      : String(annotation || ''),
                description     : String(desc || ''),
                sourceLine      : (result && result.sourceLine) || (annotation && annotation.sourceLine) || this.sourceLineForAllAssertions && this.getSourceLine() || null
            }))
        },


        /**
         * This method add the failed assertion to this test.
         *
         * @param {String} desc The description of the assertion
         * @param {String/Object} annotation The additional description how exactly this assertion fails. Will be shown with monospace font.
         *
         * Can be either string or an object with the following properties. In the latter case a string will be constructed from the properties of the object.
         *
         * - `assertionName` - the name of assertion, will be shown in the 1st line, along with originating source line (in FF and Chrome only)
         * - `got` - an arbitrary JavaScript object, when provided will be shown on the next line
         * - `need` - an arbitrary JavaScript object, when provided will be shown on the next line
         * - `gotDesc` - a prompt for "got", default value is "Got", but can be for example: "We have"
         * - `needDesc` - a prompt for "need", default value is "Need", but can be for example: "We need"
         * - `annotation` - A text to append on the last line, can contain some additional explanations
         *
         *  The "got" and "need" values will be stringified to the "not quite JSON" notation. Notably the points of circular references will be
         *  marked with `[Circular]` marks and the values at 4th (and following) level of depth will be marked with triple points: `[ [ [ ... ] ] ]`
         */
        fail : function (desc, annotation, result) {
            var sourceLine          = (result && result.sourceLine) || (annotation && annotation.sourceLine) || this.getSourceLine()
            var assertionName       = '';

            if (annotation && this.typeOf(annotation) != 'String') {
                if (!desc && annotation.descTpl) desc = this.formatString(annotation.descTpl, annotation)

                var strings             = []

                var params              = annotation
                var hasGot              = params.hasOwnProperty('got')
                var hasNeed             = params.hasOwnProperty('need')
                var gotDesc             = params.gotDesc || 'Got'
                var needDesc            = params.needDesc || 'Need'

                assertionName           = params.assertionName
                annotation              = params.annotation

                if (!params.ownTextOnly && (assertionName || sourceLine)) strings.push(
                    'Failed assertion ' + (assertionName ? '`' + assertionName + '` ' : '') + this.formatSourceLine(sourceLine)
                )

                if (hasGot && hasNeed) {
                    var max         = Math.max(gotDesc.length, needDesc.length)

                    gotDesc         = this.appendSpaces(gotDesc, max - gotDesc.length + 1)
                    needDesc        = this.appendSpaces(needDesc, max - needDesc.length + 1)
                }

                if (hasGot)     strings.push(gotDesc   + ': ' + Siesta.Util.Serializer.stringify(params.got))
                if (hasNeed)    strings.push(needDesc  + ': ' + Siesta.Util.Serializer.stringify(params.need))

                if (annotation) strings.push(annotation)

                annotation      = strings.join('\n')
            }

            if (result) {
                // Failing a pending waitFor operation
                result.name         = assertionName;
                result.passed       = false;
                result.annotation   = annotation;
                result.description  = desc;
            }

            this.addResult(result || new Siesta.Result.Assertion({
                name        : assertionName,
                passed      : false,
                sourceLine  : sourceLine,

                // protection from user passing some arbitrary JSON object instead of string
                // (which can be circular and then test report will fail with "Converting circular structure to JSON"
                annotation  : String(annotation || ''),
                description : String(desc || '')
            }))

            if (!this.isTodo) {
                if (this.harness.debuggerOnFail) {
                    eval("debugger");
                }

                if (this.harness.breakOnFail) {
                    var R   = Siesta.Resource('Siesta.Test');

                    this.finalize(true);
                    throw R.get('testFailedAndAborted');
                }
            }
        },
        
        
        /**
         * This method stops the execution of the test early. You can use it if, for example, you already know the status of
         * test (failed) and further actions involves long waitings etc.
         * 
         * This method accepts the same arguments as the {@link #fail} method. If at least the one argument is given,
         * a failed assertion will be added to the test before the exit.
         * 
         * For example:
         * 

        t.chain(
            function (next) {
                // do something
            
                next()
            },
            function (next) {
                if (someCondition) 
                    t.exit("Failure description")
                else
                    next()
            },
            { waitFor : function () { ... } }
        )


         *
         * @param {String} [desc] The description of the assertion
         * @param {String/Object} [annotation] The additional description how exactly this assertion fails. Will be shown with monospace font.
         */
        exit : function (desc, annotation) {
            if (arguments.length > 0) this.fail(desc, annotation)
            
            this.finalize(true)
            throw '__SIESTA_TEST_EXIT_EXCEPTION__'
        },


        getSource : function () {
            return this.contentManager.getContentOf(this.url)
        },


        getSourceLine : function () {
            // TODO switch to new Error().stack when dropped supported for IE10;
            try {
                throw new Error()
            } catch (e) {
                if (e.stack) {
                    var match       = e.stack.match(this.urlExtractRegex())

                    if (match) return match[ 1 ]
                }

                return null
            }
        },


        getStartTestAnchor : function () {
            return this.startTestAnchor
        },


        getExceptionCatcher : function () {
            return this.exceptionCatcher
        },


        getTestErrorClass : function () {
            return this.testErrorClass
        },


        processCallbackFromTest : function (callback, args, scope) {
            var me      = this

            if (!callback) return true;

            if (this.transparentEx) {
                callback.apply(scope || this.global, args || [])
            } else {
                var e = this.getExceptionCatcher()(function(){
                    callback.apply(scope || me.global, args || [])
                })

                if (e) {
                    this.failWithException(e)

                    // flow should be interrupted - exception detected
                    return false
                }
            }

            // flow can be continued
            return true
        },


        getStackTrace : function (e) {
            if (Object(e) !== e)    return null
            if (!e.stack)           return null
            
            var stackLines      = (e.stack + '').split('\n')
            var message         = e + ''
            var R               = Siesta.Resource('Siesta.Test');
            var result          = []
            var match

            for (var i = 0; i < stackLines.length; i++) {
                var line        = stackLines[ i ]
                
                if (!line) continue

                // first line should contain exception message
                if (!i) {
                    if (line != message)
                        result.push(message)
                    else {
                        result.push(line)
                        continue;
                    }
                }

                match   = /@(.*?):(\d+):(\d+)$/.exec(line) || /\((.*?):(\d+):(\d+)\)$/.exec(line) || 
                    /at (.*?):(\d+):(\d+)$/.exec(line) || /(.*?):(\d+):(\d+)$/.exec(line) 

                // the format of stack trace has changed, 080_exception_parsing should fail
                if (!match) return null
                
                result.push(
                    '    ' + R.get('atLine') + ' ' + match[ 2 ] + 
                    (match[ 3 ] ? ', ' + R.get('character') + ' ' + match[ 3 ] : '') + 
                    ', ' + R.get('of') + ' ' + match[ 1 ]
                )
            }

            if (!result.length) return null

            return result
        },


        formatSourceLine : function (sourceLine) {
            var R               = Siesta.Resource('Siesta.Test');

            return sourceLine ? (R.get('atLine') + ' ' + sourceLine + ' ' + R.get('of') + ' ' + this.url) : ''
        },


        appendSpaces : function (str, num) {
            var spaces      = ''

            while (num--) spaces += ' '

            return str + spaces
        },


        eachAssertion : function (func, scope) {
            scope       = scope || this

            this.getResults().each(function (result) {
                if (result instanceof Siesta.Result.Assertion) func.call(scope, result)
            })
        },


        eachSubTest : function (func, scope) {
            scope       = scope || this

            this.getResults().each(function (result) {
                if (result instanceof Siesta.Result.SubTest) 
                    if (func.call(scope, result.test) === false) return false
            })
        },


        eachChildTest : function (func, scope) {
            scope       = scope || this

            this.getResults().eachChild(function (result) {
                if (result instanceof Siesta.Result.SubTest) 
                    if (func.call(scope, result.test) === false) return false
            })
        },


        /**
         * This assertion passes when the supplied `value` evalutes to `true` and fails otherwise.
         *
         * @param {Mixed} value The value, indicating wheter assertions passes or fails
         * @param {String} [desc] The description of the assertion
         */
        ok : function (value, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (value)
                this.pass(desc, {
                    descTpl             : R.get('isTruthy'),
                    value               : value
                })
            else
                this.fail(desc, {
                    assertionName       : 'ok',
                    got                 : value,
                    annotation          : R.get('needTruthy')
                })
        },


        notok : function () {
            this.notOk.apply(this, arguments)
        },

        /**
         * This assertion passes when the supplied `value` evalutes to `false` and fails otherwise.
         *
         * It has a synonym - `notok`.
         *
         * @param {Mixed} value The value, indicating wheter assertions passes or fails
         * @param {String} [desc] The description of the assertion
         */
        notOk : function (value, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (!value)
                this.pass(desc, {
                    descTpl             : R.get('isFalsy'),
                    value               : value
                })
            else
                this.fail(desc, {
                    assertionName       : 'notOk',
                    got                 : value,
                    annotation          : R.get('needFalsy')
                })
        },


        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `==` operator returns true and fails otherwise.
         *
         * As a special case, one or both arguments can be *placeholders*, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        is : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (expected && got instanceof this.global.Date) {
                this.isDateEqual(got, expected, desc);
            } else if (this.compareObjects(got, expected, false, true))
                this.pass(desc, {
                    descTpl             : R.get('isEqualTo'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'is',
                    got                 : got,
                    need                : expected
                })
        },



        isnot : function () {
            this.isNot.apply(this, arguments)
        },

        isnt : function () {
            this.isNot.apply(this, arguments)
        },


        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `!=` operator returns true and fails otherwise.
         * It has synonyms - `isnot` and `isnt`.
         *
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        isNot : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (!this.compareObjects(got, expected, false, true))
                this.pass(desc, {
                    descTpl             : R.get('isNotEqualTo'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isnt',
                    got                 : got,
                    need                : expected,
                    needDesc            : R.get('needNot')
                })
        },


        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `===` operator returns true and fails otherwise.
         *
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        isStrict : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : R.get('isStrictlyEqual'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isStrict',
                    got                 : got,
                    need                : expected,
                    needDesc            : R.get('needStrictly')
                })
        },


        isntStrict : function () {
            this.isNotStrict.apply(this, arguments)
        },

        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `!==` operator returns true and fails otherwise.
         * It has synonyms - `isntStrict`.
         *
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        isNotStrict : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (!this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : R.get('isStrictlyNotEqual'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isntStrict',
                    got                 : got,
                    need                : expected,
                    needDesc            : R.get('needStrictlyNot')
                })
        },


        /**
         * This method starts the "asynchronous frame". The test will wait for all asynchronous frames to complete before it will finalize.
         * The frame can be finished with the {@link #endWait} call. Unlike the {@link #beginAsync}, this method requires you to provide
         * the unique id for the asynchronous frame.
         *
         * For example:
         *
         *      t.wait("require")
         *
         *      Ext.require('Some.Class', function () {
         *
         *          t.ok(Some.Class, 'Some class was loaded')
         *
         *          t.endWait("require")
         *      })
         *
         *
         * @param {String} title The unique id for the asynchronous frame.
         * @param {String} howLong The maximum time (in ms) to wait until force the finalization of this async frame. Optional. Default time is 15000 ms.
         */
        wait : function (title, howLong) {
            var R               = Siesta.Resource('Siesta.Test');

            if (this.waitTitles.hasOwnProperty(title)) throw new Error(R.get('alreadyWaiting')+ " [" + title + "]")

            return this.waitTitles[ title ] = this.beginAsync(howLong)
        },


        /**
         * This method finalize the "asynchronous frame" started with {@link #wait}.
         *
         * @param {String} title The id of frame to finalize, which was previously passed to {@link #wait} method
         */
        endWait : function (title) {
            var R               = Siesta.Resource('Siesta.Test');

            if (!this.waitTitles.hasOwnProperty(title)) throw new Error(R.get('noOngoingWait') + " [" + title + "]")

            this.endAsync(this.waitTitles[ title ])

            delete this.waitTitles[ title ]
        },



        /**
         * This method starts the "asynchronous frame". The test will wait for all asynchronous frames to complete before it will finalize.
         * The frame should be finished with the {@link #endAsync} call within the provided `time`, otherwise a failure will be reported.
         *
         * For example:
         *
         *      var async = t.beginAsync()
         *
         *      Ext.require('Some.Class', function () {
         *
         *          t.ok(Some.Class, 'Some class was loaded')
         *
         *          t.endAsync(async)
         *      })
         *
         *
         * @param {Number} time The maximum time (in ms) to wait until force the finalization of this async frame. Optional. Default time is 15000 ms.
         * @param {Function} errback Optional. The function to call in case the call to {@link #endAsync} was not detected withing `time`. If function
         * will return any "truthy" value, the failure will not be reported (you can report own failure with this errback).
         *
         * @return {Object} The frame object, which can be used in {@link #endAsync} call
         */
        beginAsync : function (time, errback) {
            time                        = time || this.defaultTimeout
            
            if (time > this.getMaximalTimeout()) this.fireEvent('maxtimeoutchanged', time)

            var R                       = Siesta.Resource('Siesta.Test');
            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout

            var index                   = this.timeoutsCount.counter++

            // in NodeJS `setTimeout` returns an object and not a simple ID, so we try hard to store that object under unique index
            // also using `setTimeout` from the scope of test - as timeouts in different scopes in browsers are mis-synchronized
            // can't just use `this.originalSetTimeout` because of scoping issues
            var timeoutId               = originalSetTimeout(function () {

                if (me.hasAsyncFrame(index)) {
                    if (!errback || !errback.call(me, me)) me.fail(R.get('noMatchingEndAsync') + ' ' + time + ' ' + Siesta.Resource('Siesta.Test.More', 'ms'))

                    me.endAsync(index)
                }
            }, time)

            this.timeoutIds[ index ]    = timeoutId

            return index
        },
        
        
        timeoutIdToIndex : function (id) {
            var index
            
            if (typeof id == 'object') {
                index       = id.__index
            } else {
                index       = this.idsToIndex[ id ]
            }
            
            return index
        },


        hasAsyncFrame : function (index) {
            return this.timeoutIds.hasOwnProperty(index)
        },

        
        hasAsyncFrameByTimeoutId : function (id) {
            return this.timeoutIds.hasOwnProperty(this.timeoutIdToIndex(id))
        },
        

        /**
         * This method finalize the "asynchronous frame" started with {@link #beginAsync}.
         *
         * @param {Object} frame The frame to finalize (returned by {@link #beginAsync} method
         */
        endAsync : function (index) {
            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout || this.global.clearTimeout
            var counter                 = 0
            var R                       = Siesta.Resource('Siesta.Test');

            if (index == null) Joose.O.each(this.timeoutIds, function (timeoutId, indx) {
                index = indx
                if (counter++) throw new Error(R.get('endAsyncMisuse'))
            })

            var timeoutId               = this.timeoutIds[ index ]

            // need to call in this way for IE < 9
            originalClearTimeout(timeoutId)
            delete this.timeoutIds[ index ]

            var me = this

            if (this.processed && !this.isFinished())
                // to allow potential call to `done` after `endAsync`
                originalSetTimeout(function () {
                    me.finalize()
                }, 1)
        },


        clearTimeouts : function () {
            var originalClearTimeout    = this.originalClearTimeout

            Joose.O.each(this.timeoutIds, function (value, id) {
                originalClearTimeout(value)
            })

            this.timeoutIds = {}
        },


        processSubTestConfig : function (config) {
            return Joose.O.extend({
                trait                   : Siesta.Test.Sub,

                parent                  : this,

                isTodo                  : this.isTodo,
                transparentEx           : this.transparentEx,

                waitForTimeout          : this.waitForTimeout,
                waitForPollInterval     : this.waitForPollInterval,
                defaultTimeout          : this.defaultTimeout,
                timeout                 : this.subTestTimeout,
                subTestTimeout          : this.subTestTimeout,

                global                  : this.global,
                url                     : this.url,
                scopeProvider           : this.scopeProvider,
                harness                 : this.harness,
                generation              : this.generation,
                launchId                : this.launchId,

                overrideSetTimeout      : this.overrideSetTimeout,
                originalSetTimeout      : this.originalSetTimeout,
                originalClearTimeout    : this.originalClearTimeout,
                
                // share the same counter for the whole subtests tree
                timeoutsCount           : this.timeoutsCount,

                autoCheckGlobals        : false,
                needToCleanup           : false
            }, config)
        },


        /**
         * Returns a new instance of the test class, configured as being a "sub test" of the current test.
         *
         * The number of nesting levels is not limited - ie sub-tests may have own sub-tests.
         *
         * Note, that this method does not starts the sub test, but only instatiate it. To start the sub test, 
         * use the {@link #launchSubTest} method or the {@link #subTest} helper method.
         *
         * @param {String} name The name of the test. Will be used in the UI, as the parent node name in the assertions tree
         * @param {Function} code A function with test code. Will receive a test instance as the 1st argument.
         * @param {Number} [timeout] A maximum duration (in ms) for this sub test. If test will not complete within this time,
         * it will be considered failed. If not provided, the {@link Siesta.Harness#subTestTimeout} value is used.
         *
         * @return {Siesta.Test} A sub test instance
         */
        getSubTest : function (arg1, arg2, arg3) {
            var config
            var R = Siesta.Resource('Siesta.Test');

            if (arguments.length == 2 || arguments.length == 3)
                config = {
                    name        : arg1,
                    run         : arg2,
                    timeout     : arg3
                }
            else if (arguments.length == 1 && this.typeOf(arg1) == 'Function')
                config  = {
                    name        : 'Sub test',
                    run         : arg1
                }

            config              = config || arg1 || {}

            // pass-through only valid timeout values
            if (config.timeout == null) delete config.timeout

            var name            = config.name

            if (!config.run) {
                this.failWithException(R.get('codeBodyMissingForSubTest') + " [" + name + "]")
                throw new Error(R.get('codeBodyMissingForSubTest') + " [" + name + "]")
            }
            if (!config.run.length) {
                this.failWithException(R.get('codeBodyMissingTestArg').replace('{name}', name))
                throw new Error(R.get('codeBodyMissingTestArg').replace('{name}', name))
            }

            return new (config.meta || this.constructor)(this.processSubTestConfig(config))
        },


        /**
         * This method launch the provided sub test instance.
         *
         * @param {Siesta.Test} subTest A test instance to launch
         * @param {Function} callback A function to call, after the test is completed. This function is called regardless from the test execution result.
         */
        launchSubTest : function (subTest, callback) {
            var me          = this
            var R           = Siesta.Resource('Siesta.Test');
            var timeout     = subTest.timeout || this.subTestTimeout

            var async       = this.beginAsync(timeout, function () {
                me.fail(R.get('Subtest') + ' ' + (subTest.name ? '[' + subTest.name + ']' : '') + ' ' + R.get('failedToFinishWithin') + ' ' + timeout + ' ' + Siesta.Resource('Siesta.Test.More', 'ms'))

                me.restoreTimeoutOverrides()
                
                testEndListener.remove()

                subTest.finalize(true)

                callback && callback(subTest)

                return true
            })

            var testEndListener = subTest.on('testfinalize', function () {
                me.endAsync(async)
                
                me.restoreTimeoutOverrides()

                callback && callback(subTest)
            })

            this.addResult(subTest.getResults())

            subTest.start()
        },


        /**
         * With this method you can mark a group of assertions as "todo", assuming they most likely will fail,
         * but it's still worth to try to run them.
         * The supplied `code` function will be run, it will receive a new test instance as the 1st argument,
         * which should be used for assertion checks (and not the primary test instance, received from `StartTest`).
         *
         * Assertions, failed inside of the `code` block will be still treated by harness as "green".
         * Assertions, passed inside of the `code` block will be treated by harness as bonus ones and highlighted.
         *
         * See also {@link Siesta.Test.ExtJS#knownBugIn} and {@link Siesta.Test.ExtJS#snooze} methods. Note, that this method will start a new {@link #subTest sub test}.
         *
         * For example:

            t.todo('Scheduled for 4.1.x release', function (todo) {

                var treePanel    = new Ext.tree.Panel()

                todo.is(treePanel.getView().store, treePanel.store, 'NodeStore and TreeStore have been merged and there is only 1 store now');
            })

         * @param {String} why The reason/description for the todo
         * @param {Function} code A function, wrapping the "todo" assertions. This function will receive a special test class instance
         * which should be used for assertion checks
         */
        todo : function (why, code, callback) {
            if (this.typeOf(why) == 'Function') why = [ code, code = why ][ 0 ]

            var todo        = this.getSubTest({
                name            : why,

                run             : code,

                isTodo          : true,
                transparentEx   : false
            })

            this.launchSubTest(todo, callback)
        },


        /**
         * This method allows you to "snooze" the failing test (make it a {@link Siesta.Test#todo todo test} until certain date.
         * After that date, test will become "normal" again. Use with care :)
         *
            t.snooze('2014-10-10', function (todo) {

                var treePanel    = new Ext.tree.Panel()

                todo.is(treePanel.getView().store, treePanel.store, 'NodeStore and TreeStore have been merged and there is only 1 store now');
            })
         *
         * @param {String/Date} snoozeUntilDate The date until which we don't want to hear about this test. Can be provided as `Date` instance or a string, recognized by `Date` constructor
         * @param {Function} fn The function body of the test
         * @param {String} reason The reason or explanation why this test is "snoozed"
         */
        snooze : function(snoozeUntilDate, fn, reason) {
            var R       = Siesta.Resource('Siesta.Test');

            if (new Date() > new Date(snoozeUntilDate)) {
                fn.call(this.global, this);
            } else {
                this.todo(R.get('Snoozed until') + ' ' + new Date(snoozeUntilDate) + ': ' + (reason || ''), fn);
            }
        },



        /**
         * This method starts a new sub test. Sub tests have separate order of assertions. In the browser UI,
         * sub tests are presented with the "parent" node of the assertions tree. Sub tests are useful if you want to test
         * several asynchronous processes in parallel, and would like to see assertions from every process separated.
         *
         * Sub tests may have their own sub tests, the number of nesting levels is not limited.
         *
         * Sub test can contain asynchronous methods as any other tests. Sub tests are considered completed
         * only when all of its asynchronous methods have completed *and* all of its sub-tests are completed too.
         *
         * For example:
         *

    t.subTest('Load 1st store', function (t) {
        var async   = t.beginAsync()

        store1.load({
            callback : function () {
                t.endAsync(async);
                t.isGreater(store1.getCount(), 0, "Store1 has been loaded")
            }
        })
    })

    t.subTest('Load 2nd store', function (t) {
        var async   = t.beginAsync()

        store2.load({
            callback : function () {
                t.endAsync(async);
                t.isGreater(store2.getCount(), 0, "Store2 has been loaded")
            }
        })
    })

         * Note, that sub test starts right away, w/o waiting for any previous sub tests to complete. If you'd like to run several sub-tests
         * sequentially, use {@link #chain} method in combination with {@link #getSubTest} method.
         *
         * @param {String} desc The name of the sub test. Will be shown as the name of the parent node in assertion tree.
         * @param {Function} code The test function to execute. It will receive a test instance as 1st argument. This test instance *must* be
         * used for assertions inside of the test function
         * @param {Function} callback The callback to execute after the sub test completes (either successfully or not)
         * @param {Number} [timeout] A maximum duration (in ms) for this sub test. If test will not complete within this time,
         * it will be considered failed. If not provided, the {@link Siesta.Harness#subTestTimeout} value is used.
         */
        subTest : function (desc, code, callback, timeout) {
            var subTest     = this.getSubTest({
                name            : desc || Siesta.Resource('Siesta.Test', 'Subtest'),
                timeout         : timeout,
                run             : code
            })

            this.launchSubTest(subTest, callback)
            
            return subTest
        },
        
        
        stringifyException : function (e, stackTrace) {
            var stringified             = e + ''
            var annotation              = (stackTrace || this.getStackTrace(e) || []).join('\n')

            // prepend the exception message to the stack trace if its not already there
            if (annotation.indexOf(stringified) == -1) annotation = stringified + annotation
            
            return annotation
        },


        failWithException : function (e, description) {
            var R                       = Siesta.Resource('Siesta.Test');
            
            this.failed                 = true

            this.failedException        = e + ''
            this.failedExceptionType    = this.typeOf(e)
            
            var stackTrace              = this.getStackTrace(e)

            this.addResult(new Siesta.Result.Assertion({
                isException     : true,
                exceptionType   : this.failedExceptionType,
                passed          : false,
                description     : description ? description : ((this.parent ? R.get('Subtest') + " `" + this.name + "`" : R.get('Test') + ' ') + ' ' + R.get('threwException')),
                annotation      : this.stringifyException(e, stackTrace)
            }))


            /**
             * This event is fired when an individual test case has thrown an exception.
             *
             * This event bubbles up to the {@link Siesta.Harness harness}, so you can observe it on the harness as well.
             *
             * @event testfailedwithexception
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just threw an exception
             * @param {Object} exception The exception thrown
             */
            this.fireEvent('testfailedwithexception', this, e, stackTrace);

            this.finalize(true)
        },
        
        
        restoreTimeoutOverrides : function () {
            if (this.overrideSetTimeout) {
                this.global.setTimeout      = this.overrideForSetTimeout
                this.global.clearTimeout    = this.overrideForClearTimeout
            }
        },


        start : function (preloadErrors) {
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test');

            if (this.startDate) throw R.get('testAlreadyStarted');

            this.startDate  = new Date() - 0
            
            me.onTestStart()

            /**
             * This event is fired when an individual test case starts. When *started*, the test will be waiting for 
             * the {@link #isReady} condition to be fullfilled and the {@link #setup} method to complete. 
             * After that the test will be *launched* (and execute the `StartTest` function). 
             *
             * This event bubbles up to the {@link Siesta.Harness harness}, you can observe it on the harness as well.
             *
             * @event teststart
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has started
             */
            this.fireEvent('teststart', this);

            if (preloadErrors && preloadErrors.length) {
                Joose.A.each(preloadErrors, function (error) {
                    if (!error.isException) 
                        me.fail(error.message)
                    else {
                        me.failWithException(error.message)
                        return false
                    }
                })
                
                me.finalize(true)

                return true
            }

            // Sub-tests should not perform the `setup` or wait for `isReady` readyness
            if (this.parent || this.reusingSandbox) {
                this.launch()
                return
            }

            var errorMessage;

            // Note, that `setTimeout, setInterval` and similar methods here are from the harness context

            var cont            = function (isReadyError) {
                var hasTimedOut     = false

                var setupTimeout    = setTimeout(function () {
                    hasTimedOut     = true
                    me.launch(R.get('setupTookTooLong'))
                }, me.isReadyTimeout)

                me.setup(
                    function () {
                        if (!hasTimedOut) {
                            clearTimeout(setupTimeout)
                            me.launch(isReadyError)
                        }
                    },
                    function (setupError) {
                        if (!hasTimedOut) {
                            clearTimeout(setupTimeout)
                            me.launch(isReadyError || setupError)
                        }
                    }
                );
            }

            var readyRes        = me.isReady();

            if (readyRes.ready) {
                // We're ready to go
                cont();
            } else {
                // Need to wait for isReady to give green light
                var timeout         = setTimeout(function () {
                    clearInterval(interval)
                    cont(errorMessage)

                }, me.isReadyTimeout)

                var interval = setInterval(function(){
                    readyRes = me.isReady();

                    if (readyRes.ready) {
                        clearInterval(interval)
                        clearTimeout(timeout)
                        cont();
                    } else {
                        errorMessage = readyRes.reason || errorMessage;
                    }
                }, 100);
            }
        },


        /**
         * This method can perform any setup code your tests need. It is called before the begining of every test and receives
         * a callback and errback, either of those should be called once the setup has completed (or failed). 
         * See also {@link #tearDown}.
         *  
         * Typical usage for this method can be for example to log in into the application, before interacting with it:
         *

    Class('My.Test.Class', {

        isa         : Siesta.Test.Browser,

        override : {

            setup : function (callback, errback) {
                Ext.Ajax.request({
                    url     : 'do_login.php',

                    params  : { ... },

                    success : function () {
                        callback()
                    },
                    failure : function () {
                        errback('Login failed')
                    }
                })
            }
        },

        ....
    })

         *
         * This method will be called *after* the {@link #isReady} method has reported that the test is ready to start.
         *
         * If the setup has failed for some reason, then an errback should be called and a failing assertion will be added to the test
         * (though the test will be lauched anyway). A text of the failed assertion can be given as the 1st argument for the errback.
         *
         * Note, that the setup is supposed to be completed within the {@link #isReadyTimeout} timeout, otherwise it will be
         * considered failed and the test will be launched with a failed assertion.
         * 
         * If you need to perform a setup at an earlier point, check the {@link #earlySetup} method.
         *
         * @param {Function} callback A function to call when the setup has completed successfully
         * @param {Function} errback A function to call when the setup has completed with an error
         */
        setup : function (callback, errback) {
            callback.call(this)
        },


        /**
         * This method can perform any asynchronous finalization code your tests need. It is called after the test has
         * been finished (or finalized externally by any reason, for example if user re-starts the test).
         * This method receives a callback and errback, either of those should be called once the tear down has completed 
         * (or has failed). Typical usage for this method can be for example to clear the database or release some other resource.
         * 
         * **Note** though, that if test suite has experienced a hard failure, this method may not be called.
         *

    Class('My.Test.Class', {

        isa         : Siesta.Test.Browser,

        override : {

            tearDown : function (callback, errback) {
                Ext.Ajax.request({
                    url     : 'clear_the_db.php',

                    params  : { ... },

                    success : function () {
                        callback()
                    },
                    failure : function () {
                        errback("Error message")
                    }
                })
            }
        },

        ....
    })

         *
         * If the tearDown has failed for some reason, then an errback should be called and a failing assertion will be added to the test
         * (though the test will be lauched anyway). A text of the failed assertion can be given as the 1st argument for the errback.
         *
         * Note, that the tear down process is supposed to be completed within the {@link #isReadyTimeout} timeout, after this
         * timeout a failing assertion will be added to the test and test suite will just continue execution.
         * 
         * @param {Function} callback A function to call when the tear down process has completed successfully
         * @param {Function} errback A function to call when the tear down process has failed.
         * @param {String} [errback.errorMessage] An error message which will be added as a failing assertion to the test.
         */
        tearDown : function (callback, errback) {
            callback.call(this)
        },
        
        
        /**
         * This method can perform any setup code your tests need. It is the earliest point for doing setup, it is called
         * even before the iframe of the test is created and started loading. Normally, you should use the {@link #setup} method
         * for tests initialization purposes.
         * 
         * Typical usage for this method can be  for example to clear the database, before starting to 
         * load the {@link Siesta.Harness.Browser#pageUrl pageUrl} link.  
         * 
         * This method receives a callback and errback, either of these should be called once the setup has completed (or failed). 
         *

    Class('My.Test.Class', {

        isa         : Siesta.Test.Browser,

        override : {

            earlySetup : function (callback, errback) {
                Ext.Ajax.request({
                    url     : 'clear_test_db.php',

                    params  : { ... },

                    success : function () {
                        callback()
                    },
                    failure : function () {
                        errback('Reseting DB has failed')
                    }
                })
            }
        },

        ....
    })

         *
         * If the setup has failed for some reason, then an errback should be called and a failing assertion will be added to the test
         * (though the test will be lauched anyway). A text of the failed assertion can be given as the 1st argument for the errback.
         *
         * Note, that the setup is supposed to be completed within the {@link #isReadyTimeout} timeout, otherwise it will be
         * considered failed and the test will be launched with a failed assertion. Also, this method is not called for the
         * re-used iframes (see the {@link Siesta.Harness.Browser#sandbox sandbox} option).
         *
         * @param {Function} callback A function to call when the setup has completed successfully
         * @param {Function} errback A function to call when the setup has completed with an error
         */
        earlySetup : function (callback, errback) {
            callback.call(this)
        },
        
        
        // only called for the re-used contexts
        cleanupContextBeforeStart : function () {
            var global      = this.global

            this.forEachUnexpectedGlobal(function (name) {
                try {
                    // can throw exception in IE8
                    delete global[ name ]
                } catch (e) {
                }
            })
        },
        
        
        // this method assumes "overrideSetTimeout" option is enabled
        clearAsyncFrameGlobally : function (id) {
            var topTest     = this
            
            while (topTest.parent) topTest = topTest.parent
            
            topTest.eachSubTest(function (subTest) {
                if (subTest.hasAsyncFrameByTimeoutId(id)) {
                    subTest.overrideForClearTimeout(id)
                    return false
                }
            })
        },


        launch : function (errorMessage) {
            if (errorMessage) {
                var R = Siesta.Resource('Siesta.Test');

                this.fail(R.get('errorBeforeTestStarted'), {
                    annotation      : errorMessage
                })
            }

            var me                      = this
            var global                  = this.global

            var scopeProvider           = this.scopeProvider

            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout

            if (this.overrideSetTimeout) {
                // see http://www.adequatelygood.com/2011/4/Replacing-setTimeout-Globally
                if (!this.reusingSandbox) scopeProvider.runCode('var setTimeout, clearTimeout;')

                global.setTimeout = this.overrideForSetTimeout = function (func, delay) {

                    var index = me.timeoutsCount.counter++

                    // in NodeJS `setTimeout` returns an object and not a simple ID, so we try hard to store that object under unique index
                    // also using `setTimeout` from the scope of test - as timeouts in different scopes in browsers are mis-synchronized
                    var timeoutId = originalSetTimeout(function () {
                        originalClearTimeout(timeoutId)
                        delete me.timeoutIds[ index ]

                        // if the test func has been executed, but the test was not finalized yet - then we should try to finalize it
                        if (me.processed && !me.isFinished())
                            // we are doing that after slight delay, potentially allowing to setup some other async frames in the "func" below
                            originalSetTimeout(function () {
                                me.finalize()
                            }, 1)

                        func()

                    }, delay)

                    // in NodeJS saves the index of the timeout descriptor to the descriptor
                    if (typeof timeoutId == 'object')
                        timeoutId.__index = index
                    else
                        // in browser (where `timeoutId` is a number) - to the `idsToIndex` hash
                        me.idsToIndex[ timeoutId ] = index

                    return me.timeoutIds[ index ] = timeoutId
                }

                global.clearTimeout = this.overrideForClearTimeout = function (id) {
                    if (id == null) return
                    
                    // if there's no timeout id with this index, that probably means
                    // that this "clearTimeout" call corresponds to the "setTimeout" from some other
                    // sub test - parent most probably (or sibling sub test)
                    // strictly that may not be true, because user can launch several sub tests
                    // simultaneously, but, "overrideSetTimeout" for that case can not be supported reliably
                    // anyway, as we need to know from what test the "setTimeout" call comes (to keep it
                    // active) and we can't override it twice
                    if (!me.hasAsyncFrameByTimeoutId(id)) {
                        me.clearAsyncFrameGlobally(id)
                        
                        return
                    }

                    originalClearTimeout(id)
                    
                    var index       = me.timeoutIdToIndex(id)

                    if (index != null) delete me.timeoutIds[ index ]

                    // if the test func has been executed, but the test was not finalized yet - then we should try to finalize it
                    if (me.processed && !me.isFinished())
                        // we are doing that after slight delay, potentially allowing to setup some other async frames after the "clearTimeout" will complete
                        originalSetTimeout(function () {
                            me.finalize()
                        }, 1)
                }
            }
            // eof this.overrideSetTimeout

            // we only don't need to cleanup up when doing a self-testing or for sub-tests
            if (this.needToCleanup) {
                scopeProvider.beforeCleanupCallback = function () {
                    // if scope cleanup happens most probably user has restarted the test and is not interested in the results
                    // of previous launch
                    // finalizing the previous test in such case
                    if (!me.isFinished()) me.finalize(true)

                    if (me.overrideSetTimeout) {
                        global.setTimeout           = originalSetTimeout
                        global.clearTimeout         = originalClearTimeout
                    }

                    // cleanup the closures just in case (probably useful for IE)
                    originalSetTimeout          = originalClearTimeout  = null
                    global                      = null

                    // this iterator will also process "this" test instance too
                    me.eachSubTest(function (subTest) {
                        subTest.cleanup()
                    })
                }
            }

            if (this.reusingSandbox && this.sandboxCleanup && !this.parent) {
                this.cleanupContextBeforeStart()
            }
            
            var run     = this.run
            
            if (this.transparentEx)
                run(me)
            else
                var e = this.getExceptionCatcher()(function(){
                    run(me)
                })

            this.afterLaunch(e)
        },


        // called before the iframe of the test is removed from DOM
        cleanup : function () {
            this.overrideForSetTimeout  = this.overrideForClearTimeout  = null
            this.originalSetTimeout     = this.originalClearTimeout     = null
            this.global                 = this.run                      = null
            this.exceptionCatcher       = this.testErrorClass           = null
            this.startTestAnchor                                        = null
            
            this.scopeProvider          = null
            
            this.purgeListeners()
        },


        // a method executed after the "run" function has been ran - used in BDD role for example
        afterLaunch : function (e) {
            if (e)
                this.failWithException(e)
            else
                this.finalize()
        },


        finalize : function (force) {
            var me          = this
            var R           = Siesta.Resource('Siesta.Test');
            
            if (me.finalizationStarted || me.isFinished()) return

            me.processed    = true

            if (force) {
                me.clearTimeouts()

                me.eachChildTest(function (childTest) { childTest.finalize(true) })
            }

            if (!Joose.O.isEmpty(me.timeoutIds)) {
                if (
                    !me.__timeoutWarning && me.overrideSetTimeout && me.lastActivityDate &&
                    new Date() - me.lastActivityDate > me.defaultTimeout * 2
                ) {
                    me.diag(R.get('testStillRunning'));
                    me.warn(R.get('testNotFinalized').replace('{url}', me.url));
                    me.__timeoutWarning = true;
                }

                return
            }

            if (!me.isDone && me.doDone(force) === false) return 
            
            me.finalizationStarted  = true

            var finalizationCode    = function (tearDownError) {
                if (tearDownError) me.fail(tearDownError)
                
                me.endDate          = new Date() - 0
    
                if (!me.parent) me.addResult(new Siesta.Result.Summary({
                    isFailed            : me.isFailed(),
                    description         : me.getSummaryMessage()
                }))
                
                me.onTestFinalize()
                
                /**
                 * This event is fired when an individual test case ends (either because it has completed correctly or thrown an exception).
                 *
                 * This event bubbles up to the {@link Siesta.Harness harness}, so you can observe it on the harness as well.
                 *
                 * @event testfinalize
                 * @member Siesta.Test
                 * @param {JooseX.Observable.Event} event The event instance
                 * @param {Siesta.Test} test The test instance that just has completed
                 */
                me.fireEvent('testfinalize', me);
    
                // a test end event that bubbles
                me.fireEvent('testendbubbling', me);
    
                me.callback && me.callback()
                
                // help garbage collector to cleanup all the context of this callback (huge impact)
                me.callback         = null
            }
            
            // sub-tests don't do the "tearDown" process
            if (me.parent || me.reusingSandbox) {
                finalizationCode()
                
                return
            }
            
            var originalSetTimeout      = me.originalSetTimeout
            var originalClearTimeout    = me.originalClearTimeout
            
            var hasTimedOut     = false
            
            var timeout         = originalSetTimeout(function () {
                hasTimedOut     = true
                
                finalizationCode(R.get('testTearDownTimeout'))
            }, me.isReadyTimeout)
            
            me.tearDown(function () {
                originalClearTimeout(timeout)
                
                if (!hasTimedOut) finalizationCode()
            }, function (error) {
                originalClearTimeout(timeout)
                
                if (!hasTimedOut) finalizationCode(error)
            })
        },
        
        
        onBeforeTestFinalize : function () {
        },
        
        
        onTestFinalize : function () {
        },


        onTestStart : function () {
        },
        
        
        getSummaryMessage : function (lineBreaks) {
            var res             = []

            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned
            var total           = failCount + passCount

            res.push('Passed: ' + passCount)
            res.push('Failed: ' + failCount)

            if (!this.failed) {
                // there was a t.plan() call
                if (assertPlanned != null) {
                    if (total < assertPlanned)
                        res.push('Looks like you planned ' + assertPlanned + ' tests, but ran only ' + total)

                    if (total > assertPlanned)
                        res.push('Looks like you planned ' + assertPlanned + ' tests, but ran ' +  (total - assertPlanned) + ' extra tests, ' + total + ' total.')

                    if (total == assertPlanned && !failCount) res.push('All tests passed')
                } else {
                    var R = Siesta.Resource('Siesta.Test');

                    if (!this.isDoneCorrectly()) res.push(R.get('missingDoneCall'))

                    if (this.isDoneCorrectly() && !failCount) res.push(R.get('allTestsPassed'))
                }
            }

            return lineBreaks ? res.join(lineBreaks) : res
        },


        /**
         * This method indicates that the test has reached the expected point of its completion and no more assertions are planned. 
         * Adding assertions after the call to `done` will be considered as a failure.
         * 
         * This method **does not** stop the execution of the test. For that, see the {@link #exit} method.
         * 
         * See also {@link Siesta.Harness#needDone}
         *
         *
         * @param {Number} delay Optional. When provided, the test will not complete right away, but will wait for `delay` milliseconds for additional assertions.
         */
        done : function (delay) {
            var me                      = this

            if (delay) {
                var async               = this.beginAsync()
                var originalSetTimeout  = this.originalSetTimeout

                originalSetTimeout(function () {
                    me.endAsync(async)
                    me.done()
                }, delay)

            } else {
                this.doDone(false)
                
                if (this.processed) this.finalize()
            }
        },

        
        doDone : function (force) {
            var me          = this
            
            // this is the early "testfinalize" hook, we need "early" and "regular" hooks, since we want the globals check to be the last assertion
            me.fireEvent('beforetestfinalizeearly', me)

            // Firing the `beforetestfinalizeearly` events may trigger additional test actions
            if (!Joose.O.isEmpty(me.timeoutIds)) {
                if (force)
                    me.clearTimeouts()
                else
                    return false
            }
            
            // assertion can stil be added in this method and the following event listeners
            // but not after!
            me.onBeforeTestFinalize()

            /**
             * This event is fired before each individual test case ends (no any corresponding Harness actions will have been run yet).
             *
             * This event bubbles up to the {@link Siesta.Harness harness}, so you can observe it on the harness as well.
             *
             * @event beforetestfinalize
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that is about to finalize
             */
            me.fireEvent('beforetestfinalize', me);
            
            this.isDone     = true
        },

        // `isDoneCorrectly` means that either test does not need the call to `done`
        // or the call to `done` has been already made
        isDoneCorrectly : function () {
            return !this.needDone || this.isDone
        },


        getAssertionCount : function (excludeTodo) {
            var count   = 0

            this.eachAssertion(function (assertion) {
                if (!excludeTodo || !assertion.isTodo) count++
            })

            return count
        },


        // cached method except the "includeTodo" case
        getPassCount : function (includeTodo) {
            if (this.$passCount != null && !includeTodo) return this.$passCount

            var passCount = 0

            this.eachAssertion(function (assertion) {
                if (assertion.passed && (includeTodo || !assertion.isTodo)) passCount++
            })

            return includeTodo ? passCount : this.$passCount = passCount
        },

        getTodoPassCount : function () {
            var todoCount = 0;

            this.eachAssertion(function (assertion) {
                if (assertion.isTodo && assertion.passed) todoCount++;
            });

            return todoCount;
        },

        getTodoFailCount : function () {
            var todoCount = 0;

            this.eachAssertion(function (assertion) {
                if (assertion.isTodo && !assertion.passed) todoCount++;
            });

            return todoCount;
        },


        // cached method except the "includeTodo" case
        getFailCount : function (includeTodo) {
            if (this.$failCount != null && !includeTodo) return this.$failCount

            var failCount = 0

            this.eachAssertion(function (assertion) {
                if (!assertion.passed && (includeTodo || !assertion.isTodo)) failCount++
            })

            return includeTodo ? failCount : this.$failCount = failCount
        },


        getFailedAssertions : function () {
            var failed      = [];

            this.eachAssertion(function (assertion) {
                if (!assertion.isPassed()) failed.push(assertion)
            })

            return failed
        },


        isPassed : function () {
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned

            return this.isFinished() && !this.failed && !failCount && (
                assertPlanned != null && passCount == assertPlanned
                    ||
                assertPlanned == null && this.isDoneCorrectly()
            )
        },


        isFailed : function () {
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned

            return this.failed || failCount || (

                this.isFinished() && (
                    assertPlanned != null && passCount != assertPlanned
                        ||
                    assertPlanned == null && !this.isDoneCorrectly()
                )
            )
        },


        isFailedWithException : function () {
            return this.failed
        },


        isStarted : function () {
            return this.startDate != null
        },


        isFinished : function () {
            return this.endDate != null
        },


        getDuration : function () {
            return this.endDate - this.startDate
        },


        getBubbleTarget : function () {
            return this.parent || this.harness;
        },


        warn : function (message) {
            this.addResult(new Siesta.Result.Diagnostic({
                description : message,
                isWarning   : true
            }))
        },


        flattenArray : function (array) {
            var me          = this
            var result      = []

            Joose.A.each(array, function (el) {
                if (me.typeOf(el) == 'Array')
                    result.push.apply(result, me.flattenArray(el))
                else
                    result.push(el)
            })

            return result
        },


        trimString : function (string) {
            // "polyfill" regexp from MDN
            // Make sure we trim BOM and NBSP
            return String(string).replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
        },


        buildActionableMethods : function () {
            var methods     = {}

            this.meta.getMethods().each(function (method, name) {
                methods[ name.toLowerCase() ] = name
            })

            return methods
        },


        getJUnitClass : function () {
            return this.jUnitClass || this.meta.name || 'Siesta.Test'
        },
        
        
        // to give test scripts access to locales
        resource : function () {
            return Siesta.Resource.apply(Siesta.Resource, arguments)
        },
        
        
        getRootTest : function () {
            var root        = this
            
            while (root.parent) root = root.parent
            
            return root
        }
    }
    // eof methods

})
//eof Siesta.Test;
Singleton('Siesta.Test.ActionRegistry', {
    
    has : {
        actionClasses       : Joose.I.Object
    },

    
    methods : {
        
        registerAction : function (name, constructor) {
            this.actionClasses[ name.toLowerCase() ] = constructor
        },

        
        getActionClass : function (name) {
            return this.actionClasses[ name.toLowerCase() ]
        },
        
        
        create : function (obj, test, defaultArgs, initStep) {
            if (obj !== Object(obj)) throw "Action configuration should be an Object instance"

            if (!obj.action) {
                var actionClasses       = this.actionClasses
                var methods             = {}
                
                if (test) {
                    methods             = test.getActionableMethods()    
                }
                
                Joose.O.eachOwn(obj, function (value, key) {
                    var shortcut        = key.toLowerCase()

                    if (actionClasses[ shortcut ]) {
                        obj.action      = shortcut
                        
                        switch (shortcut) {
                            case 'setvalue' :
                            case 'waitfor'  :
                            // do nothing 
                            break
                            
                            case 'type'     :
                                obj.text        = value
                            break

                            default         :
                                obj.target      = value
                        }
                        
                        return false
                    } else if (methods[ shortcut ]) {
                        if (shortcut.match(/^waitFor/i)) {
                            obj.action      = 'wait'
                            obj.waitFor     = methods[ shortcut ]
                            obj.args        = value || []
                        } else {
                            obj.action      = 'methodCall'
                            obj.methodName  = methods[ shortcut ]
                            obj.args        = value || []
                        }
                        
                        return false
                    }
                })
            }
            
            if (!obj.action) throw "Need to include `action` property or shortcut property in the step config"
            
            // Don't get the arguments from the previous step if it is a waitFor action, 
            // it does not make sense and messes up the arguments
            if (obj.action != 'wait' && obj.action != 'waitfor' && obj.action != 'delay' && obj.action != 'methodCall') {
                if (!obj.args && defaultArgs) obj.args = defaultArgs
            }
            
            var actionClass = this.getActionClass(obj.action)
            
            // if there's `initStep` function - overwrite the "next" function anyway
            if (!obj.next || initStep) obj.next     = initStep(actionClass.prototype.hasOwnAsyncFrame).next
            if (!obj.test || test) obj.test     = test

            return new actionClass(obj)
        }
    }
});
;
/**
@class Siesta.Test.Action

Base class for {@link Siesta.Test#chain} actions.

*/
Class('Siesta.Test.Action', {
    
    has : {
        args                : null, 
        
        /**
         * @cfg {String} desc When provided, once step is completed, a passing assertion with this text will be added to a test.
         * This configuration option can be useful to indicate the progress of "wait" steps  
         */
        desc                : null,
        test                : { required : true },
        next                : { required : true },
        
        requiredTestMethod  : null
    },

    
    methods : {
        
        initialize : function () {
            var requiredTestMethod  = this.requiredTestMethod
            
            // additional sanity check
            if (requiredTestMethod && !this.test[ requiredTestMethod ]) 
                throw new Error(Siesta.Resource('Siesta.Test.Action','missingTestAction').replace('{0}', this.meta.name).replace('{1}', requiredTestMethod))
        },
        
        
        process : function () {
            this.next()
        }
    }
});
;
/**

@class Siesta.Test.Action.Done
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with "done" shortcut:

    t.chain(
        {
            action      : 'done'
        }
    )

This action will just call the {@link Siesta.Test#done done} method of the test.

*/
Class('Siesta.Test.Action.Done', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Number} delay
         * 
         * An optional `delay` argument for {@link Siesta.Test#done done} call.
         */
        delay  :        null
    },

    
    methods : {
        
        process : function () {
            this.test.done(this.delay)
            
            this.next()
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('done', Siesta.Test.Action.Done);
/**

@class Siesta.Test.Action.Wait
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with "wait" or "delay" shortcuts:

    t.chain(
        {
            action      : 'wait',   // or "delay"
            delay       : 1000      // 1 second
        }
    )

Alternatively, for convenience, this action can be included in the chain using "waitFor" config (the "action" property can be omitted):

    t.chain(
        {
            waitFor     : 'selector',           // or any other waitFor* method name
            args        : [ '.x-grid-row' ]     // an array of arguments for the specified method
        }
    )
    
    t.chain(
        {
            waitFor     : 'rowsVisible',        // or any other waitFor* method name
            args        : [ grid ]              // an array of arguments for the specified method
        }
    )
    
    t.chain(
        {
            waitFor     : 'waitForRowsVisible', // full method name is also ok
            args        : grid                  // a single value will be converted to array automatically
        }
    )
    
In the latter case, this action will perform a call to the one of the `waitFor*` methods of the test instance.
The name of the method is computed by prepending the uppercased value of `waitFor` config with the string "waitFor" 
(unless it doesn't already start with "waitFor").
The arguments for method call can be provided as the "args" array. Any non-array value for "args" will be converted to an array with one element.
* **Note**, that this action will provide a `callback`, `scope`, and `timeout` arguments for `waitFor*` methods - you should not specify them. 


As a special case, the value of `waitFor` config can be a Number or Function - that will trigger the call to {@link Siesta.Test#waitFor} method with provided value:

    t.chain(
        {
            waitFor     : 500
        },
        // same as
        {
            waitFor     : '',
            args        : [ 500 ] 
        },
        {
            waitFor     : function () { return document.body.className.match(/someClass/) }
        }
    )

*/
Class('Siesta.Test.Action.Wait', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Number} delay
         * 
         * A number of milliseconds to wait before continuing.
         */
        delay           : 1000,
        
        /**
         * @cfg {Number} timeout
         * 
         * The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        timeout         : null,

        /**
         * @cfg {Array/Function} args
         * 
         * The array of arguments to pass to waitForXXX method. You should omit the 3 last parameters: callback, scope, timeout. Any non-array value will be converted to 
         * a single-value array. Can be also a function, returning either an array of a single value, which will be converted to array.
         * Function will be called using test instance as a "this" scope.
         * If you need to pass a function, as an argument, wrap in the array. Compare: 
    {
        waitFor : 'SomeCondition',
        // will be called when processing the action, should return an array of arguments
        args    : function () {} 
    }
    
    {
        waitFor : 'SomeCondition',
        // won't be called, instead will be passed as 1st argument
        args    : [ function () {} ] 
    }
         *  
         */
        args            : Joose.I.Array,

        /**
         * @cfg {String} waitFor
         * 
         * The name of the `waitFor` method to call. You can omit the leading "waitFor":
         * 

    t.chain(
        {
            waitFor     : 'selector',
            ...
        },
        // same as
        {
            waitFor     : 'waitForSelector',
            ...
        }
    )
         * 
         */
        waitFor         : null,
        
        
        /**
         * @cfg {Object/Function} trigger 
         * 
         * A config object for the action that should trigger the waiting condition. Can be also a regular function to execute. 
         * An action or function will be executed right *after* the waiting has started, to avoid the race conditions. 
         * 
         * To illustrate, imagine, when clicking on some button, new data package will be loaded and some event `dataloaded` 
         * will be fired. We want to wait for that event. Usually, you will write this as the following action steps, in the `chain` method:
         * 

    t.chain(
        { click : '.someButton' },
        { waitFor : 'Event', args : [ someDataStorage, 'dataload' ] },
        ...
    )

         * However, imagine loading mechanism implements caching, and sometimes loading happens *synchronously*. In this case,
         * the `dataload` event will be also fired synchronously, right during the "onclick" handler of the button. Then, we'll start
         * waiting for that event (which has already been fired) and the `waitFor` action will fail.
         * 
         * To avoid this race condition, we need to first start waiting for the event, and only then - perform a click:
         * 

    t.chain(
        function (next) {
            t.waitForEvent(someDataStorage, 'dataload', next);
            
            t.click('.someButton', function () {})
        },
        ...
    )

         * or, using `trigger` config:

    t.chain(
        { 
            waitFor : 'Event', 
            args    : [ someDataStorage, 'dataload' ],
            trigger : { click : '.someButton' } 
        },
        ...
    )

         */
        trigger         : null,

        hasOwnAsyncFrame    : true,
        description         : '' // used internally to have custom wait messages that don't produce noise in the UI (chain step automatically adds a t.pass with 'desc')
    },

    
    methods : {
        
        process : function () {
            var waitFor     = this.waitFor;
            var test        = this.test

            if (test.typeOf(waitFor) === 'Number' || test.typeOf(waitFor) === 'Function') {
                // Caller supplied a function returning true when done waiting or
                // a number of milliseconds to wait for.
                this.args   = [ waitFor ];
                waitFor     = '';
            }
            
            if (waitFor == null) {
                this.args   = [ this.delay ];
                waitFor     = '';
            }
            
            // special case for { waitForFn : function () {} }" - we consider the function here
            // not a function which should return an array with arguments for the "waitFor" method
            // (which is a usual behavior for { someMehthod : function () {} } ), but the `waitFor` checker function itself
            if (test.typeOf(this.args) === "Function" && waitFor != 'waitForFn') {
                this.args   = this.args.call(test, this);
            }
            
            if (test.typeOf(this.args) !== "Array") {
                this.args   = [ this.args ];
            }

            // also allow full method names
            waitFor         = waitFor.replace(/^waitFor/, '')
            var methodName  = 'waitFor' + Joose.S.uppercaseFirst(waitFor);
            
            if (!test[ methodName ]){
                throw Siesta.Resource("Siesta.Test.Action.Wait", 'missingMethodText') + methodName;
            }
            
            // If using simple waitFor statement, use the object notation to be able to pass a description
            // which gives better debugging help than "Waited too long for condition to be fulfilled".
            if (methodName === 'waitFor') {
                test.waitFor({
                    method          : this.args[ 0 ],
                    callback        : this.next,
                    scope           : test,
                    timeout         : this.timeout || test.waitForTimeout,
                    description     : this.description || this.desc || ''
                });
            } else {
                test[ methodName ].apply(test, this.args.concat(this.next, test, this.timeout || test.waitForTimeout));
            }
            
            var trigger     = this.trigger
            
            if (trigger) {
                if (test.typeOf(trigger) == 'Function') 
                    trigger.call(test, test)
                else {
                    if (!(trigger instanceof Siesta.Test.Action)) {
                        trigger.next        = function () {}
                        trigger.test        = this.test
                        
                        trigger             = Siesta.Test.ActionRegistry().create(trigger, test)
                    }
                    
                    trigger.process()
                }
            }
            
        }
    }
});

Joose.A.each([ 'wait', 'waitFor', 'delay' ], function(name) {
    Siesta.Test.ActionRegistry().registerAction(name, Siesta.Test.Action.Wait);
});;
/**

@class Siesta.Test.Action.Eval
@extends Siesta.Test.Action

This action can be included in the `t.chain` steps only with a plain string. Siesta will examine the passed string,
and call an apropriate method of the test class. String should have the following format: 
    
    methodName(params) 

Method name is anything until the first parenthes. Method name may have an optional prefix `t.`. 
Everything in between of outermost parentheses will be treated as parameters for method call. For example:

    t.chain(
        // string should look like a usual method call, 
        // but arguments can't reference any variables
        // strings should be quoted, to include quoting symbol in string use double slash: \\
        't.click("combo[type=some\\"Type] => .x-form-trigger")',
        
        // leading "t." is optional, but quoting is not
        'waitForComponent("combo[type=someType]")',
        
        // JSON objects are ok, but they should be a valid JSON - ie object properties should be quoted
        'myClick([ 10, 10 ], { "foo" : "bar" })',
    )
    
* **Note** You can pass the JSON objects as arguments, but they should be serialized as valid JSON - ie object properties should be quoted.
    
* **Note** A callback for next step in chain will be always appended to provided parameters. Make sure it is placed in a correct spot!
For example if method signature is `t.someMethod(param1, param2, callback)` and you are calling this method as:
    
    t.chain(
        `t.someMethod("text")`
    )
it will fail - callback will be provided in place of `param2`. Instead call it as: 
    
    t.chain(
        `t.someMethod("text", null)`
    )

This action may save you few keystrokes, when you need to perform some action with static arguments (known prior the action).

*/
Class('Siesta.Test.Action.Eval', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        actionString          : null
    },

    
    methods : {
        
        process : function () {
            var test            = this.test
            var parsed          = this.parseActionString(this.actionString)
            
            if (parsed.error) {
                test.fail(parsed.error)
                this.next()
                return
            }
            
            var methodName      = parsed.methodName
            
            if (!methodName || test.typeOf(test[ methodName ]) != 'Function') {
                test.fail(Siesta.Resource("Siesta.Test.Action.Eval", 'invalidMethodNameText') + methodName)
                this.next()
                return
            }
            
            parsed.params.push(this.next)
            
            test[ methodName ].apply(test, parsed.params)
        },
        
        
        parseActionString : function (actionString) {
            var match           = /^\s*(.+?)\(\s*(.*)\s*\)\s*$/.exec(actionString)
            
            if (!match) return {
                error       : Siesta.Resource("Siesta.Test.Action.Eval", 'wrongFormatText') + actionString
            }
            
            var methodName      = match[ 1 ].replace(/^t\./, '')
            
            try {
                var params      = JSON.parse('[' + match[ 2 ] + ']')
            } catch (e) {
                return {
                    error       : Siesta.Resource("Siesta.Test.Action.Eval", 'parseErrorText') + match[ 2 ]
                }
            }
            
            return {
                methodName      : methodName,
                params          : params
            }
        }
    }
});
;
/**

@class Siesta.Test.Action.MethodCall
@extends Siesta.Test.Action

This action allows you to call any method of the test class. You can add it to the `chain` method by providing a property in the config object,
which corresponds to some method of the test class. The value of this property should contain arguments for the method call (see {@link #args}).

    t.chain(
        function (next) {
            t.someMethodCall('arg1', 'arg2', next)
        },
        // or
        {
            someMethodCall  : [ 'arg1', 'arg2' ]
        },
        ...
        {
            waitForSelector : '.selector'
        }
    )
    

*/
Class('Siesta.Test.Action.MethodCall', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {String} methodName
         *
         * A name of the method to call.
         */
        methodName      : null,
        
        /**
         * @cfg {Array/Function/Object} args
         *
         * Arguments for the method call. Usually should be an array. 
         * 
         * If its a function, then the function will be called at the action execution time and result from the 
         * action will be treated as `args`. The only exception is the "waitForFn" method, for which the supplied function
         * will be treated as the 1st argument for the "waitForFn" method. 
         * 
         * Anything else will be converted to a single element array. 
         * 
         * The callback will be added as the last argument (after resolving this config), unless the {@link #callbackIndex} is specified.
         */
        args            : null,
        
        /**
         * @cfg {Number} callbackIndex An index in the {@link #args} array where the callback should be inserted. 
         */
        callbackIndex   : null
    },

    
    methods : {
        
        process : function () {
            var test            = this.test
            var methodName      = this.methodName
            var args            = this.args
            
            if (test.typeOf(args) == 'Function') args  = args.call(test, this)
            
            if (test.typeOf(args) == 'Array') {
                args = args.slice();
            } else {
                args = [ args ]
            }
            
            if (this.callbackIndex != null) 
                args.splice(this.callbackIndex, 0, this.next)
            else
                args.push(this.next)
            
            test[ methodName ].apply(test, args)
        }
    }
});

Siesta.Test.ActionRegistry().registerAction('methodCall', Siesta.Test.Action.MethodCall)
;
/**

@class Siesta.Harness

`Siesta.Harness` is an abstract base harness class in Siesta hierarchy. This class provides no UI, 
you should use one of it subclasses, for example {@link Siesta.Harness.Browser}

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.


Synopsys
========

    var harness,
        isNode        = typeof process != 'undefined' && process.pid
    
    if (isNode) {
        harness = require('siesta');
    } else {
        harness = new Siesta.Harness.Browser();
    }
        
    
    harness.configure({
        title     : 'Awesome Test Suite',
        
        transparentEx       : true,
        
        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],
        
        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })
    
    
    harness.start(
        // simple string - url relative to harness file
        'sanity.t.js',
        
        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',
            
            // replace `preload` option of harness
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },
        
        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',
            
            autoCheckGlobals    : false,
            
            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/


Class('Siesta.Harness', {
    
    does        : [
        JooseX.Observable,
        Siesta.Util.Role.CanGetType
    ],
    
    has : {
        /**
         * @cfg {String} title The title of the test suite. Can contain HTML. When provided in the test file descriptor - will change the name of test in the harness UI.
         */
        title               : null,
        
        /**
         * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test}.
         * You can subclass {@link Siesta.Test} and provide a new class. 
         * 
         * This option can be also specified in the test file descriptor. 
         */
        testClass           : Siesta.Test,
        contentManagerClass : Siesta.Content.Manager,
        
        // fields of test descriptor:
        // - id - either `url` or wbs + group - computed
        // - url
        // - isMissing - true if test file is missing
        // - testCode - a test code source (can be provided by user)
        // - testConfig - config object provided to the StartTest
        // - index - (in the group) computed
        // - scopeProvider
        // - scopeProviderConfig
        // - preload
        // - alsoPreload
        // - parent - parent descriptor (or harness for top-most ones) - computed
        // - preset - computed by harness - instance of Siesta.Content.Preset
        // - forceDOMVisible - true to show the <iframe> on top of all others when running this test
        //                     (required for IE when using "document.getElementFromPoint()") 
        // OR - object 
        // - group - group name
        // - items - array of test descriptors
        // - expanded - initial state of the group (true by default)
        descriptors         : Joose.I.Array,
        descriptorsById     : Joose.I.Object,
        
        launchCounter       : 0,
        
        launches            : Joose.I.Object,
        
        scopesByURL         : Joose.I.Object,
        testsByURL          : Joose.I.Object,
        
        /**
         * @cfg {Boolean} transparentEx When set to `true` harness will not try to catch any exception, thrown from the test code.
         * This is very useful for debugging - you can for example use the "break on error" option in Firebug.
         * But, using this option may naturally lead to unhandled exceptions, which may leave the harness in incosistent state - 
         * refresh the browser page in such case.
         *  
         * Defaults to `false` - harness will do its best to detect any exception thrown from the test code.
         * 
         * This option can be also specified in the test file descriptor. 
         */
        transparentEx       : false,
        
        scopeProviderConfig     : null,
        scopeProvider           : null,
        
        /**
         * @cfg {String} runCore Either `parallel` or `sequential`. Indicates how the individual tests should be run - several at once or one-by-one.
         * Default value is "parallel". You do not need to change this option usually.
         */
        runCore                 : 'parallel',
        
        /**
         * @cfg {Number} maxThreads The maximum number of tests running at the same time. Only applicable for `parallel` run-core.
         */
        maxThreads              : 4,
        
        /**
         * @cfg {Boolean} autoCheckGlobals When set to `true`, harness will automatically issue an {@link Siesta.Test#verifyGlobals} assertion at the end of each test,
         * so you won't have to manually specify it each time. The assertion will be triggered only if test completed successfully. Default value is `false`.
         * See also {@link #expectedGlobals} configuration option and {@link Siesta.Test#expectGlobals} method.
         * 
         * This option will be always disabled in Opera, since every DOM element with `id` is being added as a global symbol in it.
         * 
         * This option can be also specified in the test file descriptor.
         */
        autoCheckGlobals        : false,
        
        disableGlobalsCheck     : false,
        
        /**
         * @cfg {Array} expectedGlobals An array of properties names which are likely to present in the scope of each test. There is no need to provide the name
         * of built-in globals - harness will automatically scan them from the empty context. Only provide the names of global properties which will be created
         * by your preload code.
         * 
         * For example
         * 
    harness.configure({
        title               : 'Ext Scheduler Test Suite',
        
        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'MyProject',
            'SomeExternalLibrary'
        ],
        ...
    })
            
         * This option can be also specified in the test file descriptor.
         */
        expectedGlobals         : Joose.I.Array,
        // will be populated by `populateCleanScopeGlobals` 
        cleanScopeGlobals       : Joose.I.Array,
        
        /**
         * @cfg {Array} preload The array which contains the *preload descriptors* describing which files/code should be preloaded into the scope of each test.
         * 
         * Preload descriptor can be:
         * 
         * - a string, containing an url to load (cross-domain urls are ok, if url ends with ".css" it will be loaded as CSS)
         * - an object `{ type : 'css/js', url : '...' }` allowing to specify the CSS files with different extension
         * - an object `{ type : 'css/js', content : '...' }` allowing to specify the inline content for script / style. The content should only be the tag content - not the tag itself, it'll be created by Siesta.
         * - an object `{ text : '...' }` which is a shortcut for `{ type : 'js', content : '...' }`
         * 
         * For example:
         * 
    harness.configure({
        title           : 'Ext Scheduler Test Suite',
        
        preload         : [
            'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            {
                text    : 'MySpecialGlobalFunc = function () { if (typeof console != "undefined") ... }'
            }
        ],
        ...
    })
            
         * This option can be also specified in the test file descriptor. **Note**, that if test descriptor has non-empty 
         * {@link Siesta.Harness.Browser#pageUrl pageUrl} option, then *it will not inherit* the `preload` option 
         * from parent descriptors or harness, **unless** it has the `preload` config set to string `inherit`. 
         * If both `pageUrl` and `preload` are set on the harness level, `preload` value still will be inherited. For example:
         *
    harness.configure({
        pageUrl     : 'general-page.html',
        preload         : [ 'my-file.js' ],
        ...
    })
    
    harness.start(
        // this test will inherit both `pageUrl` and `preload`
        'test1.js',
        {
            // no preloads inherited
            pageUrl     : 'host-page.html',
            url         : 'test2.js'
        }, 
        {
            // inherit `preload` value from the upper level - [ 'my-file.js' ]
            pageUrl     : 'host-page.html',
            preload     : 'inherit',
            url         : 'test3.js'
        }, 
        {
            group       : 'Some group',
            pageUrl     : 'host-page2.html',
            preload     : 'inherit',
            
            items           : [
                {
                    // inherit `pageUrl` value from the group
                    // inherit `preload` value from the upper level - [ 'my-file.js' ]
                    url     : 'test3.js'
                }
            ]
        }
    )
    
         * When using the code coverage feature, one need to explicitly mark the JavaScript files that needs to be instrumented with the "instrument : true".
         * See {@link Siesta.Harness.Browser#enableCodeCoverage} for details.
         * 

    harness.configure({
        preload         : [
            {
                type        : 'js',
                url         : 'some_file.js',
                instrument  : true
            }
        ],
        ...
    })


         *     
         *     
         */
        preload                 : Joose.I.Array,
        
        /**
         * @cfg {Array} alsoPreload The array with preload descriptors describing which files/code should be preloaded **additionally**.
         * 
         * This option can be also specified in the test file descriptor.
         */
        
        /**
         * @cfg {Object} listeners The object which keys corresponds to event names and values - to event handlers. If provided, the special key "scope" will be treated as the 
         * scope for all event handlers, otherwise the harness itself will be used as scope.
         * 
         * Note, that the events from individual {@link Siesta.Test test cases} instances will bubble up to the harness - you can listen to all of them in one place: 
         * 

    harness.configure({
        title     : 'Awesome Test Suite',
        
        preload : [
            'http://cdn.sencha.io/ext-4.1.0-gpl/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.1.0-gpl/ext-all-debug.js',
            
            'preload.js'
        ],
        
        listeners : {
            testsuitestart      : function (event, harness) {
                log('Test suite is starting: ' + harness.title)
            },
            testsuiteend        : function (event, harness) {
                log('Test suite is finishing: ' + harness.title)
            },
            teststart           : function (event, test) {
                log('Test case is starting: ' + test.url)
            },
            testupdate          : function (event, test, result) {
                log('Test case [' + test.url + '] has been updated: ' + result.description + (result.annotation ? ', ' + result.annotation : ''))
            },
            testfailedwithexception : function (event, test) {
                log('Test case [' + test.url + '] has failed with exception: ' + test.failedException)
            },
            testfinalize        : function (event, test) {
                log('Test case [' + test.url + '] has completed')
            }
        }
    })

         */
        
        
        /**
         * @cfg {Boolean} cachePreload When set to `true`, harness will cache the content of the preload files and provide it for each test, instead of loading it 
         * from network each time. This option may give a slight speedup in tests execution (especially when running the suite from the remote server), but see the 
         * caveats below. Default value is `false`.
         * 
         * Caveats: this option doesn't work very well for CSS (due to broken relative urls for images). Also its not "debugging-friendly" - as you will not be able 
         * to setup breakpoints for cached code. 
         */
        cachePreload            : false,
        
        mainPreset              : null,
        emptyPreset             : null,
        
        /**
         * @cfg {Number} keepNLastResults
         * 
         * Indicates the number of the test results which still should be kept, for user examination.
         * Results are cleared when their total number exceed this value, based on FIFO order.
         */
        keepNLastResults        : 2,
        
        lastResultsURLs         : Joose.I.Array,
        lastResultsByURL        : Joose.I.Object,
        
        /**
         * @cfg {Boolean} overrideSetTimeout When set to `true`, the tests will override the native "setTimeout" from the context of each test
         * for asynchronous code tracking. If setting it to `false`, you will need to use `beginAsync/endAsync` calls to indicate that test is still running.
         * 
         * Note, that this option may not work reliably, when used for several sub tests launched simultaneously (for example 
         * for several sibling {@link Siesta.Test#todo} sections.  
         * 
         * This option can be also specified in the test file descriptor. Defaults to `false`.
         */
        overrideSetTimeout      : false,
        
        /**
         * @cfg {Boolean} needDone When set to `true`, the tests will must indicate that that they have reached the correct 
         * exit point with `t.done()` call, after which, adding any assertions is not allowed. 
         * Using this option will ensure that test did not exit prematurely with some exception silently caught.
         * 
         * This option can be also specified in the test file descriptor.
         */
        needDone                : false,
        
        needToStop              : false,
        
        // the default timeout for tests will be increased when launching more than this number of files
        increaseTimeoutThreshold    : 8,
        
        // the start and end dates for the most recent `launch` method
        startDate               : null,
        endDate                 : null,
        
        /**
         * @cfg {Number} waitForTimeout Default timeout for `waitFor` (in milliseconds). Default value is 10000.
         * 
         * This option can be also specified in the test file descriptor.
         */
        waitForTimeout          : 10000,
        
        /**
         * @cfg {Number} defaultTimeout Default timeout for `beginAsync` operation (in milliseconds). Default value is 15000.
         * 
         * This option can be also specified in the test file descriptor.
         */
        defaultTimeout          : 15000,
        
        /**
         * @cfg {Number} subTestTimeout Default timeout for sub tests. Default value is twice bigger than {@link #defaultTimeout}.
         * 
         * This option can be also specified in the test file descriptor.
         */
        subTestTimeout          : null,
        
        /**
         * @cfg {Number} isReadyTimeout Default timeout for test start (in milliseconds). Default value is 15000. See {@link Siesta.Test#isReady} for details.
         * 
         * This option can be also specified in the test file descriptor.
         */
        isReadyTimeout          : 10000,
        
        /**
         * @cfg {Number} pauseBetweenTests Default timeout between tests (in milliseconds). Increase this settings for big test suites, to give browser time for memory cleanup.
         */
        pauseBetweenTests       : 10,
        
        
        /**
         * @cfg {Boolean} failOnExclusiveSpecsWhenAutomated When this option is enabled and Siesta is running in automation mode
         * (using WebDriver or PhantomJS launcher) any exclusive BDD specs found (like {@link Siesta.Test#iit t.iit} or {@link Siesta.Test#ddescribe t.ddescribe}
         * will cause a failing assertion. The idea behind this setting is that such "exclusive" specs should only be used during debugging
         * and are often mistakenly committed in the codebase, leaving other specs not executed. 
         * 
         * This option can be also specified in the test file descriptor.
         */
        failOnExclusiveSpecsWhenAutomated   : false,
        
        
        setupDone                   : false,
        
        sourceLineForAllAssertions  : false,
        
        currentLaunchId             : null,
        
        isAutomated                 : false,
        autoLaunchTests             : true
    },
    
    
    methods : {
        
        initialize : function () {
            var me      = this
            
            me.on('testupdate', function (event, test, result, parentResult) {
                me.onTestUpdate(test, result, parentResult);
            })
            
            me.on('testfailedwithexception', function (event, test, exception, stack) {
                me.onTestFail(test, exception, stack);
            })
            
            me.on('teststart', function (event, test) {
                me.onTestStart(test);
            })
            
            me.on('testfinalize', function (event, test) {
                me.onTestEnd(test);
            })
        },
        
        onTestUpdate : function (test, result, parentResult) {
        },
        
        
        onTestFail : function (test, exception, stack) {
        },
        
        
        onTestStart : function (test) {
        },
        
        
        onTestEnd : function (test) {
        },
        
        
        onTestSuiteStart : function (descriptors, contentManager, launchState) {
            this.startDate  = new Date()
            
            /**
             * This event is fired when the test suite starts. Note, that when running the test suite in the browser, this event can be fired several times
             * (for each group of tests you've launched).  
             * 
             * You can subscribe to it, using regular ExtJS syntax:
             * 
             *      harness.on('testsuitestart', function (event, harness) {}, scope, { single : true })
             * 
             * See also the "/examples/events"
             * 
             * @event testsuitestart
             * @member Siesta.Harness
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Harness} harness The harness that just has started
             */
            this.fireEvent('testsuitestart', this, launchState)
        },
        
        
        onTestSuiteEnd : function (descriptors, contentManager, launchState) {
            this.endDate    = new Date()
            
            /**
             * This event is fired when the test suite ends. Note, that when running the test suite in the browser, this event can be fired several times
             * (for each group of tests you've launched).  
             * 
             * @event testsuiteend
             * @member Siesta.Harness
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Harness} harness The harness that just has ended
             */
            this.fireEvent('testsuiteend', this, launchState)
        },
        
        
        onBeforeScopePreload : function (scopeProvider, url) {
            this.fireEvent('beforescopepreload', scopeProvider, url)
        },
        
        
        onAfterScopePreload : function (scopeProvider, url) {
            this.fireEvent('afterscopepreload', scopeProvider, url)
        },
        
        
        onCachingError : function (descriptors, contentManager) {
        },
        
        
        /**
         * This method configures the harness instance. It just copies the passed configuration option into harness instance.
         *
         * @param {Object} config - configuration options (values of attributes for this class)
         */
        configure : function (config) {
            Joose.O.copy(config, this)
            
            var me      = this
            
            if (config.listeners) Joose.O.each(config.listeners, function (value, name) {
                if (name == 'scope') return
                
                me.on(name, value, config.scope || me)
            })
        },
        
        
        // backward compat
        processPreloadArray : function (preload) {
            var me = this
            
            Joose.A.each(preload, function (url, index) {
                
                // do not process { text : "" } preload descriptors
                if (Object(url) === url) return 
                
                preload[ index ] = me.normalizeURL(url)
            })
            
            return preload
        },
        
        
        populateCleanScopeGlobals : function (scopeProvider, callback) {
            var scopeProviderClass  = eval(scopeProvider)
            var cleanScope          = new scopeProviderClass()
            
            var cleanScopeGlobals   = this.cleanScopeGlobals
            
            // we can also use "create" and not "setup" here
            // create will only create the iframe (in browsers) and will not try to update its content
            // the latter crashes IE8
            cleanScope.setup(function () {
                
                for (var name in cleanScope.scope) cleanScopeGlobals.push(name)
                
                callback()
                
                // this setTimeout seems to stop the spinning loading indicator in FF
                // accorting to https://github.com/3rd-Eden/Socket.IO/commit/bad600fb1fb70238f42767c56f01256470fa3c15
                // it only works *after* onload (this callback will be called *in* onload)
                
                setTimeout(function () {
                    // will remove the iframe (in case of browser harness) from DOM and stop loading indicator
                    cleanScope.cleanup()    
                }, 0)
            })
        },
        
        
        startSingle : function (desc, callback) {
            var me              = this
            
            this.__counter__    = this.__counter__ || 0 
            
            var startSingle     = function () {
                me.launch([ me.normalizeDescriptor(desc, me, me.__counter__++) ], callback)
            }
            
            me.setupDone ? startSingle() : this.setup(startSingle)
        },
        
        
        setup : function (callback) {
            var me              = this
            
            this.mainPreset     = new Siesta.Content.Preset({
                preload     : this.processPreloadArray(this.preload)
            })
            
            this.emptyPreset    = new Siesta.Content.Preset()
            
            me.normalizeDescriptors(me.descriptors)
            
            this.populateCleanScopeGlobals(this.scopeProvider, callback)
        },
        
        /**
         * This method will launch a test suite. It accepts a variable number of *test file descriptors* or an array of such. A test file descritor is one of the following:
         * 
         * - a string, containing a test file url. The url should be unique among all tests. If you need to re-use the same test
         * file, you can add an arbitrary query string to it: `my_test.t.js?copy=1`
         * - an object containing the `url` property `{ url : '...', option1 : 'value1', option2 : 'value2' }`. The `url` property should point to the test file.
         * Other properties can contain values of some configuration options of the harness (marked accordingly). In this case, they will **override** the corresponding values,
         * provided to harness or parent descriptor. 
         * - an object `{ group : 'groupName', items : [], expanded : true, option1 : 'value1' }` specifying the folder of test files. The `expanded` property
         * sets the initial state of the folder - "collapsed/expanded". The `items` property can contain an array of test file descriptors.
         * Other properties will override the applicable harness options **for all child descriptors**.
         * 
         * If test descriptor is `null` or other "falsy" value it is ignored.
         * 
         * Groups (folder) may contain nested groups. Number of nesting levels is not limited.
         * 
         * For example, one may easily have a special group of test files, having its own `preload` configuration (for example for testing on-demand loading). In the same
         * time some test in that group may have its own preload, overriding others.

    harness.configure({
        title           : 'Ext Scheduler Test Suite',
        preload         : [
            'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            '../awesome-app-all-debug.js'
        ],
        ...
    })
    
    harness.start(
        // regular file
        'data/crud.t.js',
        // a group with own "preload" config for its items
        {
            group       : 'On-demand loading',
            
            preload     : [
                'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
                'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            ],
            items       : [
                'ondemand/sanity.t.js',
                'ondemand/special-test.t.js',
                // a test descriptor with its own "preload" config (have the most priority)
                {
                    url         : 'ondemand/4-0-6-compat.t.js',
                    preload     : [
                        'http://cdn.sencha.io/ext-4.0.6/resources/css/ext-all.css',
                        'http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js',
                    ]
                },
                // sub-group
                {
                    group       : 'Sub-group',
                    items       : [
                        ...
                    ]
                }
            ]
        },
        ...
    )

         * Additionally, you can provide a test descriptor in the test file itself, adding it as the 1st or 2nd argument for `StartTest` call:  
         * 
    StartTest({
        autoCheckGlobals    : false,
        alsoPreload         : [ 'some_additional_preload.js' ]
    }, function (t) {
        ...
    }) 
         * 
         * Values from this object takes the highest priority and will override any other configuration.
         * 
         * Test descriptor may contain special property - `config` which will be applied to the test instance created. Be careful not to overwrite
         * standard properties and methods!
         * 

    harness.start(
        {
            url         : 'ondemand/4-0-6-compat.t.js',
            config      : {
                myProperty1     : 'value1',
                myProperty2     : 'value2'
            }
        },
        ...
    )
    
    StartTest(function (t) {
        if (t.myProperty1 == 'value1') {
            // do this
        }
        ...
    }) 

         * 
         * @param {Array/Mixed} descriptor1 or an array of descriptors
         * @param {Mixed} descriptor2
         * @param {Mixed} descriptorN
         */
        start : function () {
            var me          = Siesta.my.activeHarness = this
            
            me.descriptors  = this.flattenArray(arguments)

            // A system level descriptor used by the recorder
            me.descriptors.push({
                isSystemDescriptor  : true,
                url                 : '/'
            });

            this.setup(function () {
                me.setupDone        = true
                
                me.fireEvent('setupdone')
                
                if (me.autoLaunchTests) me.launch(me.descriptors)
            })
        },
        
        
        /**
         * This method will read the content of the provided `url` then will try to parse it as JSON
         * and pass to the regular {@link #start} method. The file on the `url` should contain
         * a valid JSON array object with test descriptors.
         * 
         * You can use this method in conjunction with the `bin/discover` utility, which can 
         * auto-discover the test files and generate a starter file for you. In such setup, it is convenient
         * to specify the test configs in the test file itself (see {@link #start} method for details).
         * However, in such setup, you can not use conditional processing of the descriptors set, so
         * you decide what fits best to your needs.
         * 
         * @param {String} url
         */
        startFromUrl : function (url) {
            var contentManager  = new this.contentManagerClass({
                harness         : this,
                presets         : [  new Siesta.Content.Preset({ preload : [ url ] }) ]
            })
            
            var me      = this
            
            contentManager.cache(function () {
                var content     = contentManager.getContentOf(url)
                
                try {
                    var descriptors     = JSON.parse(content)
                } catch (e) {
                    alert("The content of: " + url + " is not a valid JSON")
                    return
                }
                
                if (me.typeOf(descriptors) == 'Array')
                    me.start(descriptors)
                else {
                    alert("The content of: " + url + " is not an array")
                }
                
            }, function () {
                alert("Can not load the content of: " + url)
            })
        },
        
        
        // good to have this as a separate method for testing
        normalizeDescriptors : function (descArray) {
            var me              = this
            
            var descriptors     = []
            
            Joose.A.each(descArray, function (desc, index) {
                if (desc) descriptors.push(me.normalizeDescriptor(desc, me, index))
            })
            
            me.descriptors      = descriptors
        },

        
        launch : function (descriptors, callback, errback) {
            var launchId                = this.currentLaunchId  = ++this.launchCounter
            var me                      = this
            
            //console.time('launch')
            //console.time('launch-till-preload')
            //console.time('launch-after-preload')
            
            this.needToStop             = false
            
            // no folders, only leafs
            var flattenDescriptors      = this.flattenDescriptors(descriptors)
            // the preset for the test scripts files 
            var testScriptsPreset       = new Siesta.Content.Preset()
            var presets                 = [ testScriptsPreset, this.mainPreset ]
            
            var notLaunchedByAutomationId   = {}
            
            Joose.A.each(flattenDescriptors, function (desc) { 
                if (desc.preset != me.mainPreset && desc.preset != me.emptyPreset) presets.push(desc.preset)
                
                if (!desc.testCode) testScriptsPreset.addResource(desc.url)
                
                me.deleteTestByURL(desc.url)
                
                // only used in automation, where the `desc.automationElementId` is populated 
                notLaunchedByAutomationId[ desc.automationElementId ] = 1
            })
            
            // cache either everything (this.cachePreload) or only the test files (to be able to show missing files / show content) 
            var contentManager  = new this.contentManagerClass({
                harness         : this,
                presets         : [ testScriptsPreset ].concat(this.cachePreload ? presets : [])
            })
            
            var launchState     = this.launches[ launchId ] = {
                launchId            : launchId,
                increaseTimeout     : this.runCore == 'parallel' && flattenDescriptors.length > this.increaseTimeoutThreshold,
                descriptors         : flattenDescriptors,
                contentManager      : contentManager,
                notLaunchedByAutomationId   : notLaunchedByAutomationId
            }
            
            //console.time('caching')
            
            me.onTestSuiteStart(descriptors, contentManager, launchState)
            
            contentManager.cache(function () {
                
                //console.timeEnd('caching')
                
                Joose.A.each(flattenDescriptors, function (desc) {
                    var url             = desc.url
                    
                    if (contentManager.hasContentOf(url)) {
                        var testConfig  = desc.testConfig = Siesta.getConfigForTestScript(contentManager.getContentOf(url))
                        
                        // if testConfig contains the "preload" or "alsoPreload" key - then we need to update the preset of the descriptor
                        if (testConfig && (testConfig.preload || testConfig.alsoPreload)) desc.preset = me.getDescriptorPreset(desc)
                    } else
                        // if test code is provided, then test is considered not missing 
                        // allow subclasses to define there own logic when found missing test file
                        if (!desc.testCode) me.markMissingFile(desc)
                        
                    me.normalizeScopeProvider(desc)
                })
                
                me.fireEvent('testsuitelaunch', descriptors, contentManager, launchState)
                
                me.runCoreGeneral(flattenDescriptors, contentManager, launchState, launchState.callback = function () {
                    me.onTestSuiteEnd(descriptors, contentManager, launchState)
                    
                    callback && callback(descriptors)
                    
                    launchState.needToStop  = true
                    
                    delete me.launches[ launchId ]
                })
                
            }, function () {}, true)
        },
        
        
        markMissingFile : function (desc) {
            desc.isMissing = true
        },
        
        
        flattenDescriptors : function (descriptors, includeFolders) {
            var flatten     = []
            var me          = this
            
            Joose.A.each(descriptors, function (descriptor) {
                if (descriptor.group) {
                    if (includeFolders) flatten.push(descriptor)
                    
                    flatten.push.apply(flatten, me.flattenDescriptors(descriptor.items, includeFolders))
                } else
                    if (!descriptor.isSystemDescriptor) flatten.push(descriptor)
            })
            
            return flatten
        },
        
        
        lookUpValueInDescriptorTree : function (descriptor, configName, doNotLookAtRoot) {
            var testConfig  = descriptor.testConfig
            
            if (testConfig && testConfig.hasOwnProperty(configName))    return testConfig[ configName ]
            if (descriptor.hasOwnProperty(configName))                  return descriptor[ configName ]
            
            var parent  = descriptor.parent
            
            if (parent) {
                if (parent == this)
                    if (doNotLookAtRoot) 
                        return undefined
                    else
                        return this[ configName ]
                
                return this.lookUpValueInDescriptorTree(parent, configName, doNotLookAtRoot)
            }
            
            return undefined
        },
        

        getDescriptorConfig : function (descriptor, configName, doNotLookAtRoot) {
            var res     = this.lookUpValueInDescriptorTree(descriptor, configName, doNotLookAtRoot)
            
            if (res == null && configName == 'pageUrl')
                res     = this.lookUpValueInDescriptorTree(descriptor, 'hostPageUrl', doNotLookAtRoot)
            
            return res
        },
        
        
        getDescriptorPreset : function (desc) {
            var preload                 = this.getDescriptorConfig(desc, 'preload', true)
            var alsoPreload             = this.getDescriptorConfig(desc, 'alsoPreload', true)
            
            if (preload || alsoPreload) {
                var totalPreload        = (preload || this.preload).concat(alsoPreload || [])
                
                // filter out empty array as preloads - return `emptyPreset` for them
                return totalPreload.length ? new Siesta.Content.Preset({ preload : this.processPreloadArray(totalPreload) }) : this.emptyPreset
            }
                
            return this.mainPreset
        },
        
        
        normalizeScopeProvider : function (desc) {
            var scopeProvider = this.getDescriptorConfig(desc, 'scopeProvider')
            
            if (scopeProvider) {
                var match 
                
                if (match = /^=(.+)/.exec(scopeProvider))
                    scopeProvider = match[ 1 ]
                else 
                    scopeProvider = scopeProvider.replace(/^(Scope\.Provider\.)?/, 'Scope.Provider.')
            }
            
            desc.scopeProvider          = scopeProvider
            desc.scopeProviderConfig    = this.getDescriptorConfig(desc, 'scopeProviderConfig') 
        },
        
        
        normalizeDescriptor : function (desc, parent, index, level) {
            if (desc.normalized) return desc
            
            if (typeof desc == 'string') desc = { url : desc }
            
            level       = level || 0
            
            var me      = this
            
            desc.parent = parent
            
            // folder
            if (desc.group) {
                desc.id     = parent == this ? 'testFolder-' + level + '-' + index : parent.id + '/' + level + '-' + index
                
                var items   = []
                
                Joose.A.each(desc.items || [], function (subDesc, index) {
                    if (subDesc) items.push(me.normalizeDescriptor(subDesc, desc, index, level + 1))
                })
                
                desc.items  = items
                
            } else {
                // leaf case
                desc.id                     = desc.url
                desc.preset                 = this.getDescriptorPreset(desc)
                
                // the only thing left to normalize in the descriptor is now "scopeProvider"
                // we postpone this normalization to the moment after loading of the test files, 
                // since they can also contain "scopeProvider"-related configs
                // see "normalizeScopeProvider"
            }
            
            this.descriptorsById[ desc.id ] = desc
            
            desc.normalized     = true
            
            return desc
        },
        
        
        runCoreGeneral : function (descriptors, contentManager, launchState, callback) {
            var runCoreMethod   = 'runCore' + Joose.S.uppercaseFirst(this.runCore)
            
            if (typeof this[ runCoreMethod ] != 'function') throw new Error("Invalid `runCore` specified: [" + this.runCore + "]")
            
            this[ runCoreMethod ](descriptors, contentManager, launchState, callback)
        },
        
        
        runCoreParallel : function (descriptors, contentManager, launchState, callback) {
            var me              = this
            var processedNum    = 0
            var count           = descriptors.length
            
            if (!count) callback()
            
            var exitLoop                = false
            var hasExited               = false
            var hasLaunchedAllThreads   = false
            
            var doProcessURL  = function (desc) {
                me.processURL(desc, desc.index, contentManager, launchState, function () {
                    processedNum++
                    
                    // set the internal closure `exitLoop` to stop launching new branches
                    // on the 1st encountering of `me.needToStop` flag
                    if (me.needToStop || exitLoop || launchState.needToStop) {
                        exitLoop = true
                        
                        if (!hasExited) {
                            hasExited = true
                            callback()
                        }
                        
                        return
                    }
                    
                    if (processedNum == count) 
                        callback()
                    else
                        launchThread(descriptors)
                })
            }
            
            var launchThread  = function (descriptors) {
                var desc = descriptors.shift()
                
                if (!desc) return
                
                if (hasLaunchedAllThreads)
                    setTimeout(function () {
                        doProcessURL(desc)
                    }, me.pauseBetweenTests)
                else
                    doProcessURL(desc)
            }
            
            for (var i = 1; i <= this.maxThreads; i++) launchThread(descriptors)
            
            hasLaunchedAllThreads = true
        },
        
        
        runCoreSequential : function (descriptors, contentManager, launchState, callback) {
            if (descriptors.length && !this.needToStop && !launchState.needToStop) {
                var desc        = descriptors.shift()
                var me          = this
                
                this.processURL(desc, desc.index, contentManager, launchState, function () {

                    if (descriptors.length && !launchState.needToStop)
                        setTimeout(function () {
                            me.runCoreSequential(descriptors, contentManager, launchState, callback)
                        }, me.pauseBetweenTests)
                    else
                        callback()
                })
                
            } else
                callback()
        },
        
        
        getSeedingCode : function (desc, launchId) {
            var code    = function (descId, launchId) {
                StartTest = startTest = describe = function () { arguments.callee.args = arguments };
                
                StartTest.launchId          = launchId
                StartTest.id                = descId
                
                // for older IE - the try/catch should be from the same context as the exception
                StartTest.exceptionCatcher  = function (func) { var ex; try { func() } catch (e) { ex = e; } return ex == '__SIESTA_TEST_EXIT_EXCEPTION__' ? undefined : ex; };
                
                // for Error instances we try to pick up the values from "message" or "description" property
                // so need to have a correct constructor from the context of test
                StartTest.testErrorClass    = Error;
            }
            
            return ';(' + code.toString() + ')(' + JSON.stringify(desc.id) + ', ' + launchId + ')'
        },
        
        
        getScopeProviderConfigFor : function (desc, launchId) {
            var config          = Joose.O.copy(desc.scopeProviderConfig || {})
            
            config.seedingCode  = this.getSeedingCode(desc, launchId)
            config.launchId     = launchId
            
            return config
        },
        
        
        keepTestResult : function (url) {
            // already keeping 
            if (this.lastResultsByURL[ url ]) {
                var indexOf     = -1
                
                Joose.A.each(this.lastResultsURLs, function (resultUrl, i) { 
                    if (resultUrl == url) { indexOf = i; return false }
                })
                
                this.lastResultsURLs.splice(indexOf, 1)
                this.lastResultsURLs.push(url)
                
                return
            }
            
            this.lastResultsURLs.push(url)
            this.lastResultsByURL[ url ] = true
            
            if (this.lastResultsURLs.length > this.keepNLastResults) this.releaseTestResult()
        },
        
        
        releaseTestResult : function () {
            if (this.lastResultsURLs.length <= this.keepNLastResults) return
            
            var url     = this.lastResultsURLs.shift()
            
            delete this.lastResultsByURL[ url ]
            
            var test    = this.getTestByURL(url)
            
            if (test && test.isFinished()) this.cleanupScopeForURL(url)
        },
        
        
        isKeepingResultForURL : function (url) {
            return this.lastResultsByURL[ url ]
        },
        
        
        setupScope : function (desc, launchId) {
            var url                 = desc.url
            
            var alreadyExisting     = this.scopesByURL[ url ]
            // if test suite has been restarted at the "testsuitestart" point
            // then previous launch will concur the latest launch for the "this.scopesByURL" state
            // so we prevent the older launch to overwrite the newer
            var isOudatedRequest    = alreadyExisting && alreadyExisting.launchId > launchId
            
            var scopeProviderClass  = eval(desc.scopeProvider)
            
            var newProvider         = new scopeProviderClass(this.getScopeProviderConfigFor(desc, launchId))
            
            if (isOudatedRequest) {
                return newProvider
            } else {
                this.cleanupScopeForURL(url)
            
                this.keepTestResult(url)
                
                return this.scopesByURL[ url ] = newProvider
            }
        },
        
        
        cleanupScopeForURL : function (url) {
            var scopeProvider = this.scopesByURL[ url ]
            
            if (scopeProvider) {
                delete this.scopesByURL[ url ]
                
                scopeProvider.cleanup()
            }
        },


        // should prepare the "seedingScript" - include it to the `scopeProvider`
        prepareScopeSeeding : function (scopeProvider, desc, contentManager) {
            if (desc.testCode || this.cachePreload && contentManager.hasContentOf(desc.url))
                scopeProvider.addPreload({
                    type        : 'js', 
                    content     : desc.testCode || (contentManager.getContentOf(desc.url) + '\n//# sourceURL=' + desc.url)
                })
            else
                scopeProvider.seedingScript = this.resolveURL(desc.url, scopeProvider, desc)
        },

        
        // should normalize non-standard urls (like specifying Class.Name in preload)
        // such behavior is not documented and generally deprecated
        normalizeURL : function (url) {
            return url
        },
            
            
        resolveURL : function (url, scopeProvider, desc) {
            return url
        },
        
        
        canUseCachedContent : function (resource, desc) {
            return this.cachePreload && resource instanceof Siesta.Content.Resource.JavaScript
        },
        
        
        addCachedResourceToPreloads : function (scopeProvider, contentManager, resource, desc) {
            scopeProvider.addPreload({
                type        : 'js',
                content     : contentManager.getContentOf(resource)
            })
        },
        
        
        getOnErrorHandler : function (testHolder, preloadErrors) {
            var R = Siesta.Resource('Siesta.Harness');

            return function (msg, url, lineNumber, col, error) {
                var test            = testHolder.test

                // Either an HTMLElement load failure - "window.addEventListener('error', handler, true)"
                // OR
                // Error in a script on another domain (message Script error)
                if (arguments.length == 1) {
                    var event       = msg
                    
                    error           = event.error

                    if (event.target && event.target instanceof test.global.HTMLElement && !error) {
                        msg         = R.get('resourceFailedToLoad', { nodeName : event.target ? event.target.nodeName.toUpperCase() : ''});
                        url         = event.srcElement ? event.srcElement.href || event.srcElement.src : ''
                        lineNumber  = ''

                        test.fail(msg + ' ' + (event.target ? event.target.outerHTML : url));

                        return;
                    } else {
                        msg = event.message;
                        url = '';
                        lineNumber = 0;
                    }
                }

                if (test && test.isStarted()) {
                    test.nbrExceptions++;
                    test.failWithException(error || (msg + ' ' + url + ' ' + lineNumber))
                } else {
                    preloadErrors && preloadErrors.push({
                        isException     : true,
                        message         : error && error.stack ? error.stack + '' : msg + ' ' + url + ' ' + lineNumber
                    })
                }
            }
        },
        
        
        processURL : function (desc, index, contentManager, launchState, callback, noCleanup, sharedSandboxState) {
            var me      = this
            var url     = desc.url
            
            if (desc.isMissing) {
                callback()
                
                return
            }
            
            // a magical shared object, which will contain the `test` property with test instance, once the test will be created
            var testHolder      = {}
            // an array of errors occured during preload phase
            var preloadErrors   = []
            
            var onErrorHandler  = this.getOnErrorHandler(testHolder, preloadErrors)
            var scopeProvider   = this.setupScope(desc, launchState.launchId)
            var transparentEx   = this.getDescriptorConfig(desc, 'transparentEx')
            
            // trying to setup the `onerror` handler as early as possible - to detect each and every exception from the test
            scopeProvider.addOnErrorHandler(onErrorHandler, !transparentEx)
            
//            scopeProvider.addPreload({
//                type        : 'js', 
//                content     : 'console.time("scope-onload")'
//            })
            
            desc.preset.eachResource(function (resource) {
                var hasContent      = contentManager.hasContentOf(resource)
                
                if (hasContent && me.canUseCachedContent(resource, desc)) {
                    me.addCachedResourceToPreloads(scopeProvider, contentManager, resource, desc)
                } else {
                    var resourceDesc    = resource.asDescriptor()
                    
                    if (resourceDesc.url) resourceDesc.url = me.resolveURL(resourceDesc.url, scopeProvider, desc)
                    
                    scopeProvider.addPreload(resourceDesc)
                }
            })

            
            me.prepareScopeSeeding(scopeProvider, desc, contentManager)
            
            var testClass       = me.getDescriptorConfig(desc, 'testClass')
            if (me.typeOf(testClass) == 'String') testClass = Joose.S.strToClass(testClass)
            
            var testConfig      = me.getNewTestConfiguration(desc, scopeProvider, contentManager, launchState, sharedSandboxState)
            
            // create the test instance early, so that one can perform some setup (as the test class method call)
            // even before the "pageUrl" starts loading
            var test            = testHolder.test = new testClass(testConfig)
            
            this.onBeforeScopePreload(scopeProvider, url, test)
            
            test.earlySetup(function () {
                cont()
            }, function (errorMessage) {
                preloadErrors.push({ isException : false, message : errorMessage })
                
                cont()
            })
            
            function cont() {
                //console.timeEnd('launch-till-preload')
                
                //console.time('preload')
                
    //            scopeProvider.addPreload({
    //                type        : 'js', 
    //                content     : 'console.timeEnd("scope-onload")'
    //            })
                
                scopeProvider.setup(function (scopeProvider, failedPreloads) {
                    me.onAfterScopePreload(scopeProvider, url, test, failedPreloads)
                    
                    failedPreloads && Joose.O.each(failedPreloads, function (value, url) {
                        preloadErrors.unshift({ 
                            isException : false, 
                            message     : Siesta.Resource('Siesta.Harness', 'preloadHasFailed', { url : url })
                        })
                    })
                    
                    // scope provider has been cleaned up while setting up? (may be user has restarted the test)
                    // then do nothing
                    if (!scopeProvider.scope) { callback(); return }
                    
                    me.launchTest({
                        testHolder          : testHolder,
                        desc                : desc,
                        scopeProvider       : scopeProvider,
                        contentManager      : contentManager,
                        launchState         : launchState,
                        preloadErrors       : preloadErrors,
                        onErrorHandler      : onErrorHandler,
                        
                        // need to provide the "startTestAnchor" explicitly (and not just get from "scope" inside of the "launchTest"
                        // method, because for "separateContext" method, startAnchor is calculated differently
                        startTestAnchor     : scopeProvider.scope.StartTest,
                        noCleanup           : noCleanup,
                        reusingSandbox      : false
                    }, callback)
                })
            }
        },
        
        
        launchTest : function (options, callback) {
            var scopeProvider   = options.scopeProvider
            var desc            = options.desc
//            desc, scopeProvider, contentManager, options, preloadErrors, onErrorHandler, callback
            
            //console.timeEnd('preload')
            //console.timeEnd('launch-after-preload')
            var me              = this
            var url             = desc.url
        
            // after the scope setup, the `onerror` handler might be cleared - installing it again
            scopeProvider.addOnErrorHandler(options.onErrorHandler, !this.getDescriptorConfig(desc, 'transparentEx'))
            
            var test            = options.testHolder.test
            var startTestAnchor = options.startTestAnchor
            var args            = startTestAnchor && startTestAnchor.args
            var global          = scopeProvider.scope
            var noCleanup       = options.noCleanup
            var cleanupUrl      = options.cleanupUrl
            
            // additional setup of the test instance, setting up the properties, which are known only after scope
            // is loaded
            Joose.O.extend(test, {
                startTestAnchor     : startTestAnchor,
                exceptionCatcher    : startTestAnchor.exceptionCatcher,
                testErrorClass      : startTestAnchor.testErrorClass,
                
                global              : global,
                
                // the "options" part is used by the "separateContext" branch, where
                // the test script is executed in different context from the "global" context
                originalSetTimeout  : options.originalSetTimeout || global.setTimeout,
                originalClearTimeout: options.originalClearTimeout || global.clearTimeout,
                
                // pick either 1st or 2nd argument depending which one is a function 
                run                 : args && (typeof args[ 0 ] == 'function' ? args[ 0 ] : args[ 1 ]),
                
                reusingSandbox      : options.reusingSandbox,
                
                // "main" test callback, called once test is completed
                callback : function () {
                    if (!noCleanup && !me.isKeepingResultForURL(url)) {
                        // `cleanupUrl` will be different for shared sandbox tests
                        me.cleanupScopeForURL(cleanupUrl || url)
                    }
                    
                    callback && callback()
                }
            })
            
            this.saveTestWithURL(url, test)
            
            var doLaunch        = function() {
                // scope provider has been cleaned up while setting up? (may be user has restarted the test)
                // then do nothing
                if (!scopeProvider.scope) { callback(); return }
                
                //console.timeEnd('launch')
                
                me.fireEvent('beforeteststart', test)
                
                // in the edge case, test can be already finished before its even started :)
                // this happens if user re-launch the test during these 10ms - test will be 
                // finalized forcefully in the "deleteTestByUrl" method
                if (!test.isFinished()) 
                    if (test.start(options.preloadErrors) !== true)
                        // remove the test from the list of "not launched" only if there were no errors
                        // during test preload
                        delete options.launchState.notLaunchedByAutomationId[ desc.automationElementId ]
                
                options         = null
                test            = null
            }
            
            if (options.reusingSandbox)
                doLaunch()
            else {
                if (scopeProvider instanceof Scope.Provider.IFrame) 
                    // start the test after slight delay - to run it already *after* onload (in browsers)
                    global.setTimeout(doLaunch, 10)
                else
                    // for Window provider, `global.setTimeout` seems to not execute passed function _sometimes_
                    // also increase the "onload" delay
                    setTimeout(doLaunch, 50)
            }
        },
        
        
        getNewTestConfiguration : function (desc, scopeProvider, contentManager, launchState, sharedSandboxState) {
            var groups          = []
            var currentDesc     = desc.parent
            
            while (currentDesc) {
                // do not push name of the top-level "hidden" group which has no parent
                currentDesc.parent && groups.unshift(String(currentDesc.group))
                
                currentDesc     = currentDesc.parent
            }
            
            var config          = {
                url                 : desc.url,
                name                : desc.name,
                
                launchId            : launchState.launchId,
                
                automationElementId : desc.automationElementId,
                groups              : groups,
                jUnitClass          : this.getDescriptorConfig(desc, 'jUnitClass'),
            
                harness             : this,
            
                expectedGlobals     : this.cleanScopeGlobals.concat(this.getDescriptorConfig(desc, 'expectedGlobals')),
                autoCheckGlobals    : this.getDescriptorConfig(desc, 'autoCheckGlobals'),
                disableGlobalsCheck : this.disableGlobalsCheck,
            
                scopeProvider       : scopeProvider,
                
                contentManager      : contentManager,
                
                transparentEx       : this.getDescriptorConfig(desc, 'transparentEx'),
                needDone            : this.getDescriptorConfig(desc, 'needDone'),
                
                overrideSetTimeout          : this.getDescriptorConfig(desc, 'overrideSetTimeout'),
                
                defaultTimeout              : this.getDescriptorConfig(desc, 'defaultTimeout') * (launchState.increaseTimeout ? 2 : 1),
                subTestTimeout              : this.getDescriptorConfig(desc, 'subTestTimeout') * (launchState.increaseTimeout ? 2 : 1),
                waitForTimeout              : this.getDescriptorConfig(desc, 'waitForTimeout') * (launchState.increaseTimeout ? 3 : 1),
                isReadyTimeout              : this.getDescriptorConfig(desc, 'isReadyTimeout'),
                
                sourceLineForAllAssertions  : this.sourceLineForAllAssertions,
                
                sandboxCleanup              : this.getDescriptorConfig(desc, 'sandboxCleanup'),
                sharedSandboxState          : sharedSandboxState,
                
                config                      : this.getDescriptorConfig(desc, 'config'),
                
                failOnExclusiveSpecsWhenAutomated   : this.getDescriptorConfig(desc, 'failOnExclusiveSpecsWhenAutomated'),
                
                enableCodeCoverage          : this.getDescriptorConfig(desc, 'enableCodeCoverage')
            }
            
            // potentially not safe
            if (desc.testConfig || desc.config) Joose.O.extend(config, desc.testConfig || desc.config)
            
            return config
        },
        
        
        getScriptDescriptor : function (id) {
            return this.descriptorsById[ id ]
        },
        
        
        getTestByURL : function (url) {
            return this.testsByURL[ url ]
        },
        
        
        saveTestWithURL : function (url, test) {
            this.testsByURL[ url ] = test
        },
        
        
        deleteTestByURL : function (url) {
            var test    = this.testsByURL[ url ]
            
            if (test) {
                // exceptions can arise if test page has switched to different context for example (click on the link)
                // and siesta is trying to clear the timeouts with "clearTimeout"
                try {
                    test.finalize(true)
                } catch (e) {
                }
                this.cleanupScopeForURL(url)
            }
            
            delete this.testsByURL[ url ]
        },
        
        
        allPassed : function () {
            var allPassed       = true
            var me              = this
            
            Joose.A.each(this.flattenDescriptors(this.descriptors), function (descriptor) {
                // if at least one test is missing then something is wrong
                if (descriptor.isMissing) { allPassed = false; return false }
                
                var test        = me.getTestByURL(descriptor.url)
                
                // ignore missing tests (could be skipped by test filtering)
                if (!test) return
                
                allPassed       = allPassed && test.isPassed()
                
                // stop iteration if found failed test
                if (!allPassed) return false
            })
            
            return allPassed
        },
        
        
        flattenArray : function (array) {
            var me          = this
            var result      = []

            Joose.A.each(array, function (el) {
                if (me.typeOf(el) == 'Array')
                    result.push.apply(result, me.flattenArray(el))
                else
                    result.push(el)
            })

            return result
        }
    },
    // eof methods
    
    my : {
        
        has     : {
            HOST            : null,
            instance        : null
        },
        
        methods : {
            
            // backward compat for static harness instance
            staticDeprecationWarning : function (methodName) {
                var message     = Siesta.Resource('Siesta.Harness', 'staticDeprecationWarning', { methodName : methodName, harnessClass : this.HOST + '' })
                
                if (typeof console != 'undefined') console.warn(message)
            },
            
            
            configure : function (config) {
                this.staticDeprecationWarning('configure')
                
                var instance        = this.instance = new this.HOST()
                
                return instance.configure(config)
            },
            
            
            start : function () {
                this.staticDeprecationWarning('start')
                
                return this.instance.start.apply(this.instance, arguments)
            },
            
            
            on : function () {
                this.staticDeprecationWarning('on')
                
                return this.instance.on.apply(this.instance, arguments)
            }
            // eof backward compat
        }
    }
})
//eof Siesta.Harness
;
/**
@class Siesta.Role.CanStyleOutput
@private

A role, providing output coloring functionality

*/
Role('Siesta.Role.CanStyleOutput', {
    
    has         : {
        /**
         * @cfg {Boolean} disableColoring When set to `true` will disable the colors in the console output in automation launchers / NodeJS launcher
         */
        disableColoring : false,
        
        style               : {
            is          : 'rwc',
            lazy        : 'this.buildStyle'
        },
        
        styles              : { 
            init    : {
                'bold'      : [1, 22],
                'italic'    : [3, 23],
                'underline' : [4, 24],
                
                'black '    : [30, 39],
                'yellow'    : [33, 39],
                'cyan'      : [36, 39],
                'white'     : [37, 39],
                'green'     : [32, 39],
                'red'       : [31, 39],
                'grey'      : [90, 39],
                'blue'      : [34, 39],
                'magenta'   : [35, 39],
                
                'bgblack '  : [40, 49],
                'bgyellow'  : [43, 49],
                'bgcyan'    : [46, 49],
                'bgwhite'   : [47, 49],
                'bggreen'   : [42, 49],
                'bgred'     : [41, 49],
                'bggrey'    : [100, 49],
                'bgblue'    : [44, 49],
                'bgmagenta' : [45, 49],
                
                'inverse'   : [7, 27]
            }
        }
    },
    
    
    methods : {
        
        buildStyle : function () {
            var me          = this
            var style       = {}
            
            Joose.O.each(this.styles, function (value, name) {
                
                style[ name ] = function (text) { return me.styled(text, name) }
            })
            
            return style
        },
        
        
        styled : function (text, style) {
            if (this.disableColoring) return text
            
            var styles = this.styles
            
            return '\033[' + styles[ style ][ 0 ] + 'm' + text + '\033[' + styles[ style ][ 1 ] + 'm'
        }
    }
})
;
;
/**
@class Siesta.Util.Role.CanParseBrowser

A mixin, providing browser name and version sniffing using UA string method.

*/
Role('Siesta.Util.Role.CanParseBrowser', {
    
    methods : { 
        
        parseBrowser : function (uaString) {
            var browser = 'unknown'
            var version = ''
            
            var match
            
            if (match = /Firefox\/((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "Firefox"
                version     = match[ 1 ]
            }
            
            if (match = /Chrome\/((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "Chrome"
                version     = match[ 1 ]
            }
            
            if (match = /MSIE\s*((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "IE"
                version     = match[ 1 ]
            }
            
            if (uaString.match(/trident/i) && (match = /rv.(\d\d\.?\d?)/.exec(uaString))) {
                browser     = "IE"
                version     = match[ 1 ]
            }
            
            if (match = /Apple.*Version\/((?:\d+\.?)+)\s*(?=Safari\/((?:\d+\.?)+))/.exec(uaString)) {
                browser     = "Safari"
                version     = match[ 1 ] + ' (' + match[ 2 ] + ')'
            }
            
            if (match = /PhantomJS\/(\d+\.\d+\.\d+)/.exec(uaString)) {
                browser     = "PhantomJS"
                version     = match[ 1 ]
            }
            
            if (match = /SlimerJS\/(\d+\.\d+\.\d+)/.exec(uaString)) {
                browser     = "SlimerJS"
                version     = match[ 1 ]
            }
            
            return {
                name        : browser,
                version     : version
            }
        }
    }
});
;
/*!
* jQuery JavaScript Library v1.6.2
* http://jquery.com/
*
* Copyright 2011, John Resig
* Dual licensed under the MIT or GPL Version 2 licenses.
* http://jquery.org/license
*
* Includes Sizzle.js
* http://sizzlejs.com/
* Copyright 2011, The Dojo Foundation
* Released under the MIT, BSD, and GPL Licenses.
*
* Date: Thu Jun 30 14:16:56 2011 -0400
*/
(function (window, undefined) {

    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
	navigator = window.navigator,
	location = window.location;
    var jQuery = (function () {

        // Define a local copy of jQuery
        var jQuery = function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context, rootjQuery);
        },

        // Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

        // Map over the $ in case of overwrite
	_$ = window.$,

        // A central reference to the root jQuery(document)
	rootjQuery,

        // A simple way to check for HTML strings or ID strings
        // (both of which we optimize for)
	quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

        // Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

        // Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

        // Check for digits
	rdigit = /\d/,

        // Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

        // JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

        // Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

        // Matches dashed string for camelizing
	rdashAlpha = /-([a-z])/ig,

        // Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
	    return letter.toUpperCase();
	},

        // Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

        // For matching the engine and version of the browser
	browserMatch,

        // The deferred used on DOM ready
	readyList,

        // The ready event handler
	DOMContentLoaded,

        // Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

        // [[Class]] -> type pairs
	class2type = {};

        jQuery.fn = jQuery.prototype = {
            constructor: jQuery,
            init: function (selector, context, rootjQuery) {
                var match, elem, ret, doc;

                // Handle $(""), $(null), or $(undefined)
                if (!selector) {
                    return this;
                }

                // Handle $(DOMElement)
                if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                }

                // The body element only exists once, optimize finding it
                if (selector === "body" && !context && document.body) {
                    this.context = document;
                    this[0] = document.body;
                    this.selector = selector;
                    this.length = 1;
                    return this;
                }

                // Handle HTML strings
                if (typeof selector === "string") {
                    // Are we dealing with HTML string or an ID?
                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [null, selector, null];

                    } else {
                        match = quickExpr.exec(selector);
                    }

                    // Verify a match, and that no context was specified for #id
                    if (match && (match[1] || !context)) {

                        // HANDLE: $(html) -> $(array)
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            doc = (context ? context.ownerDocument || context : document);

                            // If a single string is passed in and it's a single tag
                            // just do a createElement and skip the rest
                            ret = rsingleTag.exec(selector);

                            if (ret) {
                                if (jQuery.isPlainObject(context)) {
                                    selector = [document.createElement(ret[1])];
                                    jQuery.fn.attr.call(selector, context, true);

                                } else {
                                    selector = [doc.createElement(ret[1])];
                                }

                            } else {
                                ret = jQuery.buildFragment([match[1]], [doc]);
                                selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
                            }

                            return jQuery.merge(this, selector);

                            // HANDLE: $("#id")
                        } else {
                            elem = document.getElementById(match[2]);

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if (elem.id !== match[2]) {
                                    return rootjQuery.find(selector);
                                }

                                // Otherwise, we inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                        // HANDLE: $(expr, $(...))
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);

                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return this.constructor(context).find(selector);
                    }

                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                    return rootjQuery.ready(selector);
                }

                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray(selector, this);
            },

            // Start with an empty selector
            selector: "",

            // The current version of jQuery being used
            jquery: "1.6.2",

            // The default length of a jQuery object is 0
            length: 0,

            // The number of elements contained in the matched element set
            size: function () {
                return this.length;
            },

            toArray: function () {
                return slice.call(this, 0);
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function (num) {
                return num == null ?

                // Return a 'clean' array
			this.toArray() :

                // Return just the object
			(num < 0 ? this[this.length + num] : this[num]);
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function (elems, name, selector) {
                // Build a new jQuery matched element set
                var ret = this.constructor();

                if (jQuery.isArray(elems)) {
                    push.apply(ret, elems);

                } else {
                    jQuery.merge(ret, elems);
                }

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;

                ret.context = this.context;

                if (name === "find") {
                    ret.selector = this.selector + (this.selector ? " " : "") + selector;
                } else if (name) {
                    ret.selector = this.selector + "." + name + "(" + selector + ")";
                }

                // Return the newly-formed element set
                return ret;
            },

            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: function (callback, args) {
                return jQuery.each(this, callback, args);
            },

            ready: function (fn) {
                // Attach the listeners
                jQuery.bindReady();

                // Add the callback
                readyList.done(fn);

                return this;
            },

            eq: function (i) {
                return i === -1 ?
			this.slice(i) :
			this.slice(i, +i + 1);
            },

            first: function () {
                return this.eq(0);
            },

            last: function () {
                return this.eq(-1);
            },

            slice: function () {
                return this.pushStack(slice.apply(this, arguments),
			"slice", slice.call(arguments).join(","));
            },

            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },

            end: function () {
                return this.prevObject || this.constructor(null);
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: [].sort,
            splice: [].splice
        };

        // Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

            // Handle a deep copy situation
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {};
            }

            // extend jQuery itself if only one argument is passed
            if (length === i) {
                target = this;
                --i;
            }

            for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                    // Extend the base object
                    for (name in options) {
                        src = target[name];
                        copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[name] = jQuery.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        };

        jQuery.extend({
            noConflict: function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            },

            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Hold (or release) the ready event
            holdReady: function (hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },

            // Handle when the DOM is ready
            ready: function (wait) {
                // Either a released hold or an DOMready/load event and not yet ready
                if ((wait === true && ! --jQuery.readyWait) || (wait !== true && !jQuery.isReady)) {
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if (!document.body) {
                        return setTimeout(jQuery.ready, 1);
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith(document, [jQuery]);

                    // Trigger any bound ready events
                    if (jQuery.fn.trigger) {
                        jQuery(document).trigger("ready").unbind("ready");
                    }
                }
            },

            bindReady: function () {
                if (readyList) {
                    return;
                }

                readyList = jQuery._Deferred();

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if (document.readyState === "complete") {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    return setTimeout(jQuery.ready, 1);
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if (document.addEventListener) {
                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", jQuery.ready, false);

                    // If IE event model is used
                } else if (document.attachEvent) {
                    // ensure firing before onload,
                    // maybe late but safe also for iframes
                    document.attachEvent("onreadystatechange", DOMContentLoaded);

                    // A fallback to window.onload, that will always work
                    window.attachEvent("onload", jQuery.ready);

                    // If IE and not a frame
                    // continually check to see if the document is ready
                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) { }

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            },

            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function (obj) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || function (obj) {
                return jQuery.type(obj) === "array";
            },

            // A crude way of determining if an object is a window
            isWindow: function (obj) {
                return obj && typeof obj === "object" && "setInterval" in obj;
            },

            isNaN: function (obj) {
                return obj == null || !rdigit.test(obj) || isNaN(obj);
            },

            type: function (obj) {
                return obj == null ?
			String(obj) :
			class2type[toString.call(obj)] || "object";
            },

            isPlainObject: function (obj) {
                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }

                // Not own constructor property must be Object
                if (obj.constructor &&
			!hasOwn.call(obj, "constructor") &&
			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.

                var key;
                for (key in obj) { }

                return key === undefined || hasOwn.call(obj, key);
            },

            isEmptyObject: function (obj) {
                for (var name in obj) {
                    return false;
                }
                return true;
            },

            error: function (msg) {
                throw msg;
            },

            parseJSON: function (data) {
                if (typeof data !== "string" || !data) {
                    return null;
                }

                // Make sure leading/trailing whitespace is removed (IE can't handle it)
                data = jQuery.trim(data);

                // Attempt to parse using the native JSON parser first
                if (window.JSON && window.JSON.parse) {
                    return window.JSON.parse(data);
                }

                // Make sure the incoming data is actual JSON
                // Logic borrowed from http://json.org/json2.js
                if (rvalidchars.test(data.replace(rvalidescape, "@")
			.replace(rvalidtokens, "]")
			.replace(rvalidbraces, ""))) {

                    return (new Function("return " + data))();

                }
                jQuery.error("Invalid JSON: " + data);
            },

            // Cross-browser xml parsing
            // (xml & tmp used internally)
            parseXML: function (data, xml, tmp) {

                if (window.DOMParser) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } else { // IE
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }

                tmp = xml.documentElement;

                if (!tmp || !tmp.nodeName || tmp.nodeName === "parsererror") {
                    jQuery.error("Invalid XML: " + data);
                }

                return xml;
            },

            noop: function () { },

            // Evaluates a script in a global context
            // Workarounds based on findings by Jim Driscoll
            // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
            globalEval: function (data) {
                if (data && rnotwhite.test(data)) {
                    // We use execScript on Internet Explorer
                    // We use an anonymous function so that context is window
                    // rather than jQuery in Firefox
                    (window.execScript || function (data) {
                        window["eval"].call(window, data);
                    })(data);
                }
            },

            // Converts a dashed string to camelCased string;
            // Used by both the css and data modules
            camelCase: function (string) {
                return string.replace(rdashAlpha, fcamelCase);
            },

            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
            },

            // args is for internal usage only
            each: function (object, callback, args) {
                var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction(object);

                if (args) {
                    if (isObj) {
                        for (name in object) {
                            if (callback.apply(object[name], args) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length; ) {
                            if (callback.apply(object[i++], args) === false) {
                                break;
                            }
                        }
                    }

                    // A special, fast, case for the most common use of each
                } else {
                    if (isObj) {
                        for (name in object) {
                            if (callback.call(object[name], name, object[name]) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length; ) {
                            if (callback.call(object[i], i, object[i++]) === false) {
                                break;
                            }
                        }
                    }
                }

                return object;
            },

            // Use native String.trim function wherever possible
            trim: trim ?
		function (text) {
		    return text == null ?
				"" :
				trim.call(text);
		} :

            // Otherwise use our own trimming functionality
		function (text) {
		    return text == null ?
				"" :
				text.toString().replace(trimLeft, "").replace(trimRight, "");
		},

            // results is for internal usage only
            makeArray: function (array, results) {
                var ret = results || [];

                if (array != null) {
                    // The window, strings (and functions) also have 'length'
                    // The extra typeof function check is to prevent crashes
                    // in Safari 2 (See: #3039)
                    // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                    var type = jQuery.type(array);

                    if (array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(array)) {
                        push.call(ret, array);
                    } else {
                        jQuery.merge(ret, array);
                    }
                }

                return ret;
            },

            inArray: function (elem, array) {

                if (indexOf) {
                    return indexOf.call(array, elem);
                }

                for (var i = 0, length = array.length; i < length; i++) {
                    if (array[i] === elem) {
                        return i;
                    }
                }

                return -1;
            },

            merge: function (first, second) {
                var i = first.length,
			j = 0;

                if (typeof second.length === "number") {
                    for (var l = second.length; j < l; j++) {
                        first[i++] = second[j];
                    }

                } else {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }

                first.length = i;

                return first;
            },

            grep: function (elems, callback, inv) {
                var ret = [], retVal;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for (var i = 0, length = elems.length; i < length; i++) {
                    retVal = !!callback(elems[i], i);
                    if (inv !== retVal) {
                        ret.push(elems[i]);
                    }
                }

                return ret;
            },

            // arg is for internal usage only
            map: function (elems, callback, arg) {
                var value, key, ret = [],
			i = 0,
			length = elems.length,
                // jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || jQuery.isArray(elems));

                // Go through the array, translating each of the items to their
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);

                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }

                    // Go through every key on the object,
                } else {
                    for (key in elems) {
                        value = callback(elems[key], key, arg);

                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }
                }

                // Flatten any nested arrays
                return ret.concat.apply([], ret);
            },

            // A global GUID counter for objects
            guid: 1,

            // Bind a function to a context, optionally partially applying any
            // arguments.
            proxy: function (fn, context) {
                if (typeof context === "string") {
                    var tmp = fn[context];
                    context = fn;
                    fn = tmp;
                }

                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if (!jQuery.isFunction(fn)) {
                    return undefined;
                }

                // Simulated bind
                var args = slice.call(arguments, 2),
			proxy = function () {
			    return fn.apply(context, args.concat(slice.call(arguments)));
			};

                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

                return proxy;
            },

            // Mutifunctional method to get and set values to a collection
            // The value/s can optionally be executed if it's a function
            access: function (elems, key, value, exec, fn, pass) {
                var length = elems.length;

                // Setting many attributes
                if (typeof key === "object") {
                    for (var k in key) {
                        jQuery.access(elems, k, key[k], exec, fn, value);
                    }
                    return elems;
                }

                // Setting one attribute
                if (value !== undefined) {
                    // Optionally, function values get executed if exec is true
                    exec = !pass && exec && jQuery.isFunction(value);

                    for (var i = 0; i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }

                    return elems;
                }

                // Getting an attribute
                return length ? fn(elems[0], key) : undefined;
            },

            now: function () {
                return (new Date()).getTime();
            },

            // Use of jQuery.browser is frowned upon.
            // More details: http://docs.jquery.com/Utilities/jQuery.browser
            uaMatch: function (ua) {
                ua = ua.toLowerCase();

                // temp hack for IE11
                if (ua.match(/trident/i) && ua.match(/rv.\d\d/)) {
                    return { browser: "msie", version: "11.0"};
                }
                var match = rwebkit.exec(ua) ||
			ropera.exec(ua) ||
			rmsie.exec(ua) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec(ua) ||
			[];

                return { browser: match[1] || "", version: match[2] || "0" };
            },

            sub: function () {
                function jQuerySub(selector, context) {
                    return new jQuerySub.fn.init(selector, context);
                }
                jQuery.extend(true, jQuerySub, this);
                jQuerySub.superclass = this;
                jQuerySub.fn = jQuerySub.prototype = this();
                jQuerySub.fn.constructor = jQuerySub;
                jQuerySub.sub = this.sub;
                jQuerySub.fn.init = function init(selector, context) {
                    if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                        context = jQuerySub(context);
                    }

                    return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
                };
                jQuerySub.fn.init.prototype = jQuerySub.fn;
                var rootjQuerySub = jQuerySub(document);
                return jQuerySub;
            },

            browser: {}
        });

        // Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        browserMatch = jQuery.uaMatch(userAgent);
        if (browserMatch.browser) {
            jQuery.browser[browserMatch.browser] = true;
            jQuery.browser.version = browserMatch.version;
        }

        // Deprecated, use jQuery.browser.webkit instead
        if (jQuery.browser.webkit) {
            jQuery.browser.safari = /safari/i.test(userAgent) && !/chrome/i.test(userAgent);
        }

        // IE doesn't match non-breaking spaces with \s
        if (rnotwhite.test("\xA0")) {
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

        // All jQuery objects should point back to these
        rootjQuery = jQuery(document);

        // Cleanup functions for the document ready method
        if (document.addEventListener) {
            DOMContentLoaded = function () {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function () {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (document.readyState === "complete") {
                    document.detachEvent("onreadystatechange", DOMContentLoaded);
                    jQuery.ready();
                }
            };
        }

        // The DOM ready check for Internet Explorer
        function doScrollCheck() {
            if (jQuery.isReady) {
                return;
            }

            try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
            } catch (e) {
                setTimeout(doScrollCheck, 1);
                return;
            }

            // and execute any waiting functions
            jQuery.ready();
        }

        return jQuery;

    })();


    var // Promise methods
	promiseMethods = "done fail isResolved isRejected promise then always pipe".split(" "),
    // Static reference to slice
	sliceDeferred = [].slice;

    jQuery.extend({
        // Create a simple deferred (one callbacks list)
        _Deferred: function () {
            var // callbacks list
			callbacks = [],
            // stored [ context , args ]
			fired,
            // to avoid firing when already doing so
			firing,
            // flag to know if the deferred has been cancelled
			cancelled,
            // the deferred itself
			deferred = {

			    // done( f1, f2, ...)
			    done: function () {
			        if (!cancelled) {
			            var args = arguments,
							i,
							length,
							elem,
							type,
							_fired;
			            if (fired) {
			                _fired = fired;
			                fired = 0;
			            }
			            for (i = 0, length = args.length; i < length; i++) {
			                elem = args[i];
			                type = jQuery.type(elem);
			                if (type === "array") {
			                    deferred.done.apply(deferred, elem);
			                } else if (type === "function") {
			                    callbacks.push(elem);
			                }
			            }
			            if (_fired) {
			                deferred.resolveWith(_fired[0], _fired[1]);
			            }
			        }
			        return this;
			    },

			    // resolve with given context and args
			    resolveWith: function (context, args) {
			        if (!cancelled && !fired && !firing) {
			            // make sure args are available (#8421)
			            args = args || [];
			            firing = 1;
			            try {
			                while (callbacks[0]) {
			                    callbacks.shift().apply(context, args);
			                }
			            }
			            finally {
			                fired = [context, args];
			                firing = 0;
			            }
			        }
			        return this;
			    },

			    // resolve with this as context and given arguments
			    resolve: function () {
			        deferred.resolveWith(this, arguments);
			        return this;
			    },

			    // Has this deferred been resolved?
			    isResolved: function () {
			        return !!(firing || fired);
			    },

			    // Cancel
			    cancel: function () {
			        cancelled = 1;
			        callbacks = [];
			        return this;
			    }
			};

            return deferred;
        },

        // Full fledged deferred (two callbacks list)
        Deferred: function (func) {
            var deferred = jQuery._Deferred(),
			failDeferred = jQuery._Deferred(),
			promise;
            // Add errorDeferred methods, then and promise
            jQuery.extend(deferred, {
                then: function (doneCallbacks, failCallbacks) {
                    deferred.done(doneCallbacks).fail(failCallbacks);
                    return this;
                },
                always: function () {
                    return deferred.done.apply(deferred, arguments).fail.apply(this, arguments);
                },
                fail: failDeferred.done,
                rejectWith: failDeferred.resolveWith,
                reject: failDeferred.resolve,
                isRejected: failDeferred.isResolved,
                pipe: function (fnDone, fnFail) {
                    return jQuery.Deferred(function (newDefer) {
                        jQuery.each({
                            done: [fnDone, "resolve"],
                            fail: [fnFail, "reject"]
                        }, function (handler, data) {
                            var fn = data[0],
							action = data[1],
							returned;
                            if (jQuery.isFunction(fn)) {
                                deferred[handler](function () {
                                    returned = fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().then(newDefer.resolve, newDefer.reject);
                                    } else {
                                        newDefer[action](returned);
                                    }
                                });
                            } else {
                                deferred[handler](newDefer[action]);
                            }
                        });
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function (obj) {
                    if (obj == null) {
                        if (promise) {
                            return promise;
                        }
                        promise = obj = {};
                    }
                    var i = promiseMethods.length;
                    while (i--) {
                        obj[promiseMethods[i]] = deferred[promiseMethods[i]];
                    }
                    return obj;
                }
            });
            // Make sure only one callback list will be used
            deferred.done(failDeferred.cancel).fail(deferred.cancel);
            // Unexpose cancel
            delete deferred.cancel;
            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },

        // Deferred helper
        when: function (firstParam) {
            var args = arguments,
			i = 0,
			length = args.length,
			count = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction(firstParam.promise) ?
				firstParam :
				jQuery.Deferred();
            function resolveFunc(i) {
                return function (value) {
                    args[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;
                    if (!(--count)) {
                        // Strange bug in FF4:
                        // Values changed onto the arguments object sometimes end up as undefined values
                        // outside the $.when method. Cloning the object into a fresh array solves the issue
                        deferred.resolveWith(deferred, sliceDeferred.call(args, 0));
                    }
                };
            }
            if (length > 1) {
                for (; i < length; i++) {
                    if (args[i] && jQuery.isFunction(args[i].promise)) {
                        args[i].promise().then(resolveFunc(i), deferred.reject);
                    } else {
                        --count;
                    }
                }
                if (!count) {
                    deferred.resolveWith(deferred, args);
                }
            } else if (deferred !== firstParam) {
                deferred.resolveWith(deferred, length ? [firstParam] : []);
            }
            return deferred.promise();
        }
    });



    jQuery.support = (function () {

        var div = document.createElement("div"),
		documentElement = document.documentElement,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		support,
		fragment,
		body,
		testElementParent,
		testElement,
		testElementStyle,
		tds,
		events,
		eventName,
		i,
		isSupported;

        // Preliminary tests
        div.setAttribute("className", "t");
        div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];

        // Can't get basic test support
        if (!all || !all.length || !a) {
            return {};
        }

        // First batch of supports tests
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];

        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: (div.firstChild.nodeType === 3),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: (a.getAttribute("href") === "/a"),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55$/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: (input.value === "on"),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true
        };

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch (e) {
            support.deleteExpando = false;
        }

        if (!div.addEventListener && div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", function () {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode(true).fireEvent("onclick");
        }

        // Check if a radio maintains it's value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");
        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.firstChild);

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        div.innerHTML = "";

        // Figure out if the W3C box model works as expected
        div.style.width = div.style.paddingLeft = "1px";

        body = document.getElementsByTagName("body")[0];
        // We use our own, invisible, body unless the body is already present
        // in which case we use a div (#9239)
        testElement = document.createElement(body ? "div" : "body");
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0
        };
        if (body) {
            jQuery.extend(testElementStyle, {
                position: "absolute",
                left: -1000,
                top: -1000
            });
        }
        for (i in testElementStyle) {
            testElement.style[i] = testElementStyle[i];
        }
        testElement.appendChild(div);
        testElementParent = body || documentElement;
        testElementParent.insertBefore(testElement, testElementParent.firstChild);

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        support.boxModel = div.offsetWidth === 2;

        if ("zoom" in div.style) {
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            // (IE < 8 does this)
            div.style.display = "inline";
            div.style.zoom = 1;
            support.inlineBlockNeedsLayout = (div.offsetWidth === 2);

            // Check if elements with layout shrink-wrap their children
            // (IE 6 does this)
            div.style.display = "";
            div.innerHTML = "<div style='width:4px;'></div>";
            support.shrinkWrapBlocks = (div.offsetWidth !== 2);
        }

        div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
        tds = div.getElementsByTagName("td");

        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        // (only IE 8 fails this test)
        isSupported = (tds[0].offsetHeight === 0);

        tds[0].style.display = "";
        tds[1].style.display = "none";

        // Check if empty table cells still have offsetWidth/Height
        // (IE < 8 fail this test)
        support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);
        div.innerHTML = "";

        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. For more
        // info see bug #3333
        // Fails in WebKit before Feb 2011 nightlies
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        if (document.defaultView && document.defaultView.getComputedStyle) {
            marginDiv = document.createElement("div");
            marginDiv.style.width = "0";
            marginDiv.style.marginRight = "0";
            div.appendChild(marginDiv);
            support.reliableMarginRight =
			(parseInt((document.defaultView.getComputedStyle(marginDiv, null) || { marginRight: 0 }).marginRight, 10) || 0) === 0;
        }

        // Remove the body element we added
        testElement.innerHTML = "";
        testElementParent.removeChild(testElement);

        // Technique from Juriy Zaytsev
        // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if (div.attachEvent) {
            for (i in {
                submit: 1,
                change: 1,
                focusin: 1
            }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) {
                    div.setAttribute(eventName, "return;");
                    isSupported = (typeof div[eventName] === "function");
                }
                support[i + "Bubbles"] = isSupported;
            }
        }

        // Null connected elements to avoid leaks in IE
        testElement = fragment = select = opt = body = marginDiv = div = input = null;

        return support;
    })();

    // Keep track of boxModel
    jQuery.boxModel = jQuery.support.boxModel;




    var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([a-z])([A-Z])/g;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];

            return !!elem && !isEmptyDataObject(elem);
        },

        data: function (elem, name, data, pvt /* Internal Use Only */) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var internalKey = jQuery.expando, getByName = typeof name === "string", thisCache,

            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[jQuery.expando] : elem[jQuery.expando] && jQuery.expando;

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ((!id || (pvt && id && !cache[id][internalKey])) && getByName && data === undefined) {
                return;
            }

            if (!id) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if (isNode) {
                    elem[jQuery.expando] = id = ++jQuery.uuid;
                } else {
                    id = jQuery.expando;
                }
            }

            if (!cache[id]) {
                cache[id] = {};

                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                    cache[id][internalKey] = jQuery.extend(cache[id][internalKey], name);
                } else {
                    cache[id] = jQuery.extend(cache[id], name);
                }
            }

            thisCache = cache[id];

            // Internal jQuery data is stored in a separate object inside the object's data
            // cache in order to avoid key collisions between internal data and user-defined
            // data
            if (pvt) {
                if (!thisCache[internalKey]) {
                    thisCache[internalKey] = {};
                }

                thisCache = thisCache[internalKey];
            }

            if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
            }

            // TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
            // not attempt to inspect the internal events object using jQuery.data, as this
            // internal data object is undocumented and subject to change.
            if (name === "events" && !thisCache[name]) {
                return thisCache[internalKey] && thisCache[internalKey].events;
            }

            return getByName ?
            // Check for both converted-to-camel and non-converted data property names
			thisCache[jQuery.camelCase(name)] || thisCache[name] :
			thisCache;
        },

        removeData: function (elem, name, pvt /* Internal Use Only */) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var internalKey = jQuery.expando, isNode = elem.nodeType,

            // See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

            // See jQuery.data for more information
			id = isNode ? elem[jQuery.expando] : jQuery.expando;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if (!cache[id]) {
                return;
            }

            if (name) {
                var thisCache = pvt ? cache[id][internalKey] : cache[id];

                if (thisCache) {
                    delete thisCache[name];

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if (!isEmptyDataObject(thisCache)) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if (pvt) {
                delete cache[id][internalKey];

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if (!isEmptyDataObject(cache[id])) {
                    return;
                }
            }

            var internalCache = cache[id][internalKey];

            // Browsers that fail expando deletion also refuse to delete expandos on
            // the window, but it will allow it on all other JS objects; other browsers
            // don't care
            if (jQuery.support.deleteExpando || cache != window) {
                delete cache[id];
            } else {
                cache[id] = null;
            }

            // We destroyed the entire user cache at once because it's faster than
            // iterating through each key, but we need to continue to persist internal
            // data if it existed
            if (internalCache) {
                cache[id] = {};
                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }

                cache[id][internalKey] = internalCache;

                // Otherwise, we need to eliminate the expando on the node to avoid
                // false lookups in the cache for entries that no longer exist
            } else if (isNode) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if (jQuery.support.deleteExpando) {
                    delete elem[jQuery.expando];
                } else if (elem.removeAttribute) {
                    elem.removeAttribute(jQuery.expando);
                } else {
                    elem[jQuery.expando] = null;
                }
            }
        },

        // For internal use only.
        _data: function (elem, name, data) {
            return jQuery.data(elem, name, data, true);
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function (elem) {
            if (elem.nodeName) {
                var match = jQuery.noData[elem.nodeName.toLowerCase()];

                if (match) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }

            return true;
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var data = null;

            if (typeof key === "undefined") {
                if (this.length) {
                    data = jQuery.data(this[0]);

                    if (this[0].nodeType === 1) {
                        var attr = this[0].attributes, name;
                        for (var i = 0, l = attr.length; i < l; i++) {
                            name = attr[i].name;

                            if (name.indexOf("data-") === 0) {
                                name = jQuery.camelCase(name.substring(5));

                                dataAttr(this[0], name, data[name]);
                            }
                        }
                    }
                }

                return data;

            } else if (typeof key === "object") {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            var parts = key.split(".");
            parts[1] = parts[1] ? "." + parts[1] : "";

            if (value === undefined) {
                data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if (data === undefined && this.length) {
                    data = jQuery.data(this[0], key);
                    data = dataAttr(this[0], key, data);
                }

                return data === undefined && parts[1] ?
				this.data(parts[0]) :
				data;

            } else {
                return this.each(function () {
                    var $this = jQuery(this),
					args = [parts[0], value];

                    $this.triggerHandler("setData" + parts[1] + "!", args);
                    jQuery.data(this, key, value);
                    $this.triggerHandler("changeData" + parts[1] + "!", args);
                });
            }
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });

    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            var name = "data-" + key.replace(rmultiDash, "$1-$2").toLowerCase();

            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				!jQuery.isNaN(data) ? parseFloat(data) :
					rbrace.test(data) ? jQuery.parseJSON(data) :
					data;
                } catch (e) { }

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);

            } else {
                data = undefined;
            }
        }

        return data;
    }

    // TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
    // property to be considered empty objects; this property always exists in
    // order to make sure JSON.stringify does not expose internal metadata
    function isEmptyDataObject(obj) {
        for (var name in obj) {
            if (name !== "toJSON") {
                return false;
            }
        }

        return true;
    }




    function handleQueueMarkDefer(elem, type, src) {
        var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery.data(elem, deferDataKey, undefined, true);
        if (defer &&
		(src === "queue" || !jQuery.data(elem, queueDataKey, undefined, true)) &&
		(src === "mark" || !jQuery.data(elem, markDataKey, undefined, true))) {
            // Give room for hard-coded callbacks to fire first
            // and eventually mark/queue something else on the element
            setTimeout(function () {
                if (!jQuery.data(elem, queueDataKey, undefined, true) &&
				!jQuery.data(elem, markDataKey, undefined, true)) {
                    jQuery.removeData(elem, deferDataKey, true);
                    defer.resolve();
                }
            }, 0);
        }
    }

    jQuery.extend({

        _mark: function (elem, type) {
            if (elem) {
                type = (type || "fx") + "mark";
                jQuery.data(elem, type, (jQuery.data(elem, type, undefined, true) || 0) + 1, true);
            }
        },

        _unmark: function (force, elem, type) {
            if (force !== true) {
                type = elem;
                elem = force;
                force = false;
            }
            if (elem) {
                type = type || "fx";
                var key = type + "mark",
				count = force ? 0 : ((jQuery.data(elem, key, undefined, true) || 1) - 1);
                if (count) {
                    jQuery.data(elem, key, count, true);
                } else {
                    jQuery.removeData(elem, key, true);
                    handleQueueMarkDefer(elem, type, "mark");
                }
            }
        },

        queue: function (elem, type, data) {
            if (elem) {
                type = (type || "fx") + "queue";
                var q = jQuery.data(elem, type, undefined, true);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!q || jQuery.isArray(data)) {
                        q = jQuery.data(elem, type, jQuery.makeArray(data), true);
                    } else {
                        q.push(data);
                    }
                }
                return q || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
			fn = queue.shift(),
			defer;

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
            }

            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                fn.call(elem, function () {
                    jQuery.dequeue(elem, type);
                });
            }

            if (!queue.length) {
                jQuery.removeData(elem, type + "queue", true);
                handleQueueMarkDefer(elem, type, "queue");
            }
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            if (typeof type !== "string") {
                data = type;
                type = "fx";
            }

            if (data === undefined) {
                return jQuery.queue(this[0], type);
            }
            return this.each(function () {
                var queue = jQuery.queue(this, type, data);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue(type, function () {
                var elem = this;
                setTimeout(function () {
                    jQuery.dequeue(elem, type);
                }, time);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, object) {
            if (typeof type !== "string") {
                object = type;
                type = undefined;
            }
            type = type || "fx";
            var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
            function resolve() {
                if (!(--count)) {
                    defer.resolveWith(elements, [elements]);
                }
            }
            while (i--) {
                if ((tmp = jQuery.data(elements[i], deferDataKey, undefined, true) ||
					(jQuery.data(elements[i], queueDataKey, undefined, true) ||
						jQuery.data(elements[i], markDataKey, undefined, true)) &&
					jQuery.data(elements[i], deferDataKey, jQuery._Deferred(), true))) {
                    count++;
                    tmp.done(resolve);
                }
            }
            resolve();
            return defer.promise();
        }
    });




    var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	rinvalidChar = /\:|^on/,
	formHook, boolHook;

    jQuery.fn.extend({
        attr: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.attr);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        },

        prop: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.prop);
        },

        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) { }
            });
        },

        addClass: function (value) {
            var classNames, i, l, elem,
			setClass, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (value && typeof value === "string") {
                classNames = value.split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1) {
                        if (!elem.className && classNames.length === 1) {
                            elem.className = value;

                        } else {
                            setClass = " " + elem.className + " ";

                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                if (! ~setClass.indexOf(" " + classNames[c] + " ")) {
                                    setClass += classNames[c] + " ";
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classNames, i, l, elem, className, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }

            if ((value && typeof value === "string") || value === undefined) {
                classNames = (value || "").split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1 && elem.className) {
                        if (value) {
                            className = (" " + elem.className + " ").replace(rclass, " ");
                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                className = className.replace(" " + classNames[c] + " ", " ");
                            }
                            elem.className = jQuery.trim(className);

                        } else {
                            elem.className = "";
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value,
			isBool = typeof stateVal === "boolean";

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === "string") {
                    // toggle individual class names
                    var className,
					i = 0,
					self = jQuery(this),
					state = stateVal,
					classNames = value.split(rspace);

                    while ((className = classNames[i++])) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }

                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery._data(this, "__className__", this.className);
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },

        hasClass: function (selector) {
            var className = " " + selector + " ";
            for (var i = 0, l = this.length; i < l; i++) {
                if ((" " + this[i].className + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        },

        val: function (value) {
            var hooks, ret,
			elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.nodeName.toLowerCase()] || jQuery.valHooks[elem.type];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                    // handle most common string cases
					ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
					ret == null ? "" : ret;
                }

                return undefined;
            }

            var isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var self = jQuery(this), val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, self.val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.nodeName.toLowerCase()] || jQuery.valHooks[this.type];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function (elem) {
                    var value,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

                    // Nothing was selected
                    if (index < 0) {
                        return null;
                    }

                    // Loop through all the selected options
                    for (var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++) {
                        var option = options[i];

                        // Don't return options that are disabled or in a disabled optgroup
                        if (option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                    if (one && !values.length && options.length) {
                        return jQuery(options[index]).val();
                    }

                    return values;
                },

                set: function (elem, value) {
                    var values = jQuery.makeArray(value);

                    jQuery(elem).find("option").each(function () {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });

                    if (!values.length) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },

        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attrFix: {
            // Always normalize to ensure hook usage
            tabindex: "tabIndex"
        },

        attr: function (elem, name, value, pass) {
            var nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return undefined;
            }

            if (pass && name in jQuery.attrFn) {
                return jQuery(elem)[name](value);
            }

            // Fallback to prop when attributes are not supported
            if (!("getAttribute" in elem)) {
                return jQuery.prop(elem, name, value);
            }

            var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            // Normalize the name if needed
            if (notxml) {
                name = jQuery.attrFix[name] || name;

                hooks = jQuery.attrHooks[name];

                if (!hooks) {
                    // Use boolHook for boolean attributes
                    if (rboolean.test(name)) {

                        hooks = boolHook;

                        // Use formHook for forms and if the name contains certain characters
                    } else if (formHook && name !== "className" &&
					(jQuery.nodeName(elem, "form") || rinvalidChar.test(name))) {

                        hooks = formHook;
                    }
                }
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return undefined;

                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, "" + value);
                    return value;
                }

            } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {

                ret = elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
				undefined :
				ret;
            }
        },

        removeAttr: function (elem, name) {
            var propName;
            if (elem.nodeType === 1) {
                name = jQuery.attrFix[name] || name;

                if (jQuery.support.getSetAttribute) {
                    // Use removeAttribute in browsers that support it
                    elem.removeAttribute(name);
                } else {
                    jQuery.attr(elem, name, "");
                    elem.removeAttributeNode(elem.getAttributeNode(name));
                }

                // Set corresponding property to false for boolean attributes
                if (rboolean.test(name) && (propName = jQuery.propFix[name] || name) in elem) {
                    elem[propName] = false;
                }
            }
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if (rtype.test(elem.nodeName) && elem.parentNode) {
                        jQuery.error("type property can't be changed");
                    } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            tabIndex: {
                get: function (elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabIndex");

                    return attributeNode && attributeNode.specified ?
					parseInt(attributeNode.value, 10) :
					rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
						0 :
						undefined;
                }
            },
            // Use the value property for back compat
            // Use the formHook for button elements in IE6/7 (#1954)
            value: {
                get: function (elem, name) {
                    if (formHook && jQuery.nodeName(elem, "button")) {
                        return formHook.get(elem, name);
                    }
                    return name in elem ?
					elem.value :
					null;
                },
                set: function (elem, value, name) {
                    if (formHook && jQuery.nodeName(elem, "button")) {
                        return formHook.set(elem, value, name);
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function (elem, name, value) {
            var nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return undefined;
            }

            var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    return (elem[name] = value);
                }

            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== undefined) {
                    return ret;

                } else {
                    return elem[name];
                }
            }
        },

        propHooks: {}
    });

    // Hook for boolean attributes
    boolHook = {
        get: function (elem, name) {
            // Align boolean attributes with corresponding properties
            return jQuery.prop(elem, name) ?
			name.toLowerCase() :
			undefined;
        },
        set: function (elem, value, name) {
            var propName;
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[name] || name;
                if (propName in elem) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[propName] = true;
                }

                elem.setAttribute(name, name.toLowerCase());
            }
            return name;
        }
    };

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!jQuery.support.getSetAttribute) {

        // propFix is more comprehensive and contains all fixes
        jQuery.attrFix = jQuery.propFix;

        // Use this for any attribute on a form in IE6/7
        formHook = jQuery.attrHooks.name = jQuery.attrHooks.title = jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret;
                ret = elem.getAttributeNode(name);
                // Return undefined if nodeValue is empty string
                return ret && ret.nodeValue !== "" ?
				ret.nodeValue :
				undefined;
            },
            set: function (elem, value, name) {
                // Check form objects in IE (multiple bugs related)
                // Only use nodeValue if the attribute node exists on the form
                var ret = elem.getAttributeNode(name);
                if (ret) {
                    ret.nodeValue = value;
                    return value;
                }
            }
        };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each(["width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                set: function (elem, value) {
                    if (value === "") {
                        elem.setAttribute(name, "auto");
                        return value;
                    }
                }
            });
        });
    }


    // Some attributes require a special call on IE
    if (!jQuery.support.hrefNormalized) {
        jQuery.each(["href", "src", "width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                get: function (elem) {
                    var ret = elem.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            });
        });
    }

    if (!jQuery.support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function (elem, value) {
                return (elem.style.cssText = "" + value);
            }
        };
    }

    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get: function (elem) {
                var parent = elem.parentNode;

                if (parent) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        });
    }

    // Radios and checkboxes getter/setter
    if (!jQuery.support.checkOn) {
        jQuery.each(["radio", "checkbox"], function () {
            jQuery.valHooks[this] = {
                get: function (elem) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
            }
        });
    });




    var rnamespaces = /\.(.*)$/,
	rformElems = /^(?:textarea|input|select)$/i,
	rperiod = /\./g,
	rspaces = / /g,
	rescape = /[^\w\s.|`]/g,
	fcleanup = function (nm) {
	    return nm.replace(rescape, "\\$&");
	};

    /*
    * A number of helper functions used for managing events.
    * Many of the ideas behind this code originated from
    * Dean Edwards' addEvent library.
    */
    jQuery.event = {

        // Bind an event to an element
        // Original by Dean Edwards
        add: function (elem, types, handler, data) {
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            } else if (!handler) {
                // Fixes bug #7229. Fix recommended by jdalton
                return;
            }

            var handleObjIn, handleObj;

            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
            }

            // Make sure that the function being executed has a unique ID
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure
            var elemData = jQuery._data(elem);

            // If no elemData is found then we must be trying to bind to one of the
            // banned noData elements
            if (!elemData) {
                return;
            }

            var events = elemData.events,
			eventHandle = elemData.handle;

            if (!events) {
                elemData.events = events = {};
            }

            if (!eventHandle) {
                elemData.handle = eventHandle = function (e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.handle.apply(eventHandle.elem, arguments) :
					undefined;
                };
            }

            // Add elem as a property of the handle function
            // This is to prevent a memory leak with non-native events in IE.
            eventHandle.elem = elem;

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = types.split(" ");

            var type, i = 0, namespaces;

            while ((type = types[i++])) {
                handleObj = handleObjIn ?
				jQuery.extend({}, handleObjIn) :
				{ handler: handler, data: data };

                // Namespaced event handlers
                if (type.indexOf(".") > -1) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    handleObj.namespace = namespaces.slice(0).sort().join(".");

                } else {
                    namespaces = [];
                    handleObj.namespace = "";
                }

                handleObj.type = type;
                if (!handleObj.guid) {
                    handleObj.guid = handler.guid;
                }

                // Get the current list of functions bound to this event
                var handlers = events[type],
				special = jQuery.event.special[type] || {};

                // Init the event handler queue
                if (!handlers) {
                    handlers = events[type] = [];

                    // Check for a special event handler
                    // Only use addEventListener/attachEvent if the special
                    // events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add the function to the element's handler list
                handlers.push(handleObj);

                // Keep track of which events have been used, for event optimization
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, pos) {
            // don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            }

            var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
			elemData = jQuery.hasData(elem) && jQuery._data(elem),
			events = elemData && elemData.events;

            if (!elemData || !events) {
                return;
            }

            // types is actually an event object here
            if (types && types.type) {
                handler = types.handler;
                types = types.type;
            }

            // Unbind all events for the element
            if (!types || typeof types === "string" && types.charAt(0) === ".") {
                types = types || "";

                for (type in events) {
                    jQuery.event.remove(elem, type + types);
                }

                return;
            }

            // Handle multiple events separated by a space
            // jQuery(...).unbind("mouseover mouseout", fn);
            types = types.split(" ");

            while ((type = types[i++])) {
                origType = type;
                handleObj = null;
                all = type.indexOf(".") < 0;
                namespaces = [];

                if (!all) {
                    // Namespaced event handlers
                    namespaces = type.split(".");
                    type = namespaces.shift();

                    namespace = new RegExp("(^|\\.)" +
					jQuery.map(namespaces.slice(0).sort(), fcleanup).join("\\.(?:.*\\.)?") + "(\\.|$)");
                }

                eventType = events[type];

                if (!eventType) {
                    continue;
                }

                if (!handler) {
                    for (j = 0; j < eventType.length; j++) {
                        handleObj = eventType[j];

                        if (all || namespace.test(handleObj.namespace)) {
                            jQuery.event.remove(elem, origType, handleObj.handler, j);
                            eventType.splice(j--, 1);
                        }
                    }

                    continue;
                }

                special = jQuery.event.special[type] || {};

                for (j = pos || 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if (handler.guid === handleObj.guid) {
                        // remove the given handler for the given type
                        if (all || namespace.test(handleObj.namespace)) {
                            if (pos == null) {
                                eventType.splice(j--, 1);
                            }

                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }

                        if (pos != null) {
                            break;
                        }
                    }
                }

                // remove generic event handler if no more handlers exist
                if (eventType.length === 0 || pos != null && eventType.length === 1) {
                    if (!special.teardown || special.teardown.call(elem, namespaces) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    ret = null;
                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                var handle = elemData.handle;
                if (handle) {
                    handle.elem = null;
                }

                delete elemData.events;
                delete elemData.handle;

                if (jQuery.isEmptyObject(elemData)) {
                    jQuery.removeData(elem, undefined, true);
                }
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function (event, data, elem, onlyHandlers) {
            // Event object or event type
            var type = event.type || event,
			namespaces = [],
			exclusive;

            if (type.indexOf("!") >= 0) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
            // jQuery.Event object
			event[jQuery.expando] ? event :
            // Object literal
			new jQuery.Event(type, event) :
            // Just the event type (string)
			new jQuery.Event(type);

            event.type = type;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");

            // triggerHandler() and global events don't bubble or run the default action
            if (onlyHandlers || !elem) {
                event.preventDefault();
                event.stopPropagation();
            }

            // Handle a global trigger
            if (!elem) {
                // TODO: Stop taunting the data cache; remove global events and always attach to document
                jQuery.each(jQuery.cache, function () {
                    // internalKey variable is just used to make it easier to find
                    // and potentially change this stuff later; currently it just
                    // points to jQuery.expando
                    var internalKey = jQuery.expando,
					internalCache = this[internalKey];
                    if (internalCache && internalCache.events && internalCache.events[type]) {
                        jQuery.event.trigger(event, data, internalCache.handle.elem);
                    }
                });
                return;
            }

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            event.target = elem;

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);

            var cur = elem,
            // IE doesn't like method names with a colon (#3533, #8272)
			ontype = type.indexOf(":") < 0 ? "on" + type : "";

            // Fire event on the current element, then bubble up the DOM tree
            do {
                var handle = jQuery._data(cur, "handle");

                event.currentTarget = cur;
                if (handle) {
                    handle.apply(cur, data);
                }

                // Trigger an inline bound script
                if (ontype && jQuery.acceptData(cur) && cur[ontype] && cur[ontype].apply(cur, data) === false) {
                    event.result = false;
                    event.preventDefault();
                }

                // Bubble up to document, then to window
                cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
            } while (cur && !event.isPropagationStopped());

            // If nobody prevented the default action, do it now
            if (!event.isDefaultPrevented()) {
                var old,
				special = jQuery.event.special[type] || {};

                if ((!special._default || special._default.call(elem.ownerDocument, event) === false) &&
				!(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction)() check here because IE6/7 fails that test.
                    // IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
                    try {
                        if (ontype && elem[type]) {
                            // Don't re-trigger an onFOO event when we call its FOO() method
                            old = elem[ontype];

                            if (old) {
                                elem[ontype] = null;
                            }

                            jQuery.event.triggered = type;
                            elem[type]();
                        }
                    } catch (ieError) { }

                    if (old) {
                        elem[ontype] = old;
                    }

                    jQuery.event.triggered = undefined;
                }
            }

            return event.result;
        },

        handle: function (event) {
            event = jQuery.event.fix(event || window.event);
            // Snapshot the handlers list since a called handler may add/remove events.
            var handlers = ((jQuery._data(this, "events") || {})[event.type] || []).slice(0),
			run_all = !event.exclusive && !event.namespace,
			args = Array.prototype.slice.call(arguments, 0);

            // Use the fix-ed Event rather than the (read-only) native event
            args[0] = event;
            event.currentTarget = this;

            for (var j = 0, l = handlers.length; j < l; j++) {
                var handleObj = handlers[j];

                // Triggered event must 1) be non-exclusive and have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event.
                if (run_all || event.namespace_re.test(handleObj.namespace)) {
                    // Pass in a reference to the handler function itself
                    // So that we can later remove it
                    event.handler = handleObj.handler;
                    event.data = handleObj.data;
                    event.handleObj = handleObj;

                    var ret = handleObj.handler.apply(this, args);

                    if (ret !== undefined) {
                        event.result = ret;
                        if (ret === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }

                    if (event.isImmediatePropagationStopped()) {
                        break;
                    }
                }
            }
            return event.result;
        },

        props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // store a copy of the original event object
            // and "clone" to set read-only properties
            var originalEvent = event;
            event = jQuery.Event(originalEvent);

            for (var i = this.props.length, prop; i; ) {
                prop = this.props[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary
            if (!event.target) {
                // Fixes #1925 where srcElement might not be defined either
                event.target = event.srcElement || document;
            }

            // check if target is a textnode (safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // Add relatedTarget, if necessary
            if (!event.relatedTarget && event.fromElement) {
                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
            }

            // Calculate pageX/Y if missing and clientX/Y available
            if (event.pageX == null && event.clientX != null) {
                var eventDocument = event.target.ownerDocument || document,
				doc = eventDocument.documentElement,
				body = eventDocument.body;

                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }

            // Add which for key events
            if (event.which == null && (event.charCode != null || event.keyCode != null)) {
                event.which = event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
            if (!event.metaKey && event.ctrlKey) {
                event.metaKey = event.ctrlKey;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if (!event.which && event.button !== undefined) {
                event.which = (event.button & 1 ? 1 : (event.button & 2 ? 3 : (event.button & 4 ? 2 : 0)));
            }

            return event;
        },

        // Deprecated, use jQuery.guid instead
        guid: 1E8,

        // Deprecated, use jQuery.proxy instead
        proxy: jQuery.proxy,

        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady,
                teardown: jQuery.noop
            },

            live: {
                add: function (handleObj) {
                    jQuery.event.add(this,
					liveConvert(handleObj.origType, handleObj.selector),
					jQuery.extend({}, handleObj, { handler: liveHandler, guid: handleObj.handler.guid }));
                },

                remove: function (handleObj) {
                    jQuery.event.remove(this, liveConvert(handleObj.origType, handleObj.selector), handleObj);
                }
            },

            beforeunload: {
                setup: function (data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function (namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = document.removeEventListener ?
	function (elem, type, handle) {
	    if (elem.removeEventListener) {
	        elem.removeEventListener(type, handle, false);
	    }
	} :
	function (elem, type, handle) {
	    if (elem.detachEvent) {
	        elem.detachEvent("on" + type, handle);
	    }
	};

    jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!this.preventDefault) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // timeStamp is buggy for some events on Firefox(#3843)
        // So we won't rely on the native value
        this.timeStamp = jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }

            // if preventDefault exists run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Checks if an event happened on an element within another element
    // Used in jQuery.event.special.mouseenter and mouseleave handlers
    var withinElement = function (event) {

        // Check if mouse(over|out) are still within the same parent element
        var related = event.relatedTarget,
		inside = false,
		eventType = event.type;

        event.type = event.data;

        if (related !== this) {

            if (related) {
                inside = jQuery.contains(this, related);
            }

            if (!inside) {

                jQuery.event.handle.apply(this, arguments);

                event.type = eventType;
            }
        }
    },

    // In case of event delegation, we only need to rename the event.type,
    // liveHandler will take care of the rest.
delegate = function (event) {
    event.type = event.data;
    jQuery.event.handle.apply(this, arguments);
};

    // Create mouseenter and mouseleave events
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            setup: function (data) {
                jQuery.event.add(this, fix, data && data.selector ? delegate : withinElement, orig);
            },
            teardown: function (data) {
                jQuery.event.remove(this, fix, data && data.selector ? delegate : withinElement);
            }
        };
    });

    // submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function (data, namespaces) {
                if (!jQuery.nodeName(this, "form")) {
                    jQuery.event.add(this, "click.specialSubmit", function (e) {
                        var elem = e.target,
						type = elem.type;

                        if ((type === "submit" || type === "image") && jQuery(elem).closest("form").length) {
                            trigger("submit", this, arguments);
                        }
                    });

                    jQuery.event.add(this, "keypress.specialSubmit", function (e) {
                        var elem = e.target,
						type = elem.type;

                        if ((type === "text" || type === "password") && jQuery(elem).closest("form").length && e.keyCode === 13) {
                            trigger("submit", this, arguments);
                        }
                    });

                } else {
                    return false;
                }
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialSubmit");
            }
        };

    }

    // change delegation, happens here so we have bind.
    if (!jQuery.support.changeBubbles) {

        var changeFilters,

	getVal = function (elem) {
	    var type = elem.type, val = elem.value;

	    if (type === "radio" || type === "checkbox") {
	        val = elem.checked;

	    } else if (type === "select-multiple") {
	        val = elem.selectedIndex > -1 ?
				jQuery.map(elem.options, function (elem) {
				    return elem.selected;
				}).join("-") :
				"";

	    } else if (jQuery.nodeName(elem, "select")) {
	        val = elem.selectedIndex;
	    }

	    return val;
	},

	testChange = function testChange(e) {
	    var elem = e.target, data, val;

	    if (!rformElems.test(elem.nodeName) || elem.readOnly) {
	        return;
	    }

	    data = jQuery._data(elem, "_change_data");
	    val = getVal(elem);

	    // the current data will be also retrieved by beforeactivate
	    if (e.type !== "focusout" || elem.type !== "radio") {
	        jQuery._data(elem, "_change_data", val);
	    }

	    if (data === undefined || val === data) {
	        return;
	    }

	    if (data != null || val) {
	        e.type = "change";
	        e.liveFired = undefined;
	        jQuery.event.trigger(e, arguments[1], elem);
	    }
	};

        jQuery.event.special.change = {
            filters: {
                focusout: testChange,

                beforedeactivate: testChange,

                click: function (e) {
                    var elem = e.target, type = jQuery.nodeName(elem, "input") ? elem.type : "";

                    if (type === "radio" || type === "checkbox" || jQuery.nodeName(elem, "select")) {
                        testChange.call(this, e);
                    }
                },

                // Change has to be called before submit
                // Keydown will be called before keypress, which is used in submit-event delegation
                keydown: function (e) {
                    var elem = e.target, type = jQuery.nodeName(elem, "input") ? elem.type : "";

                    if ((e.keyCode === 13 && !jQuery.nodeName(elem, "textarea")) ||
					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
					type === "select-multiple") {
                        testChange.call(this, e);
                    }
                },

                // Beforeactivate happens also before the previous element is blurred
                // with this event you can't trigger a change event, but you can store
                // information
                beforeactivate: function (e) {
                    var elem = e.target;
                    jQuery._data(elem, "_change_data", getVal(elem));
                }
            },

            setup: function (data, namespaces) {
                if (this.type === "file") {
                    return false;
                }

                for (var type in changeFilters) {
                    jQuery.event.add(this, type + ".specialChange", changeFilters[type]);
                }

                return rformElems.test(this.nodeName);
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialChange");

                return rformElems.test(this.nodeName);
            }
        };

        changeFilters = jQuery.event.special.change.filters;

        // Handle when the input is .focus()'d
        changeFilters.focus = changeFilters.beforeactivate;
    }

    function trigger(type, elem, args) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        // Don't pass args or remember liveFired; they apply to the donor event.
        var event = jQuery.extend({}, args[0]);
        event.type = type;
        event.originalEvent = {};
        event.liveFired = undefined;
        jQuery.event.handle.call(elem, event);
        if (event.isDefaultPrevented()) {
            args[0].preventDefault();
        }
    }

    // Create "bubbling" focus and blur events
    if (!jQuery.support.focusinBubbles) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0;

            jQuery.event.special[fix] = {
                setup: function () {
                    if (attaches++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function () {
                    if (--attaches === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };

            function handler(donor) {
                // Donor event is always a native one; fix it and switch its type.
                // Let focusin/out handler cancel the donor focus/blur event.
                var e = jQuery.event.fix(donor);
                e.type = fix;
                e.originalEvent = {};
                jQuery.event.trigger(e, null, e.target);
                if (e.isDefaultPrevented()) {
                    donor.preventDefault();
                }
            }
        });
    }

    jQuery.each(["bind", "one"], function (i, name) {
        jQuery.fn[name] = function (type, data, fn) {
            var handler;

            // Handle object literals
            if (typeof type === "object") {
                for (var key in type) {
                    this[name](key, data, type[key], fn);
                }
                return this;
            }

            if (arguments.length === 2 || data === false) {
                fn = data;
                data = undefined;
            }

            if (name === "one") {
                handler = function (event) {
                    jQuery(this).unbind(event, handler);
                    return fn.apply(this, arguments);
                };
                handler.guid = fn.guid || jQuery.guid++;
            } else {
                handler = fn;
            }

            if (type === "unload" && name !== "one") {
                this.one(type, data, fn);

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.add(this[i], type, handler, data);
                }
            }

            return this;
        };
    });

    jQuery.fn.extend({
        unbind: function (type, fn) {
            // Handle object literals
            if (typeof type === "object" && !type.preventDefault) {
                for (var key in type) {
                    this.unbind(key, type[key]);
                }

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.remove(this[i], type, fn);
                }
            }

            return this;
        },

        delegate: function (selector, types, data, fn) {
            return this.live(types, data, fn, selector);
        },

        undelegate: function (selector, types, fn) {
            if (arguments.length === 0) {
                return this.unbind("live");

            } else {
                return this.die(types, null, fn, selector);
            }
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },

        triggerHandler: function (type, data) {
            if (this[0]) {
                return jQuery.event.trigger(type, data, this[0], true);
            }
        },

        toggle: function (fn) {
            // Save reference to arguments for access in closure
            var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function (event) {
			    // Figure out which function to execute
			    var lastToggle = (jQuery.data(this, "lastToggle" + fn.guid) || 0) % i;
			    jQuery.data(this, "lastToggle" + fn.guid, lastToggle + 1);

			    // Make sure that clicks stop
			    event.preventDefault();

			    // and execute the function
			    return args[lastToggle].apply(this, arguments) || false;
			};

            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while (i < args.length) {
                args[i++].guid = guid;
            }

            return this.click(toggler);
        },

        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    var liveMap = {
        focus: "focusin",
        blur: "focusout",
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };

    jQuery.each(["live", "die"], function (i, name) {
        jQuery.fn[name] = function (types, data, fn, origSelector /* Internal Use Only */) {
            var type, i = 0, match, namespaces, preType,
			selector = origSelector || this.selector,
			context = origSelector ? this : jQuery(this.context);

            if (typeof types === "object" && !types.preventDefault) {
                for (var key in types) {
                    context[name](key, data, types[key], selector);
                }

                return this;
            }

            if (name === "die" && !types &&
					origSelector && origSelector.charAt(0) === ".") {

                context.unbind(origSelector);

                return this;
            }

            if (data === false || jQuery.isFunction(data)) {
                fn = data || returnFalse;
                data = undefined;
            }

            types = (types || "").split(" ");

            while ((type = types[i++]) != null) {
                match = rnamespaces.exec(type);
                namespaces = "";

                if (match) {
                    namespaces = match[0];
                    type = type.replace(rnamespaces, "");
                }

                if (type === "hover") {
                    types.push("mouseenter" + namespaces, "mouseleave" + namespaces);
                    continue;
                }

                preType = type;

                if (liveMap[type]) {
                    types.push(liveMap[type] + namespaces);
                    type = type + namespaces;

                } else {
                    type = (liveMap[type] || type) + namespaces;
                }

                if (name === "live") {
                    // bind live handler
                    for (var j = 0, l = context.length; j < l; j++) {
                        jQuery.event.add(context[j], "live." + liveConvert(type, selector),
						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType });
                    }

                } else {
                    // unbind live handler
                    context.unbind("live." + liveConvert(type, selector), fn);
                }
            }

            return this;
        };
    });

    function liveHandler(event) {
        var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
		elems = [],
		selectors = [],
		events = jQuery._data(this, "events");

        // Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
        if (event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click") {
            return;
        }

        if (event.namespace) {
            namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
        }

        event.liveFired = this;

        var live = events.live.slice(0);

        for (j = 0; j < live.length; j++) {
            handleObj = live[j];

            if (handleObj.origType.replace(rnamespaces, "") === event.type) {
                selectors.push(handleObj.selector);

            } else {
                live.splice(j--, 1);
            }
        }

        match = jQuery(event.target).closest(selectors, event.currentTarget);

        for (i = 0, l = match.length; i < l; i++) {
            close = match[i];

            for (j = 0; j < live.length; j++) {
                handleObj = live[j];

                if (close.selector === handleObj.selector && (!namespace || namespace.test(handleObj.namespace)) && !close.elem.disabled) {
                    elem = close.elem;
                    related = null;

                    // Those two events require additional checking
                    if (handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave") {
                        event.type = handleObj.preType;
                        related = jQuery(event.relatedTarget).closest(handleObj.selector)[0];

                        // Make sure not to accidentally match a child element with the same selector
                        if (related && jQuery.contains(elem, related)) {
                            related = elem;
                        }
                    }

                    if (!related || related !== elem) {
                        elems.push({ elem: elem, handleObj: handleObj, level: close.level });
                    }
                }
            }
        }

        for (i = 0, l = elems.length; i < l; i++) {
            match = elems[i];

            if (maxLevel && match.level > maxLevel) {
                break;
            }

            event.currentTarget = match.elem;
            event.data = match.handleObj.data;
            event.handleObj = match.handleObj;

            ret = match.handleObj.origHandler.apply(match.elem, arguments);

            if (ret === false || event.isPropagationStopped()) {
                maxLevel = match.level;

                if (ret === false) {
                    stop = false;
                }
                if (event.isImmediatePropagationStopped()) {
                    break;
                }
            }
        }

        return stop;
    }

    function liveConvert(type, selector) {
        return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspaces, "&");
    }

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error").split(" "), function (i, name) {

	    // Handle event binding
	    jQuery.fn[name] = function (data, fn) {
	        if (fn == null) {
	            fn = data;
	            data = null;
	        }

	        return arguments.length > 0 ?
			this.bind(name, data, fn) :
			this.trigger(name);
	    };

	    if (jQuery.attrFn) {
	        jQuery.attrFn[name] = true;
	    }
	});



    /*!
    * Sizzle CSS Selector Engine
    *  Copyright 2011, The Dojo Foundation
    *  Released under the MIT, BSD, and GPL Licenses.
    *  More information: http://sizzlejs.com/
    */
    (function () {

        var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rNonWord = /\W/;

        // Here we check if the JavaScript engine is using some sort of
        // optimization where it does not always call our comparision
        // function. If that is the case, discard the hasDuplicate value.
        //   Thus far that includes Google Chrome.
        [0, 0].sort(function () {
            baseHasDuplicate = false;
            return 0;
        });

        var Sizzle = function (selector, context, results, seed) {
            results = results || [];
            context = context || document;

            var origContext = context;

            if (context.nodeType !== 1 && context.nodeType !== 9) {
                return [];
            }

            if (!selector || typeof selector !== "string") {
                return results;
            }

            var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML(context),
		parts = [],
		soFar = selector;

            // Reset the position of the chunker regexp (start from head)
            do {
                chunker.exec("");
                m = chunker.exec(soFar);

                if (m) {
                    soFar = m[3];

                    parts.push(m[1]);

                    if (m[2]) {
                        extra = m[3];
                        break;
                    }
                }
            } while (m);

            if (parts.length > 1 && origPOS.exec(selector)) {

                if (parts.length === 2 && Expr.relative[parts[0]]) {
                    set = posProcess(parts[0] + parts[1], context);

                } else {
                    set = Expr.relative[parts[0]] ?
				[context] :
				Sizzle(parts.shift(), context);

                    while (parts.length) {
                        selector = parts.shift();

                        if (Expr.relative[selector]) {
                            selector += parts.shift();
                        }

                        set = posProcess(selector, set);
                    }
                }

            } else {
                // Take a shortcut and set the context if the root selector is an ID
                // (but not if it'll be faster if the inner selector is an ID)
                if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {

                    ret = Sizzle.find(parts.shift(), context, contextXML);
                    context = ret.expr ?
				Sizzle.filter(ret.expr, ret.set)[0] :
				ret.set[0];
                }

                if (context) {
                    ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed)} :
				Sizzle.find(parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML);

                    set = ret.expr ?
				Sizzle.filter(ret.expr, ret.set) :
				ret.set;

                    if (parts.length > 0) {
                        checkSet = makeArray(set);

                    } else {
                        prune = false;
                    }

                    while (parts.length) {
                        cur = parts.pop();
                        pop = cur;

                        if (!Expr.relative[cur]) {
                            cur = "";
                        } else {
                            pop = parts.pop();
                        }

                        if (pop == null) {
                            pop = context;
                        }

                        Expr.relative[cur](checkSet, pop, contextXML);
                    }

                } else {
                    checkSet = parts = [];
                }
            }

            if (!checkSet) {
                checkSet = set;
            }

            if (!checkSet) {
                Sizzle.error(cur || selector);
            }

            if (toString.call(checkSet) === "[object Array]") {
                if (!prune) {
                    results.push.apply(results, checkSet);

                } else if (context && context.nodeType === 1) {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i]))) {
                            results.push(set[i]);
                        }
                    }

                } else {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && checkSet[i].nodeType === 1) {
                            results.push(set[i]);
                        }
                    }
                }

            } else {
                makeArray(checkSet, results);
            }

            if (extra) {
                Sizzle(extra, origContext, results, seed);
                Sizzle.uniqueSort(results);
            }

            return results;
        };

        Sizzle.uniqueSort = function (results) {
            if (sortOrder) {
                hasDuplicate = baseHasDuplicate;
                results.sort(sortOrder);

                if (hasDuplicate) {
                    for (var i = 1; i < results.length; i++) {
                        if (results[i] === results[i - 1]) {
                            results.splice(i--, 1);
                        }
                    }
                }
            }

            return results;
        };

        Sizzle.matches = function (expr, set) {
            return Sizzle(expr, null, null, set);
        };

        Sizzle.matchesSelector = function (node, expr) {
            return Sizzle(expr, null, null, [node]).length > 0;
        };

        Sizzle.find = function (expr, context, isXML) {
            var set;

            if (!expr) {
                return [];
            }

            for (var i = 0, l = Expr.order.length; i < l; i++) {
                var match,
			type = Expr.order[i];

                if ((match = Expr.leftMatch[type].exec(expr))) {
                    var left = match[1];
                    match.splice(1, 1);

                    if (left.substr(left.length - 1) !== "\\") {
                        match[1] = (match[1] || "").replace(rBackslash, "");
                        set = Expr.find[type](match, context, isXML);

                        if (set != null) {
                            expr = expr.replace(Expr.match[type], "");
                            break;
                        }
                    }
                }
            }

            if (!set) {
                set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName("*") :
			[];
            }

            return { set: set, expr: expr };
        };

        Sizzle.filter = function (expr, set, inplace, not) {
            var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

            while (expr && set.length) {
                for (var type in Expr.filter) {
                    if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {
                        var found, item,
					filter = Expr.filter[type],
					left = match[1];

                        anyFound = false;

                        match.splice(1, 1);

                        if (left.substr(left.length - 1) === "\\") {
                            continue;
                        }

                        if (curLoop === result) {
                            result = [];
                        }

                        if (Expr.preFilter[type]) {
                            match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);

                            if (!match) {
                                anyFound = found = true;

                            } else if (match === true) {
                                continue;
                            }
                        }

                        if (match) {
                            for (var i = 0; (item = curLoop[i]) != null; i++) {
                                if (item) {
                                    found = filter(item, match, i, curLoop);
                                    var pass = not ^ !!found;

                                    if (inplace && found != null) {
                                        if (pass) {
                                            anyFound = true;

                                        } else {
                                            curLoop[i] = false;
                                        }

                                    } else if (pass) {
                                        result.push(item);
                                        anyFound = true;
                                    }
                                }
                            }
                        }

                        if (found !== undefined) {
                            if (!inplace) {
                                curLoop = result;
                            }

                            expr = expr.replace(Expr.match[type], "");

                            if (!anyFound) {
                                return [];
                            }

                            break;
                        }
                    }
                }

                // Improper expression
                if (expr === old) {
                    if (anyFound == null) {
                        Sizzle.error(expr);

                    } else {
                        break;
                    }
                }

                old = expr;
            }

            return curLoop;
        };

        Sizzle.error = function (msg) {
            throw "Syntax error, unrecognized expression: " + msg;
        };

        var Expr = Sizzle.selectors = {
            order: ["ID", "NAME", "TAG"],

            match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            },

            leftMatch: {},

            attrMap: {
                "class": "className",
                "for": "htmlFor"
            },

            attrHandle: {
                href: function (elem) {
                    return elem.getAttribute("href");
                },
                type: function (elem) {
                    return elem.getAttribute("type");
                }
            },

            relative: {
                "+": function (checkSet, part) {
                    var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test(part),
				isPartStrNotTag = isPartStr && !isTag;

                    if (isTag) {
                        part = part.toLowerCase();
                    }

                    for (var i = 0, l = checkSet.length, elem; i < l; i++) {
                        if ((elem = checkSet[i])) {
                            while ((elem = elem.previousSibling) && elem.nodeType !== 1) { }

                            checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
                        }
                    }

                    if (isPartStrNotTag) {
                        Sizzle.filter(part, checkSet, true);
                    }
                },

                ">": function (checkSet, part) {
                    var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

                    if (isPartStr && !rNonWord.test(part)) {
                        part = part.toLowerCase();

                        for (; i < l; i++) {
                            elem = checkSet[i];

                            if (elem) {
                                var parent = elem.parentNode;
                                checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                            }
                        }

                    } else {
                        for (; i < l; i++) {
                            elem = checkSet[i];

                            if (elem) {
                                checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
                            }
                        }

                        if (isPartStr) {
                            Sizzle.filter(part, checkSet, true);
                        }
                    }
                },

                "": function (checkSet, part, isXML) {
                    var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
                },

                "~": function (checkSet, part, isXML) {
                    var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
                }
            },

            find: {
                ID: function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [m] : [];
                    }
                },

                NAME: function (match, context) {
                    if (typeof context.getElementsByName !== "undefined") {
                        var ret = [],
					results = context.getElementsByName(match[1]);

                        for (var i = 0, l = results.length; i < l; i++) {
                            if (results[i].getAttribute("name") === match[1]) {
                                ret.push(results[i]);
                            }
                        }

                        return ret.length === 0 ? null : ret;
                    }
                },

                TAG: function (match, context) {
                    if (typeof context.getElementsByTagName !== "undefined") {
                        return context.getElementsByTagName(match[1]);
                    }
                }
            },
            preFilter: {
                CLASS: function (match, curLoop, inplace, result, not, isXML) {
                    match = " " + match[1].replace(rBackslash, "") + " ";

                    if (isXML) {
                        return match;
                    }

                    for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {
                        if (elem) {
                            if (not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0)) {
                                if (!inplace) {
                                    result.push(elem);
                                }

                            } else if (inplace) {
                                curLoop[i] = false;
                            }
                        }
                    }

                    return false;
                },

                ID: function (match) {
                    return match[1].replace(rBackslash, "");
                },

                TAG: function (match, curLoop) {
                    return match[1].replace(rBackslash, "").toLowerCase();
                },

                CHILD: function (match) {
                    if (match[1] === "nth") {
                        if (!match[2]) {
                            Sizzle.error(match[0]);
                        }

                        match[2] = match[2].replace(/^\+|\s*/g, '');

                        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                        var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test(match[2]) && "0n+" + match[2] || match[2]);

                        // calculate the numbers (first)n+(last) including if they are negative
                        match[2] = (test[1] + (test[2] || 1)) - 0;
                        match[3] = test[3] - 0;
                    }
                    else if (match[2]) {
                        Sizzle.error(match[0]);
                    }

                    // TODO: Move to normal caching system
                    match[0] = done++;

                    return match;
                },

                ATTR: function (match, curLoop, inplace, result, not, isXML) {
                    var name = match[1] = match[1].replace(rBackslash, "");

                    if (!isXML && Expr.attrMap[name]) {
                        match[1] = Expr.attrMap[name];
                    }

                    // Handle if an un-quoted value was used
                    match[4] = (match[4] || match[5] || "").replace(rBackslash, "");

                    if (match[2] === "~=") {
                        match[4] = " " + match[4] + " ";
                    }

                    return match;
                },

                PSEUDO: function (match, curLoop, inplace, result, not) {
                    if (match[1] === "not") {
                        // If we're dealing with a complex expression, or a simple one
                        if ((chunker.exec(match[3]) || "").length > 1 || /^\w/.test(match[3])) {
                            match[3] = Sizzle(match[3], null, null, curLoop);

                        } else {
                            var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

                            if (!inplace) {
                                result.push.apply(result, ret);
                            }

                            return false;
                        }

                    } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {
                        return true;
                    }

                    return match;
                },

                POS: function (match) {
                    match.unshift(true);

                    return match;
                }
            },

            filters: {
                enabled: function (elem) {
                    return elem.disabled === false && elem.type !== "hidden";
                },

                disabled: function (elem) {
                    return elem.disabled === true;
                },

                checked: function (elem) {
                    return elem.checked === true;
                },

                selected: function (elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                parent: function (elem) {
                    return !!elem.firstChild;
                },

                empty: function (elem) {
                    return !elem.firstChild;
                },

                has: function (elem, i, match) {
                    return !!Sizzle(match[3], elem).length;
                },

                header: function (elem) {
                    return (/h\d/i).test(elem.nodeName);
                },

                text: function (elem) {
                    var attr = elem.getAttribute("type"), type = elem.type;
                    // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
                    // use getAttribute instead to test this case
                    return elem.nodeName.toLowerCase() === "input" && "text" === type && (attr === type || attr === null);
                },

                radio: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
                },

                checkbox: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
                },

                file: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
                },

                password: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
                },

                submit: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "submit" === elem.type;
                },

                image: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
                },

                reset: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "reset" === elem.type;
                },

                button: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && "button" === elem.type || name === "button";
                },

                input: function (elem) {
                    return (/input|select|textarea|button/i).test(elem.nodeName);
                },

                focus: function (elem) {
                    return elem === elem.ownerDocument.activeElement;
                }
            },
            setFilters: {
                first: function (elem, i) {
                    return i === 0;
                },

                last: function (elem, i, match, array) {
                    return i === array.length - 1;
                },

                even: function (elem, i) {
                    return i % 2 === 0;
                },

                odd: function (elem, i) {
                    return i % 2 === 1;
                },

                lt: function (elem, i, match) {
                    return i < match[3] - 0;
                },

                gt: function (elem, i, match) {
                    return i > match[3] - 0;
                },

                nth: function (elem, i, match) {
                    return match[3] - 0 === i;
                },

                eq: function (elem, i, match) {
                    return match[3] - 0 === i;
                }
            },
            filter: {
                PSEUDO: function (elem, match, i, array) {
                    var name = match[1],
				filter = Expr.filters[name];

                    if (filter) {
                        return filter(elem, i, match, array);

                    } else if (name === "contains") {
                        return (elem.textContent || elem.innerText || Sizzle.getText([elem]) || "").indexOf(match[3]) >= 0;

                    } else if (name === "not") {
                        var not = match[3];

                        for (var j = 0, l = not.length; j < l; j++) {
                            if (not[j] === elem) {
                                return false;
                            }
                        }

                        return true;

                    } else {
                        Sizzle.error(name);
                    }
                },

                CHILD: function (elem, match) {
                    var type = match[1],
				node = elem;

                    switch (type) {
                        case "only":
                        case "first":
                            while ((node = node.previousSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }

                            if (type === "first") {
                                return true;
                            }

                            node = elem;

                        case "last":
                            while ((node = node.nextSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }

                            return true;

                        case "nth":
                            var first = match[2],
						last = match[3];

                            if (first === 1 && last === 0) {
                                return true;
                            }

                            var doneName = match[0],
						parent = elem.parentNode;

                            if (parent && (parent.sizcache !== doneName || !elem.nodeIndex)) {
                                var count = 0;

                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        node.nodeIndex = ++count;
                                    }
                                }

                                parent.sizcache = doneName;
                            }

                            var diff = elem.nodeIndex - last;

                            if (first === 0) {
                                return diff === 0;

                            } else {
                                return (diff % first === 0 && diff / first >= 0);
                            }
                    }
                },

                ID: function (elem, match) {
                    return elem.nodeType === 1 && elem.getAttribute("id") === match;
                },

                TAG: function (elem, match) {
                    return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
                },

                CLASS: function (elem, match) {
                    return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf(match) > -1;
                },

                ATTR: function (elem, match) {
                    var name = match[1],
				result = Expr.attrHandle[name] ?
					Expr.attrHandle[name](elem) :
					elem[name] != null ?
						elem[name] :
						elem.getAttribute(name),
				value = result + "",
				type = match[2],
				check = match[4];

                    return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
                },

                POS: function (elem, match, i, array) {
                    var name = match[2],
				filter = Expr.setFilters[name];

                    if (filter) {
                        return filter(elem, i, match, array);
                    }
                }
            }
        };

        var origPOS = Expr.match.POS,
	fescape = function (all, num) {
	    return "\\" + (num - 0 + 1);
	};

        for (var type in Expr.match) {
            Expr.match[type] = new RegExp(Expr.match[type].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
            Expr.leftMatch[type] = new RegExp(/(^(?:.|\r|\n)*?)/.source + Expr.match[type].source.replace(/\\(\d+)/g, fescape));
        }

        var makeArray = function (array, results) {
            array = Array.prototype.slice.call(array, 0);

            if (results) {
                results.push.apply(results, array);
                return results;
            }

            return array;
        };

        // Perform a simple check to determine if the browser is capable of
        // converting a NodeList to an array using builtin methods.
        // Also verifies that the returned array holds DOM nodes
        // (which is not the case in the Blackberry browser)
        try {
            Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;

            // Provide a fallback method if it does not work
        } catch (e) {
            makeArray = function (array, results) {
                var i = 0,
			ret = results || [];

                if (toString.call(array) === "[object Array]") {
                    Array.prototype.push.apply(ret, array);

                } else {
                    if (typeof array.length === "number") {
                        for (var l = array.length; i < l; i++) {
                            ret.push(array[i]);
                        }

                    } else {
                        for (; array[i]; i++) {
                            ret.push(array[i]);
                        }
                    }
                }

                return ret;
            };
        }

        var sortOrder, siblingCheck;

        if (document.documentElement.compareDocumentPosition) {
            sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
                    return a.compareDocumentPosition ? -1 : 1;
                }

                return a.compareDocumentPosition(b) & 4 ? -1 : 1;
            };

        } else {
            sortOrder = function (a, b) {
                // The nodes are identical, we can exit early
                if (a === b) {
                    hasDuplicate = true;
                    return 0;

                    // Fallback to using sourceIndex (in IE) if it's available on both nodes
                } else if (a.sourceIndex && b.sourceIndex) {
                    return a.sourceIndex - b.sourceIndex;
                }

                var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

                // If the nodes are siblings (or identical) we can do a quick check
                if (aup === bup) {
                    return siblingCheck(a, b);

                    // If no parents were found then the nodes are disconnected
                } else if (!aup) {
                    return -1;

                } else if (!bup) {
                    return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while (cur) {
                    ap.unshift(cur);
                    cur = cur.parentNode;
                }

                cur = bup;

                while (cur) {
                    bp.unshift(cur);
                    cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for (var i = 0; i < al && i < bl; i++) {
                    if (ap[i] !== bp[i]) {
                        return siblingCheck(ap[i], bp[i]);
                    }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
			siblingCheck(a, bp[i], -1) :
			siblingCheck(ap[i], b, 1);
            };

            siblingCheck = function (a, b, ret) {
                if (a === b) {
                    return ret;
                }

                var cur = a.nextSibling;

                while (cur) {
                    if (cur === b) {
                        return -1;
                    }

                    cur = cur.nextSibling;
                }

                return 1;
            };
        }

        // Utility function for retreiving the text value of an array of DOM nodes
        Sizzle.getText = function (elems) {
            var ret = "", elem;

            for (var i = 0; elems[i]; i++) {
                elem = elems[i];

                // Get the text from text nodes and CDATA nodes
                if (elem.nodeType === 3 || elem.nodeType === 4) {
                    ret += elem.nodeValue;

                    // Traverse everything else, except comment nodes
                } else if (elem.nodeType !== 8) {
                    ret += Sizzle.getText(elem.childNodes);
                }
            }

            return ret;
        };

        // Check to see if the browser returns elements by name when
        // querying by getElementById (and provide a workaround)
        (function () {
            // We're going to inject a fake input element with a specified name
            var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

            form.innerHTML = "<a name='" + id + "'/>";

            // Inject it into the root element, check its status, and remove it quickly
            root.insertBefore(form, root.firstChild);

            // The workaround has to do additional checks after a getElementById
            // Which slows things down for other browsers (hence the branching)
            if (document.getElementById(id)) {
                Expr.find.ID = function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);

                        return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
                    }
                };

                Expr.filter.ID = function (elem, match) {
                    var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

                    return elem.nodeType === 1 && node && node.nodeValue === match;
                };
            }

            root.removeChild(form);

            // release memory in IE
            root = form = null;
        })();

        (function () {
            // Check to see if the browser returns only elements
            // when doing getElementsByTagName("*")

            // Create a fake element
            var div = document.createElement("div");
            div.appendChild(document.createComment(""));

            // Make sure no comments are found
            if (div.getElementsByTagName("*").length > 0) {
                Expr.find.TAG = function (match, context) {
                    var results = context.getElementsByTagName(match[1]);

                    // Filter out possible comments
                    if (match[1] === "*") {
                        var tmp = [];

                        for (var i = 0; results[i]; i++) {
                            if (results[i].nodeType === 1) {
                                tmp.push(results[i]);
                            }
                        }

                        results = tmp;
                    }

                    return results;
                };
            }

            // Check to see if an attribute returns normalized href attributes
            div.innerHTML = "<a href='#'></a>";

            if (div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#") {

                Expr.attrHandle.href = function (elem) {
                    return elem.getAttribute("href", 2);
                };
            }

            // release memory in IE
            div = null;
        })();

        if (document.querySelectorAll) {
            (function () {
                var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

                div.innerHTML = "<p class='TEST'></p>";

                // Safari can't handle uppercase or unicode characters when
                // in quirks mode.
                if (div.querySelectorAll && div.querySelectorAll(".TEST").length === 0) {
                    return;
                }

                Sizzle = function (query, context, extra, seed) {
                    context = context || document;

                    // Only use querySelectorAll on non-XML documents
                    // (ID selectors don't work in non-HTML documents)
                    if (!seed && !Sizzle.isXML(context)) {
                        // See if we find a selector to speed up
                        var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(query);

                        if (match && (context.nodeType === 1 || context.nodeType === 9)) {
                            // Speed-up: Sizzle("TAG")
                            if (match[1]) {
                                return makeArray(context.getElementsByTagName(query), extra);

                                // Speed-up: Sizzle(".CLASS")
                            } else if (match[2] && Expr.find.CLASS && context.getElementsByClassName) {
                                return makeArray(context.getElementsByClassName(match[2]), extra);
                            }
                        }

                        if (context.nodeType === 9) {
                            // Speed-up: Sizzle("body")
                            // The body element only exists once, optimize finding it
                            if (query === "body" && context.body) {
                                return makeArray([context.body], extra);

                                // Speed-up: Sizzle("#ID")
                            } else if (match && match[3]) {
                                var elem = context.getElementById(match[3]);

                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if (elem && elem.parentNode) {
                                    // Handle the case where IE and Opera return items
                                    // by name instead of ID
                                    if (elem.id === match[3]) {
                                        return makeArray([elem], extra);
                                    }

                                } else {
                                    return makeArray([], extra);
                                }
                            }

                            try {
                                return makeArray(context.querySelectorAll(query), extra);
                            } catch (qsaError) { }

                            // qSA works strangely on Element-rooted queries
                            // We can work around this by specifying an extra ID on the root
                            // and working up from there (Thanks to Andrew Dupont for the technique)
                            // IE 8 doesn't work on object elements
                        } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            var oldContext = context,
						old = context.getAttribute("id"),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test(query);

                            if (!old) {
                                context.setAttribute("id", nid);
                            } else {
                                nid = nid.replace(/'/g, "\\$&");
                            }
                            if (relativeHierarchySelector && hasParent) {
                                context = context.parentNode;
                            }

                            try {
                                if (!relativeHierarchySelector || hasParent) {
                                    return makeArray(context.querySelectorAll("[id='" + nid + "'] " + query), extra);
                                }

                            } catch (pseudoError) {
                            } finally {
                                if (!old) {
                                    oldContext.removeAttribute("id");
                                }
                            }
                        }
                    }

                    return oldSizzle(query, context, extra, seed);
                };

                for (var prop in oldSizzle) {
                    Sizzle[prop] = oldSizzle[prop];
                }

                // release memory in IE
                div = null;
            })();
        }

        (function () {
            var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

            if (matches) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9 fails this)
                var disconnectedMatch = !matches.call(document.createElement("div"), "div"),
			pseudoWorks = false;

                try {
                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(document.documentElement, "[test!='']:sizzle");

                } catch (pseudoError) {
                    pseudoWorks = true;
                }

                Sizzle.matchesSelector = function (node, expr) {
                    // Make sure that attribute selectors are quoted
                    expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

                    if (!Sizzle.isXML(node)) {
                        try {
                            if (pseudoWorks || !Expr.match.PSEUDO.test(expr) && !/!=/.test(expr)) {
                                var ret = matches.call(node, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || !disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11) {
                                    return ret;
                                }
                            }
                        } catch (e) { }
                    }

                    return Sizzle(expr, null, null, [node]).length > 0;
                };
            }
        })();

        (function () {
            var div = document.createElement("div");

            div.innerHTML = "<div class='test e'></div><div class='test'></div>";

            // Opera can't find a second classname (in 9.6)
            // Also, make sure that getElementsByClassName actually exists
            if (!div.getElementsByClassName || div.getElementsByClassName("e").length === 0) {
                return;
            }

            // Safari caches class attributes, doesn't catch changes (in 3.2)
            div.lastChild.className = "e";

            if (div.getElementsByClassName("e").length === 1) {
                return;
            }

            Expr.order.splice(1, 0, "CLASS");
            Expr.find.CLASS = function (match, context, isXML) {
                if (typeof context.getElementsByClassName !== "undefined" && !isXML) {
                    return context.getElementsByClassName(match[1]);
                }
            };

            // release memory in IE
            div = null;
        })();

        function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                    var match = false;

                    elem = elem[dir];

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1 && !isXML) {
                            elem.sizcache = doneName;
                            elem.sizset = i;
                        }

                        if (elem.nodeName.toLowerCase() === cur) {
                            match = elem;
                            break;
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                    var match = false;

                    elem = elem[dir];

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1) {
                            if (!isXML) {
                                elem.sizcache = doneName;
                                elem.sizset = i;
                            }

                            if (typeof cur !== "string") {
                                if (elem === cur) {
                                    match = true;
                                    break;
                                }

                            } else if (Sizzle.filter(cur, [elem]).length > 0) {
                                match = elem;
                                break;
                            }
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        if (document.documentElement.contains) {
            Sizzle.contains = function (a, b) {
                return a !== b && (a.contains ? a.contains(b) : true);
            };

        } else if (document.documentElement.compareDocumentPosition) {
            Sizzle.contains = function (a, b) {
                return !!(a.compareDocumentPosition(b) & 16);
            };

        } else {
            Sizzle.contains = function () {
                return false;
            };
        }

        Sizzle.isXML = function (elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833) 
            var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        var posProcess = function (selector, context) {
            var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

            // Position selectors must be done after the filter
            // And so must :not(positional) so we move all PSEUDOs to the end
            while ((match = Expr.match.PSEUDO.exec(selector))) {
                later += match[0];
                selector = selector.replace(Expr.match.PSEUDO, "");
            }

            selector = Expr.relative[selector] ? selector + "*" : selector;

            for (var i = 0, l = root.length; i < l; i++) {
                Sizzle(selector, root[i], tmpSet);
            }

            return Sizzle.filter(later, tmpSet);
        };

        // EXPOSE
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.filters;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
    // Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
    // methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
	    children: true,
	    contents: true,
	    next: true,
	    prev: true
	};

    jQuery.fn.extend({
        find: function (selector) {
            var self = this,
			i, l;

            if (typeof selector !== "string") {
                return jQuery(selector).filter(function () {
                    for (i = 0, l = self.length; i < l; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                });
            }

            var ret = this.pushStack("", "find", selector),
			length, n, r;

            for (i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                    // Make sure that the results are unique
                    for (n = length; n < ret.length; n++) {
                        for (r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function (target) {
            var targets = jQuery(target);
            return this.filter(function () {
                for (var i = 0, l = targets.length; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        not: function (selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: function (selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },

        is: function (selector) {
            return !!selector && (typeof selector === "string" ?
			jQuery.filter(selector, this).length > 0 :
			this.filter(selector).length > 0);
        },

        closest: function (selectors, context) {
            var ret = [], i, l, cur = this[0];

            // Array
            if (jQuery.isArray(selectors)) {
                var match, selector,
				matches = {},
				level = 1;

                if (cur && selectors.length) {
                    for (i = 0, l = selectors.length; i < l; i++) {
                        selector = selectors[i];

                        if (!matches[selector]) {
                            matches[selector] = POS.test(selector) ?
							jQuery(selector, context || this.context) :
							selector;
                        }
                    }

                    while (cur && cur.ownerDocument && cur !== context) {
                        for (selector in matches) {
                            match = matches[selector];

                            if (match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match)) {
                                ret.push({ selector: selector, elem: cur, level: level });
                            }
                        }

                        cur = cur.parentNode;
                        level++;
                    }
                }

                return ret;
            }

            // String
            var pos = POS.test(selectors) || typeof selectors !== "string" ?
				jQuery(selectors, context || this.context) :
				0;

            for (i = 0, l = this.length; i < l; i++) {
                cur = this[i];

                while (cur) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;

                    } else {
                        cur = cur.parentNode;
                        if (!cur || !cur.ownerDocument || cur === context || cur.nodeType === 11) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function (elem) {
            if (!elem || typeof elem === "string") {
                return jQuery.inArray(this[0],
                // If it receives a string, the selector is used
                // If it receives nothing, the siblings are used
				elem ? jQuery(elem) : this.parent().children());
            }
            // Locate the position of the desired element
            return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this);
        },

        add: function (selector, context) {
            var set = typeof selector === "string" ?
				jQuery(selector, context) :
				jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
			all = jQuery.merge(this.get(), set);

            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
			all :
			jQuery.unique(all));
        },

        andSelf: function () {
            return this.add(this.prevObject);
        }
    });

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return jQuery.nth(elem, 2, "nextSibling");
        },
        prev: function (elem) {
            return jQuery.nth(elem, 2, "previousSibling");
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return jQuery.sibling(elem.parentNode.firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, "iframe") ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray(elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until),
            // The variable 'args' was introduced in
            // https://github.com/jquery/jquery/commit/52a0238
            // to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
            // http://code.google.com/p/v8/issues/detail?id=1050
			args = slice.call(arguments);

            if (!runtil.test(name)) {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }

            ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

            if ((this.length > 1 || rmultiselector.test(selector)) && rparentsprev.test(name)) {
                ret = ret.reverse();
            }

            return this.pushStack(ret, name, args.join(","));
        };
    });

    jQuery.extend({
        filter: function (expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
			jQuery.find.matches(expr, elems);
        },

        dir: function (elem, dir, until) {
            var matched = [],
			cur = elem[dir];

            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        nth: function (cur, result, dir, elem) {
            result = result || 1;
            var num = 0;

            for (; cur; cur = cur[dir]) {
                if (cur.nodeType === 1 && ++num === result) {
                    break;
                }
            }

            return cur;
        },

        sibling: function (n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, keep) {

        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;

        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });

        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem, i) {
                return (elem === qualifier) === keep;
            });

        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function (elem) {
                return elem.nodeType === 1;
            });

            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }

        return jQuery.grep(elements, function (elem, i) {
            return (jQuery.inArray(elem, qualifier) >= 0) === keep;
        });
    }




    var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnocache = /<(?:script|object|embed|option|style)/i,
    // checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
	    option: [1, "<select multiple='multiple'>", "</select>"],
	    legend: [1, "<fieldset>", "</fieldset>"],
	    thead: [1, "<table>", "</table>"],
	    tr: [2, "<table><tbody>", "</tbody></table>"],
	    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
	    area: [1, "<map>", "</map>"],
	    _default: [0, "", ""]
	};

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE can't serialize <link> and <script> tags normally
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "div<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: function (text) {
            if (jQuery.isFunction(text)) {
                return this.each(function (i) {
                    var self = jQuery(this);

                    self.text(text.call(this, i, self.text()));
                });
            }

            if (typeof text !== "object" && text !== undefined) {
                return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(text));
            }

            return jQuery.text(this);
        },

        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
				contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            return this.each(function () {
                jQuery(this).wrapAll(html);
            });
        },

        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },

        append: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },

        before: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            } else if (arguments.length) {
                var set = jQuery(arguments[0]);
                set.push.apply(set, this.toArray());
                return this.pushStack(set, "before", arguments);
            }
        },

        after: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            } else if (arguments.length) {
                var set = this.pushStack(this, "after", arguments);
                set.push.apply(set, jQuery(arguments[0]).toArray());
                return set;
            }
        },

        // keepData is for internal use only--do not document
        remove: function (selector, keepData) {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]);
                    }

                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }

            return this;
        },

        empty: function () {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            if (value === undefined) {
                return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

                // See if we can take a shortcut and just use innerHTML
            } else if (typeof value === "string" && !rnocache.test(value) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
			!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                value = value.replace(rxhtmlTag, "<$1></$2>");

                try {
                    for (var i = 0, l = this.length; i < l; i++) {
                        // Remove element nodes and prevent memory leaks
                        if (this[i].nodeType === 1) {
                            jQuery.cleanData(this[i].getElementsByTagName("*"));
                            this[i].innerHTML = value;
                        }
                    }

                    // If using innerHTML throws an exception, use the fallback method
                } catch (e) {
                    this.empty().append(value);
                }

            } else if (jQuery.isFunction(value)) {
                this.each(function (i) {
                    var self = jQuery(this);

                    self.html(value.call(this, i, self.html()));
                });

            } else {
                this.empty().append(value);
            }

            return this;
        },

        replaceWith: function (value) {
            if (this[0] && this[0].parentNode) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }

                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }

                return this.each(function () {
                    var next = this.nextSibling,
					parent = this.parentNode;

                    jQuery(this).remove();

                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            } else {
                return this.length ?
				this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) :
				this;
            }
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, table, callback) {
            var results, first, fragment, parent,
			value = args[0],
			scripts = [];

            // We can't cloneNode fragments that contain checked, in WebKit
            if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function () {
                    jQuery(this).domManip(args, table, callback, true);
                });
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }

            if (this[0]) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if (jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length) {
                    results = { fragment: parent };

                } else {
                    results = jQuery.buildFragment(args, this, scripts);
                }

                fragment = results.fragment;

                if (fragment.childNodes.length === 1) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }

                if (first) {
                    table = table && jQuery.nodeName(first, "tr");

                    for (var i = 0, l = this.length, lastIndex = l - 1; i < l; i++) {
                        callback.call(
						table ?
							root(this[i], first) :
							this[i],
                        // Make sure that we do not leak memory by inadvertently discarding
                        // the original fragment (which might have attached data) instead of
                        // using it; in addition, use the original fragment object for the last
                        // item instead of first because it can end up being emptied incorrectly
                        // in certain situations (Bug #8070).
                        // Fragments from the fragment cache must always be cloned and never used
                        // in place.
						results.cacheable || (l > 1 && i < lastIndex) ?
							jQuery.clone(fragment, true, true) :
							fragment
					);
                    }
                }

                if (scripts.length) {
                    jQuery.each(scripts, evalScript);
                }
            }

            return this;
        }
    });

    function root(elem, cur) {
        return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
    }

    function cloneCopyEvent(src, dest) {

        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }

        var internalKey = jQuery.expando,
		oldData = jQuery.data(src),
		curData = jQuery.data(dest, oldData);

        // Switch to use the internal data object, if it exists, for the next
        // stage of data copying
        if ((oldData = oldData[internalKey])) {
            var events = oldData.events;
            curData = curData[internalKey] = jQuery.extend({}, oldData);

            if (events) {
                delete curData.handle;
                curData.events = {};

                for (var type in events) {
                    for (var i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type + (events[type][i].namespace ? "." : "") + events[type][i].namespace, events[type][i], events[type][i].data);
                    }
                }
            }
        }
    }

    function cloneFixAttributes(src, dest) {
        var nodeName;

        // We do not need to do anything for non-Elements
        if (dest.nodeType !== 1) {
            return;
        }

        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if (dest.clearAttributes) {
            dest.clearAttributes();
        }

        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if (dest.mergeAttributes) {
            dest.mergeAttributes(src);
        }

        nodeName = dest.nodeName.toLowerCase();

        // IE6-8 fail to clone children inside object elements that use
        // the proprietary classid attribute value (rather than the type
        // attribute) to identify the type of content to display
        if (nodeName === "object") {
            dest.outerHTML = src.outerHTML;

        } else if (nodeName === "input" && (src.type === "checkbox" || src.type === "radio")) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            if (src.checked) {
                dest.defaultChecked = dest.checked = src.checked;
            }

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if (dest.value !== src.value) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if (nodeName === "option") {
            dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }

        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute(jQuery.expando);
    }

    jQuery.buildFragment = function (args, nodes, scripts) {
        var fragment, cacheable, cacheresults, doc;

        // nodes may contain either an explicit document object,
        // a jQuery collection or context object.
        // If nodes[0] contains a valid object to assign to doc
        if (nodes && nodes[0]) {
            doc = nodes[0].ownerDocument || nodes[0];
        }

        // Ensure that an attr object doesn't incorrectly stand in as a document object
        // Chrome and Firefox seem to allow this to occur and will throw exception
        // Fixes #8950
        if (!doc.createDocumentFragment) {
            doc = document;
        }

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        if (args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
		args[0].charAt(0) === "<" && !rnocache.test(args[0]) && (jQuery.support.checkClone || !rchecked.test(args[0]))) {

            cacheable = true;

            cacheresults = jQuery.fragments[args[0]];
            if (cacheresults && cacheresults !== 1) {
                fragment = cacheresults;
            }
        }

        if (!fragment) {
            fragment = doc.createDocumentFragment();
            jQuery.clean(args, doc, fragment, scripts);
        }

        if (cacheable) {
            jQuery.fragments[args[0]] = cacheresults ? fragment : 1;
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var ret = [],
			insert = jQuery(selector),
			parent = this.length === 1 && this[0].parentNode;

            if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {
                insert[original](this[0]);
                return this;

            } else {
                for (var i = 0, l = insert.length; i < l; i++) {
                    var elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    function getAll(elem) {
        if ("getElementsByTagName" in elem) {
            return elem.getElementsByTagName("*");

        } else if ("querySelectorAll" in elem) {
            return elem.querySelectorAll("*");

        } else {
            return [];
        }
    }

    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        if (elem.type === "checkbox" || elem.type === "radio") {
            elem.defaultChecked = elem.checked;
        }
    }
    // Finds all inputs and passes them to fixDefaultChecked
    function findInputs(elem) {
        if (jQuery.nodeName(elem, "input")) {
            fixDefaultChecked(elem);
        } else if ("getElementsByTagName" in elem) {
            jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
        }
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var clone = elem.cloneNode(true),
				srcElements,
				destElements,
				i;

            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes(elem, clone);

                // Using Sizzle here is crazy slow, so we use getElementsByTagName
                // instead
                srcElements = getAll(elem);
                destElements = getAll(clone);

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for (i = 0; srcElements[i]; ++i) {
                    cloneFixAttributes(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                cloneCopyEvent(elem, clone);

                if (deepDataAndEvents) {
                    srcElements = getAll(elem);
                    destElements = getAll(clone);

                    for (i = 0; srcElements[i]; ++i) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function (elems, context, fragment, scripts) {
            var checkScriptType;

            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if (typeof context.createElement === "undefined") {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            var ret = [], j;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) {
                        elem = context.createTextNode(elem);
                    } else {
                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Trim whitespace, otherwise indexOf won't work as expected
                        var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
						wrap = wrapMap[tag] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

                        // Go to html and back, then peel off extra wrappers
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while (depth--) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!jQuery.support.tbody) {

                            // String was a <table>, *may* have spurious <tbody>
                            var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

                            // String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

                            for (j = tbody.length - 1; j >= 0; --j) {
                                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                    tbody[j].parentNode.removeChild(tbody[j]);
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                        }

                        elem = div.childNodes;
                    }
                }

                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if (!jQuery.support.appendChecked) {
                    if (elem[0] && typeof (len = elem.length) === "number") {
                        for (j = 0; j < len; j++) {
                            findInputs(elem[j]);
                        }
                    } else {
                        findInputs(elem);
                    }
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    ret = jQuery.merge(ret, elem);
                }
            }

            if (fragment) {
                checkScriptType = function (elem) {
                    return !elem.type || rscriptType.test(elem.type);
                };
                for (i = 0; ret[i]; i++) {
                    if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
                        scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);

                    } else {
                        if (ret[i].nodeType === 1) {
                            var jsTags = jQuery.grep(ret[i].getElementsByTagName("script"), checkScriptType);

                            ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                        }
                        fragment.appendChild(ret[i]);
                    }
                }
            }

            return ret;
        },

        cleanData: function (elems) {
            var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {
                    continue;
                }

                id = elem[jQuery.expando];

                if (id) {
                    data = cache[id] && cache[id][internalKey];

                    if (data && data.events) {
                        for (var type in data.events) {
                            if (special[type]) {
                                jQuery.event.remove(elem, type);

                                // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent(elem, type, data.handle);
                            }
                        }

                        // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                        if (data.handle) {
                            data.handle.elem = null;
                        }
                    }

                    if (deleteExpando) {
                        delete elem[jQuery.expando];

                    } else if (elem.removeAttribute) {
                        elem.removeAttribute(jQuery.expando);
                    }

                    delete cache[id];
                }
            }
        }
    });

    function evalScript(i, elem) {
        if (elem.src) {
            jQuery.ajax({
                url: elem.src,
                async: false,
                dataType: "script"
            });
        } else {
            jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, "/*$0*/"));
        }

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }



    var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
    // fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^[+\-]=/,
	rrelNumFilter = /[^+\-\.\de]+/g,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = ["Left", "Right"],
	cssHeight = ["Top", "Bottom"],
	curCSS,

	getComputedStyle,
	currentStyle;

    jQuery.fn.css = function (name, value) {
        // Setting 'undefined' is a no-op
        if (arguments.length === 2 && value === undefined) {
            return this;
        }

        return jQuery.access(this, name, value, true, function (elem, name, value) {
            return value !== undefined ?
			jQuery.style(elem, name, value) :
			jQuery.css(elem, name);
        });
    };

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity", "opacity");
                        return ret === "" ? "1" : ret;

                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, origName = jQuery.camelCase(name),
			style = elem.style, hooks = jQuery.cssHooks[origName];

            name = jQuery.cssProps[origName] || origName;

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // Make sure that NaN and null values aren't set. See: #7116
                if (type === "number" && isNaN(value) || value == null) {
                    return;
                }

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && rrelNum.test(value)) {
                    value = +value.replace(rrelNumFilter, "") + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value)) !== undefined) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[name] = value;
                    } catch (e) { }
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra) {
            var ret, hooks;

            // Make sure that we're working with the right name
            name = jQuery.camelCase(name);
            hooks = jQuery.cssHooks[name];
            name = jQuery.cssProps[name] || name;

            // cssFloat needs a special treatment
            if (name === "cssFloat") {
                name = "float";
            }

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks && (ret = hooks.get(elem, true, extra)) !== undefined) {
                return ret;

                // Otherwise, if a way to get the computed value exists, use that
            } else if (curCSS) {
                return curCSS(elem, name);
            }
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function (elem, options, callback) {
            var old = {};

            // Remember the old values, and insert the new ones
            for (var name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }

            callback.call(elem);

            // Revert the old values
            for (name in options) {
                elem.style[name] = old[name];
            }
        }
    });

    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                var val;

                if (computed) {
                    if (elem.offsetWidth !== 0) {
                        return getWH(elem, name, extra);
                    } else {
                        jQuery.swap(elem, cssShow, function () {
                            val = getWH(elem, name, extra);
                        });
                    }

                    return val;
                }
            },

            set: function (elem, value) {
                if (rnumpx.test(value)) {
                    // ignore negative width and height values #1599
                    value = parseFloat(value);

                    if (value >= 0) {
                        return value + "px";
                    }

                } else {
                    return value;
                }
            }
        };
    });

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
				(parseFloat(RegExp.$1) / 100) + "" :
				computed ? "1" : "";
            },

            set: function (elem, value) {
                var style = elem.style,
				currentStyle = elem.currentStyle;

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // Set the alpha filter to set the opacity
                var opacity = jQuery.isNaN(value) ?
				"" :
				"alpha(opacity=" + value * 100 + ")",
				filter = currentStyle && currentStyle.filter || style.filter || "";

                style.filter = ralpha.test(filter) ?
				filter.replace(ralpha, opacity) :
				filter + " " + opacity;
            }
        };
    }

    jQuery(function () {
        // This hook cannot be added until DOM ready because the support test
        // for it is not run until after DOM ready
        if (!jQuery.support.reliableMarginRight) {
            jQuery.cssHooks.marginRight = {
                get: function (elem, computed) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    var ret;
                    jQuery.swap(elem, { "display": "inline-block" }, function () {
                        if (computed) {
                            ret = curCSS(elem, "margin-right", "marginRight");
                        } else {
                            ret = elem.style.marginRight;
                        }
                    });
                    return ret;
                }
            };
        }
    });

    if (document.defaultView && document.defaultView.getComputedStyle) {
        getComputedStyle = function (elem, name) {
            var ret, defaultView, computedStyle;

            name = name.replace(rupper, "-$1").toLowerCase();

            if (!(defaultView = elem.ownerDocument.defaultView)) {
                return undefined;
            }

            if ((computedStyle = defaultView.getComputedStyle(elem, null))) {
                ret = computedStyle.getPropertyValue(name);
                if (ret === "" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {
                    ret = jQuery.style(elem, name);
                }
            }

            return ret;
        };
    }

    if (document.documentElement.currentStyle) {
        currentStyle = function (elem, name) {
            var left,
			ret = elem.currentStyle && elem.currentStyle[name],
			rsLeft = elem.runtimeStyle && elem.runtimeStyle[name],
			style = elem.style;

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if (!rnumpx.test(ret) && rnum.test(ret)) {
                // Remember the original values
                left = style.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    curCSS = getComputedStyle || currentStyle;

    function getWH(elem, name, extra) {

        // Start with offset property
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight;

        if (val > 0) {
            if (extra !== "border") {
                jQuery.each(which, function () {
                    if (!extra) {
                        val -= parseFloat(jQuery.css(elem, "padding" + this)) || 0;
                    }
                    if (extra === "margin") {
                        val += parseFloat(jQuery.css(elem, extra + this)) || 0;
                    } else {
                        val -= parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
                    }
                });
            }

            return val + "px";
        }

        // Fall back to computed then uncomputed css if necessary
        val = curCSS(elem, name, name);
        if (val < 0 || val == null) {
            val = elem.style[name] || 0;
        }
        // Normalize "", auto, and prepare for extra
        val = parseFloat(val) || 0;

        // Add padding, border, margin
        if (extra) {
            jQuery.each(which, function () {
                val += parseFloat(jQuery.css(elem, "padding" + this)) || 0;
                if (extra !== "padding") {
                    val += parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
                }
                if (extra === "margin") {
                    val += parseFloat(jQuery.css(elem, extra + this)) || 0;
                }
            });
        }

        return val + "px";
    }

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function (elem) {
            var width = elem.offsetWidth,
			height = elem.offsetHeight;

            return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css(elem, "display")) === "none");
        };

        jQuery.expr.filters.visible = function (elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }




    var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    // #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

    // Keep a copy of the old load method
	_load = jQuery.fn.load,

    /* Prefilters
    * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
    * 2) These are called:
    *    - BEFORE asking for a transport
    *    - AFTER param serialization (s.data is a string if s.processData is true)
    * 3) key is the dataType
    * 4) the catchall symbol "*" can be used
    * 5) execution will start with transport dataType and THEN continue down to "*" if needed
    */
	prefilters = {},

    /* Transports bindings
    * 1) key is the dataType
    * 2) the catchall symbol "*" can be used
    * 3) selection will start with transport dataType and THEN go to "*" if needed
    */
	transports = {},

    // Document location
	ajaxLocation,

    // Document location segments
	ajaxLocParts;

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            if (jQuery.isFunction(func)) {
                var dataTypes = dataTypeExpression.toLowerCase().split(rspacesAjax),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

                // For each dataType in the dataTypeExpression
                for (; i < length; i++) {
                    dataType = dataTypes[i];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test(dataType);
                    if (placeBefore) {
                        dataType = dataType.substr(1) || "*";
                    }
                    list = structure[dataType] = structure[dataType] || [];
                    // then we add to the structure accordingly
                    list[placeBefore ? "unshift" : "push"](func);
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */) {

        dataType = dataType || options.dataTypes[0];
        inspected = inspected || {};

        inspected[dataType] = true;

        var list = structure[dataType],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = (structure === prefilters),
		selection;

        for (; i < length && (executeOnly || !selection); i++) {
            selection = list[i](options, originalOptions, jqXHR);
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if (typeof selection === "string") {
                if (!executeOnly || inspected[selection]) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift(selection);
                    selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected);
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ((executeOnly || !selection) && !inspected["*"]) {
            selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected);
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }

    jQuery.fn.extend({
        load: function (url, params, callback) {
            if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments);

                // Don't do a request if no elements are being requested
            } else if (!this.length) {
                return this;
            }

            var off = url.indexOf(" ");
            if (off >= 0) {
                var selector = url.slice(off, url.length);
                url = url.slice(0, off);
            }

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if (params) {
                // If it's a function
                if (jQuery.isFunction(params)) {
                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if (typeof params === "object") {
                    params = jQuery.param(params, jQuery.ajaxSettings.traditional);
                    type = "POST";
                }
            }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                // Complete callback (responseText is used internally)
                complete: function (jqXHR, status, responseText) {
                    // Store the response as specified by the jqXHR object
                    responseText = jqXHR.responseText;
                    // If successful, inject the HTML into all the matched elements
                    if (jqXHR.isResolved()) {
                        // #4825: Get the actual response in case
                        // a dataFilter is present in ajaxSettings
                        jqXHR.done(function (r) {
                            responseText = r;
                        });
                        // See if a selector was specified
                        self.html(selector ?
                        // Create a dummy div to hold the results
						jQuery("<div>")
                        // inject the contents of the document in, removing the scripts
                        // to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

                        // Locate the specified elements
							.find(selector) :

                        // If not, just inject the full result
						responseText);
                    }

                    if (callback) {
                        self.each(callback, [responseText, status, jqXHR]);
                    }
                }
            });

            return this;
        },

        serialize: function () {
            return jQuery.param(this.serializeArray());
        },

        serializeArray: function () {
            return this.map(function () {
                return this.elements ? jQuery.makeArray(this.elements) : this;
            })
		.filter(function () {
		    return this.name && !this.disabled &&
				(this.checked || rselectTextarea.test(this.nodeName) ||
					rinput.test(this.type));
		})
		.map(function (i, elem) {
		    var val = jQuery(this).val();

		    return val == null ?
				null :
				jQuery.isArray(val) ?
					jQuery.map(val, function (val, i) {
					    return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
					}) :
					{ name: elem.name, value: val.replace(rCRLF, "\r\n") };
		}).get();
        }
    });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
        jQuery.fn[o] = function (f) {
            return this.bind(o, f);
        };
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });

    jQuery.extend({

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            if (!settings) {
                // Only one parameter, we extend ajaxSettings
                settings = target;
                target = jQuery.extend(true, jQuery.ajaxSettings, settings);
            } else {
                // target was provided, we extend into it
                jQuery.extend(true, target, jQuery.ajaxSettings, settings);
            }
            // Flatten fields we don't want deep extended
            for (var field in { context: 1, url: 1 }) {
                if (field in settings) {
                    target[field] = settings[field];
                } else if (field in jQuery.ajaxSettings) {
                    target[field] = jQuery.ajaxSettings[field];
                }
            }
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            traditional: false,
            headers: {},
            */

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": "*/*"
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Create the final options object
			s = jQuery.ajaxSetup({}, options),
            // Callbacks context
			callbackContext = s.context || s,
            // Context for global events
            // It's the callbackContext if one was provided in the options
            // and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				(callbackContext.nodeType || callbackContext instanceof jQuery) ?
						jQuery(callbackContext) : jQuery.event,
            // Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery._Deferred(),
            // Status-dependent callbacks
			statusCode = s.statusCode || {},
            // ifModified key
			ifModifiedKey,
            // Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
            // Response headers
			responseHeadersString,
			responseHeaders,
            // transport
			transport,
            // timeout handle
			timeoutTimer,
            // Cross-domain detection vars
			parts,
            // The jqXHR state
			state = 0,
            // To know if global events are to be dispatched
			fireGlobals,
            // Loop variable
			i,
            // Fake xhr
			jqXHR = {

			    readyState: 0,

			    // Caches the header
			    setRequestHeader: function (name, value) {
			        if (!state) {
			            var lname = name.toLowerCase();
			            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
			            requestHeaders[name] = value;
			        }
			        return this;
			    },

			    // Raw string
			    getAllResponseHeaders: function () {
			        return state === 2 ? responseHeadersString : null;
			    },

			    // Builds headers hashtable if needed
			    getResponseHeader: function (key) {
			        var match;
			        if (state === 2) {
			            if (!responseHeaders) {
			                responseHeaders = {};
			                while ((match = rheaders.exec(responseHeadersString))) {
			                    responseHeaders[match[1].toLowerCase()] = match[2];
			                }
			            }
			            match = responseHeaders[key.toLowerCase()];
			        }
			        return match === undefined ? null : match;
			    },

			    // Overrides response content-type header
			    overrideMimeType: function (type) {
			        if (!state) {
			            s.mimeType = type;
			        }
			        return this;
			    },

			    // Cancel the request
			    abort: function (statusText) {
			        statusText = statusText || "abort";
			        if (transport) {
			            transport.abort(statusText);
			        }
			        done(0, statusText);
			        return this;
			    }
			};

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done(status, statusText, responses, headers) {

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status ? 4 : 0;

                var isSuccess,
				success,
				error,
				response = responses ? ajaxHandleResponses(s, jqXHR, responses) : undefined,
				lastModified,
				etag;

                // If successful, handle type chaining
                if (status >= 200 && status < 300 || status === 304) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {

                        if ((lastModified = jqXHR.getResponseHeader("Last-Modified"))) {
                            jQuery.lastModified[ifModifiedKey] = lastModified;
                        }
                        if ((etag = jqXHR.getResponseHeader("Etag"))) {
                            jQuery.etag[ifModifiedKey] = etag;
                        }
                    }

                    // If not modified
                    if (status === 304) {

                        statusText = "notmodified";
                        isSuccess = true;

                        // If we have data
                    } else {

                        try {
                            success = ajaxConvert(s, response);
                            statusText = "success";
                            isSuccess = true;
                        } catch (e) {
                            // We have a parsererror
                            statusText = "parsererror";
                            error = e;
                        }
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (!statusText || status) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = statusText;

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"),
						[jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.resolveWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            // Attach deferreds
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.done;

            // Status-dependent callbacks
            jqXHR.statusCode = function (map) {
                if (map) {
                    var tmp;
                    if (state < 2) {
                        for (tmp in map) {
                            statusCode[tmp] = [statusCode[tmp], map[tmp]];
                        }
                    } else {
                        tmp = map[jqXHR.status];
                        jqXHR.then(tmp, tmp);
                    }
                }
                return this;
            };

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(rspacesAjax);

            // Determine if a cross-domain request is in order
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts &&
				(parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] ||
					(parts[3] || (parts[1] === "http:" ? 80 : 443)) !=
						(ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443)))
			);
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefiler, stop there
            if (state === 2) {
                return false;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if (s.cache === false) {

                    var ts = jQuery.now(),
                    // try replacing _= if it is there
					ret = s.url.replace(rts, "$1_=" + ts);

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
				s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", */*; q=0.01" : "") :
				s.accepts["*"]
		);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already
                jqXHR.abort();
                return false;

            }

            // Install callbacks on deferreds
            for (i in { success: 1, error: 1, complete: 1 }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (status < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        jQuery.error(e);
                    }
                }
            }

            return jqXHR;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function (a, traditional) {
            var s = [],
			add = function (key, value) {
			    // If value is a function, invoke it and return its value
			    value = jQuery.isFunction(value) ? value() : value;
			    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
			};

            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings.traditional;
            }

            // If an array was passed in, assume that it is an array of form elements.
            if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                // Serialize the form elements
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });

            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (var prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }

            // Return the resulting serialization
            return s.join("&").replace(r20, "+");
        }
    });

    function buildParams(prefix, obj, traditional, add) {
        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams(prefix + "[" + (typeof v === "object" || jQuery.isArray(v) ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && obj != null && typeof obj === "object") {
            // Serialize object item.
            for (var name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
    * - sets all responseXXX fields accordingly
    * - finds the right dataType (mediates between content-type and expected dataType)
    * - returns the corresponding response
    */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

        // Fill responseXXX fields
        for (type in responseFields) {
            if (type in responses) {
                jqXHR[responseFields[type]] = responses[type];
            }
        }

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("content-type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    // Chain conversions given the request and the original response
    function ajaxConvert(s, response) {

        // Apply the dataFilter if provided
        if (s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
        }

        var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
        // Current and previous dataTypes
		current = dataTypes[0],
		prev,
        // Conversion expression
		conversion,
        // Conversion function
		conv,
        // Conversion functions (transitive conversion)
		conv1,
		conv2;

        // For each dataType in the chain
        for (i = 1; i < length; i++) {

            // Create converters map
            // with lowercased keys
            if (i === 1) {
                for (key in s.converters) {
                    if (typeof key === "string") {
                        converters[key.toLowerCase()] = s.converters[key];
                    }
                }
            }

            // Get the dataTypes
            prev = current;
            current = dataTypes[i];

            // If current is auto dataType, update it to prev
            if (current === "*") {
                current = prev;
                // If no auto and dataTypes are actually different
            } else if (prev !== "*" && prev !== current) {

                // Get the converter
                conversion = prev + " " + current;
                conv = converters[conversion] || converters["* " + current];

                // If there is no direct converter, search transitively
                if (!conv) {
                    conv2 = undefined;
                    for (conv1 in converters) {
                        tmp = conv1.split(" ");
                        if (tmp[0] === prev || tmp[0] === "*") {
                            conv2 = converters[tmp[1] + " " + current];
                            if (conv2) {
                                conv1 = converters[conv1];
                                if (conv1 === true) {
                                    conv = conv2;
                                } else if (conv2 === true) {
                                    conv = conv1;
                                }
                                break;
                            }
                        }
                    }
                }
                // If we found no converter, dispatch an error
                if (!(conv || conv2)) {
                    jQuery.error("No conversion from " + conversion.replace(" ", " to "));
                }
                // If found converter is not an equivalence
                if (conv !== true) {
                    // Convert with 1 or 2 converters accordingly
                    response = conv ? conv(response) : conv2(conv1(response));
                }
            }
        }
        return response;
    }




    var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            return jQuery.expando + "_" + (jsc++);
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		(typeof s.data === "string");

        if (s.dataTypes[0] === "jsonp" ||
		s.jsonp !== false && (jsre.test(s.url) ||
				inspectData && jsre.test(s.data))) {

            var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[jsonpCallback],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

            if (s.jsonp !== false) {
                url = url.replace(jsre, replace);
                if (s.url === url) {
                    if (inspectData) {
                        data = data.replace(jsre, replace);
                    }
                    if (s.data === data) {
                        // Add callback manually
                        url += (/\?/.test(url) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                    }
                }
            }

            s.url = url;
            s.data = data;

            // Install callback
            window[jsonpCallback] = function (response) {
                responseContainer = [response];
            };

            // Clean-up function
            jqXHR.always(function () {
                // Set callback back to previous value
                window[jsonpCallback] = previous;
                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(previous)) {
                    window[jsonpCallback](responseContainer[0]);
                }
            });

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(jsonpCallback + " was not called");
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = "json";

            // Delegate to script
            return "script";
        }
    });




    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
            s.global = false;
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {

            var script,
			head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

            return {

                send: function (_, callback) {

                    script = document.createElement("script");

                    script.async = "async";

                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function (_, isAbort) {

                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }

                            // Dereference the script
                            script = undefined;

                            // Callback if not abort
                            if (!isAbort) {
                                callback(200, "success");
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore(script, head.firstChild);
                },

                abort: function () {
                    if (script) {
                        script.onload(0, 1);
                    }
                }
            };
        }
    });




    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function () {
	    // Abort all pending requests
	    for (var key in xhrCallbacks) {
	        xhrCallbacks[key](0, 1);
	    }
	} : false,
	xhrId = 0,
	xhrCallbacks;

    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) { }
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) { }
    }

    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
    /* Microsoft failed to properly
    * implement the XMLHttpRequest in IE7 (can't request local files),
    * so we use the ActiveXObject when it is available
    * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
    * we need a fallback.
    */
	function () {
	    return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
    // For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

    // Determine support properties
    (function (xhr) {
        jQuery.extend(jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ("withCredentials" in xhr)
        });
    })(jQuery.ajaxSettings.xhr());

    // Create transport if the browser can provide an xhr
    if (jQuery.support.ajax) {

        jQuery.ajaxTransport(function (s) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if (!s.crossDomain || jQuery.support.cors) {

                var callback;

                return {
                    send: function (headers, complete) {

                        // Get a new xhr
                        var xhr = s.xhr(),
						handle,
						i;

                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if (s.username) {
                            xhr.open(s.type, s.url, s.async, s.username, s.password);
                        } else {
                            xhr.open(s.type, s.url, s.async);
                        }

                        // Apply custom fields if provided
                        if (s.xhrFields) {
                            for (i in s.xhrFields) {
                                xhr[i] = s.xhrFields[i];
                            }
                        }

                        // Override mime type if needed
                        if (s.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(s.mimeType);
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!s.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }

                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }
                        } catch (_) { }

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send((s.hasContent && s.data) || null);

                        // Listener
                        callback = function (_, isAbort) {

                            var status,
							statusText,
							responseHeaders,
							responses,
							xml;

                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occured
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {

                                // Was never called and is aborted or complete
                                if (callback && (isAbort || xhr.readyState === 4)) {

                                    // Only called once
                                    callback = undefined;

                                    // Do not keep as active anymore
                                    if (handle) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if (xhrOnUnloadAbort) {
                                            delete xhrCallbacks[handle];
                                        }
                                    }

                                    // If it's an abort
                                    if (isAbort) {
                                        // Abort it manually if needed
                                        if (xhr.readyState !== 4) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        // Construct response list
                                        if (xml && xml.documentElement /* #4958 */) {
                                            responses.xml = xml;
                                        }
                                        responses.text = xhr.responseText;

                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch (e) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }

                                        // Filter status for non standard behaviors

                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if (!status && s.isLocal && !s.crossDomain) {
                                            status = responses.text ? 200 : 404;
                                            // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if (status === 1223) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch (firefoxAccessException) {
                                if (!isAbort) {
                                    complete(-1, firefoxAccessException);
                                }
                            }

                            // Call complete if needed
                            if (responses) {
                                complete(status, statusText, responses, responseHeaders);
                            }
                        };

                        // if we're in sync mode or it's in cache
                        // and has been retrieved directly (IE6 & IE7)
                        // we need to manually fire the callback
                        if (!s.async || xhr.readyState === 4) {
                            callback();
                        } else {
                            handle = ++xhrId;
                            if (xhrOnUnloadAbort) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if (!xhrCallbacks) {
                                    xhrCallbacks = {};
                                    jQuery(window).unload(xhrOnUnloadAbort);
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[handle] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function () {
                        if (callback) {
                            callback(0, 1);
                        }
                    }
                };
            }
        });
    }




    var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
    // height animations
		["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
    // width animations
		["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
    // opacity animations
		["opacity"]
	],
	fxNow,
	requestAnimationFrame = window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame;

    jQuery.fn.extend({
        show: function (speed, easing, callback) {
            var elem, display;

            if (speed || speed === 0) {
                return this.animate(genFx("show", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    elem = this[i];

                    if (elem.style) {
                        display = elem.style.display;

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if (!jQuery._data(elem, "olddisplay") && display === "none") {
                            display = elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if (display === "" && jQuery.css(elem, "display") === "none") {
                            jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    elem = this[i];

                    if (elem.style) {
                        display = elem.style.display;

                        if (display === "" || display === "none") {
                            elem.style.display = jQuery._data(elem, "olddisplay") || "";
                        }
                    }
                }

                return this;
            }
        },

        hide: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("hide", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    if (this[i].style) {
                        var display = jQuery.css(this[i], "display");

                        if (display !== "none" && !jQuery._data(this[i], "olddisplay")) {
                            jQuery._data(this[i], "olddisplay", display);
                        }
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    if (this[i].style) {
                        this[i].style.display = "none";
                    }
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: function (fn, fn2, callback) {
            var bool = typeof fn === "boolean";

            if (jQuery.isFunction(fn) && jQuery.isFunction(fn2)) {
                this._toggle.apply(this, arguments);

            } else if (fn == null || bool) {
                this.each(function () {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[state ? "show" : "hide"]();
                });

            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }

            return this;
        },

        fadeTo: function (speed, to, easing, callback) {
            return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({ opacity: to }, speed, easing, callback);
        },

        animate: function (prop, speed, easing, callback) {
            var optall = jQuery.speed(speed, easing, callback);

            if (jQuery.isEmptyObject(prop)) {
                return this.each(optall.complete, [false]);
            }

            // Do not change referenced properties as per-property easing will be lost
            prop = jQuery.extend({}, prop);

            return this[optall.queue === false ? "each" : "queue"](function () {
                // XXX 'this' does not always have a nodeName when running the
                // test suite

                if (optall.queue === false) {
                    jQuery._mark(this);
                }

                var opt = jQuery.extend({}, optall),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p,
				display, e,
				parts, start, end, unit;

                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};

                for (p in prop) {

                    // property name normalization
                    name = jQuery.camelCase(p);
                    if (p !== name) {
                        prop[name] = prop[p];
                        delete prop[p];
                    }

                    val = prop[name];

                    // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                    if (jQuery.isArray(val)) {
                        opt.animatedProperties[name] = val[1];
                        val = prop[name] = val[0];
                    } else {
                        opt.animatedProperties[name] = opt.specialEasing && opt.specialEasing[name] || opt.easing || 'swing';
                    }

                    if (val === "hide" && hidden || val === "show" && !hidden) {
                        return opt.complete.call(this);
                    }

                    if (isElement && (name === "height" || name === "width")) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height
                        // animated
                        if (jQuery.css(this, "display") === "inline" &&
							jQuery.css(this, "float") === "none") {
                            if (!jQuery.support.inlineBlockNeedsLayout) {
                                this.style.display = "inline-block";

                            } else {
                                display = defaultDisplay(this.nodeName);

                                // inline-level elements accept inline-block;
                                // block-level elements need to be inline with layout
                                if (display === "inline") {
                                    this.style.display = "inline-block";

                                } else {
                                    this.style.display = "inline";
                                    this.style.zoom = 1;
                                }
                            }
                        }
                    }
                }

                if (opt.overflow != null) {
                    this.style.overflow = "hidden";
                }

                for (p in prop) {
                    e = new jQuery.fx(this, opt, p);
                    val = prop[p];

                    if (rfxtypes.test(val)) {
                        e[val === "toggle" ? hidden ? "show" : "hide" : val]();

                    } else {
                        parts = rfxnum.exec(val);
                        start = e.cur();

                        if (parts) {
                            end = parseFloat(parts[2]);
                            unit = parts[3] || (jQuery.cssNumber[p] ? "" : "px");

                            // We need to compute starting value
                            if (unit !== "px") {
                                jQuery.style(this, p, (end || 1) + unit);
                                start = ((end || 1) / e.cur()) * start;
                                jQuery.style(this, p, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if (parts[1]) {
                                end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                            }

                            e.custom(start, end, unit);

                        } else {
                            e.custom(start, val, "");
                        }
                    }
                }

                // For JS strict compliance
                return true;
            });
        },

        stop: function (clearQueue, gotoEnd) {
            if (clearQueue) {
                this.queue([]);
            }

            this.each(function () {
                var timers = jQuery.timers,
				i = timers.length;
                // clear marker counters if we know they won't be
                if (!gotoEnd) {
                    jQuery._unmark(true, this);
                }
                while (i--) {
                    if (timers[i].elem === this) {
                        if (gotoEnd) {
                            // force the next step to be the last
                            timers[i](true);
                        }

                        timers.splice(i, 1);
                    }
                }
            });

            // start the next in the queue if the last step wasn't forced
            if (!gotoEnd) {
                this.dequeue();
            }

            return this;
        }

    });

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(clearFxNow, 0);
        return (fxNow = jQuery.now());
    }

    function clearFxNow() {
        fxNow = undefined;
    }

    // Generate parameters to create a standard animation
    function genFx(type, num) {
        var obj = {};

        jQuery.each(fxAttrs.concat.apply([], fxAttrs.slice(0, num)), function () {
            obj[this] = type;
        });

        return obj;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show", 1),
        slideUp: genFx("hide", 1),
        slideToggle: genFx("toggle", 1),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.extend({
        speed: function (speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing ||
				jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

            // Queueing
            opt.old = opt.complete;
            opt.complete = function (noUnmark) {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }

                if (opt.queue !== false) {
                    jQuery.dequeue(this);
                } else if (noUnmark !== false) {
                    jQuery._unmark(this);
                }
            };

            return opt;
        },

        easing: {
            linear: function (p, n, firstNum, diff) {
                return firstNum + diff * p;
            },
            swing: function (p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
            }
        },

        timers: [],

        fx: function (elem, options, prop) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;

            options.orig = options.orig || {};
        }

    });

    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: function () {
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            (jQuery.fx.step[this.prop] || jQuery.fx.step._default)(this);
        },

        // Get the current size
        cur: function () {
            if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {
                return this.elem[this.prop];
            }

            var parsed,
			r = jQuery.css(this.elem, this.prop);
            // Empty strings, null, undefined and "auto" are converted to 0,
            // complex values such as "rotate(1rad)" are returned as is,
            // simple values such as "10px" are parsed to Float.
            return isNaN(parsed = parseFloat(r)) ? !r || r === "auto" ? 0 : r : parsed;
        },

        // Start an animation from one number to another
        custom: function (from, to, unit) {
            var self = this,
			fx = jQuery.fx,
			raf;

            this.startTime = fxNow || createFxNow();
            this.start = from;
            this.end = to;
            this.unit = unit || this.unit || (jQuery.cssNumber[this.prop] ? "" : "px");
            this.now = this.start;
            this.pos = this.state = 0;

            function t(gotoEnd) {
                return self.step(gotoEnd);
            }

            t.elem = this.elem;

            if (t() && jQuery.timers.push(t) && !timerId) {
                // Use requestAnimationFrame instead of setInterval if available
                if (requestAnimationFrame) {
                    timerId = true;
                    raf = function () {
                        // When timerId gets set to null at any point, this stops
                        if (timerId) {
                            requestAnimationFrame(raf);
                            fx.tick();
                        }
                    };
                    requestAnimationFrame(raf);
                } else {
                    timerId = setInterval(fx.tick, fx.interval);
                }
            }
        },

        // Simple 'show' function
        show: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.show = true;

            // Begin the animation
            // Make sure that we start at a small width/height to avoid any
            // flash of content
            this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

            // Start by showing the element
            jQuery(this.elem).show();
        },

        // Simple 'hide' function
        hide: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.hide = true;

            // Begin the animation
            this.custom(this.cur(), 0);
        },

        // Each step of an animation
        step: function (gotoEnd) {
            var t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options,
			i, n;

            if (gotoEnd || t >= options.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                options.animatedProperties[this.prop] = true;

                for (i in options.animatedProperties) {
                    if (options.animatedProperties[i] !== true) {
                        done = false;
                    }
                }

                if (done) {
                    // Reset the overflow
                    if (options.overflow != null && !jQuery.support.shrinkWrapBlocks) {

                        jQuery.each(["", "X", "Y"], function (index, value) {
                            elem.style["overflow" + value] = options.overflow[index];
                        });
                    }

                    // Hide the element if the "hide" operation was done
                    if (options.hide) {
                        jQuery(elem).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if (options.hide || options.show) {
                        for (var p in options.animatedProperties) {
                            jQuery.style(elem, p, options.orig[p]);
                        }
                    }

                    // Execute the complete function
                    options.complete.call(elem);
                }

                return false;

            } else {
                // classical easing cannot be used with an Infinity duration
                if (options.duration == Infinity) {
                    this.now = t;
                } else {
                    n = t - this.startTime;
                    this.state = n / options.duration;

                    // Perform the easing function, defaults to swing
                    this.pos = jQuery.easing[options.animatedProperties[this.prop]](this.state, n, 0, 1, options.duration);
                    this.now = this.start + ((this.end - this.start) * this.pos);
                }
                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend(jQuery.fx, {
        tick: function () {
            for (var timers = jQuery.timers, i = 0; i < timers.length; ++i) {
                if (!timers[i]()) {
                    timers.splice(i--, 1);
                }
            }

            if (!timers.length) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: function () {
            clearInterval(timerId);
            timerId = null;
        },

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: function (fx) {
                jQuery.style(fx.elem, "opacity", fx.now);
            },

            _default: function (fx) {
                if (fx.elem.style && fx.elem.style[fx.prop] != null) {
                    fx.elem.style[fx.prop] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
                } else {
                    fx.elem[fx.prop] = fx.now;
                }
            }
        }
    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
            }).length;
        };
    }

    // Try to restore the default display value of an element
    function defaultDisplay(nodeName) {

        if (!elemdisplay[nodeName]) {

            var body = document.body,
			elem = jQuery("<" + nodeName + ">").appendTo(body),
			display = elem.css("display");

            elem.remove();

            // If the simple way fails,
            // get element's real default display by attaching it to a temp iframe
            if (display === "none" || display === "") {
                // No iframe to use yet, so create it
                if (!iframe) {
                    iframe = document.createElement("iframe");
                    iframe.frameBorder = iframe.width = iframe.height = 0;
                }

                body.appendChild(iframe);

                // Create a cacheable copy of the iframe document on first call.
                // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                // document to it; WebKit & Firefox won't allow reusing the iframe document.
                if (!iframeDoc || !iframe.createElement) {
                    iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                    iframeDoc.write((document.compatMode === "CSS1Compat" ? "<!doctype html>" : "") + "<html><body>");
                    iframeDoc.close();
                }

                elem = iframeDoc.createElement(nodeName);

                iframeDoc.body.appendChild(elem);

                display = jQuery.css(elem, "display");

                body.removeChild(iframe);
            }

            // Store the correct default display
            elemdisplay[nodeName] = display;
        }

        return elemdisplay[nodeName];
    }




    var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

    if ("getBoundingClientRect" in document.documentElement) {
        jQuery.fn.offset = function (options) {
            var elem = this[0], box;

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            try {
                box = elem.getBoundingClientRect();
            } catch (e) { }

            var doc = elem.ownerDocument,
			docElem = doc.documentElement;

            // Make sure we're not dealing with a disconnected DOM node
            if (!box || !jQuery.contains(docElem, elem)) {
                return box ? { top: box.top, left: box.left} : { top: 0, left: 0 };
            }

            var body = doc.body,
			win = getWindow(doc),
			clientTop = docElem.clientTop || body.clientTop || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top = box.top + scrollTop - clientTop,
			left = box.left + scrollLeft - clientLeft;

            return { top: top, left: left };
        };

    } else {
        jQuery.fn.offset = function (options) {
            var elem = this[0];

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            jQuery.offset.initialize();

            var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

            while ((elem = elem.parentNode) && elem !== body && elem !== docElem) {
                if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                    break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top -= elem.scrollTop;
                left -= elem.scrollLeft;

                if (elem === offsetParent) {
                    top += elem.offsetTop;
                    left += elem.offsetLeft;

                    if (jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName))) {
                        top += parseFloat(computedStyle.borderTopWidth) || 0;
                        left += parseFloat(computedStyle.borderLeftWidth) || 0;
                    }

                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }

                if (jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible") {
                    top += parseFloat(computedStyle.borderTopWidth) || 0;
                    left += parseFloat(computedStyle.borderLeftWidth) || 0;
                }

                prevComputedStyle = computedStyle;
            }

            if (prevComputedStyle.position === "relative" || prevComputedStyle.position === "static") {
                top += body.offsetTop;
                left += body.offsetLeft;
            }

            if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                top += Math.max(docElem.scrollTop, body.scrollTop);
                left += Math.max(docElem.scrollLeft, body.scrollLeft);
            }

            return { top: top, left: left };
        };
    }

    jQuery.offset = {
        initialize: function () {
            var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat(jQuery.css(body, "marginTop")) || 0,
			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

            jQuery.extend(container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" });

            container.innerHTML = html;
            body.insertBefore(container, body.firstChild);
            innerDiv = container.firstChild;
            checkDiv = innerDiv.firstChild;
            td = innerDiv.nextSibling.firstChild.firstChild;

            this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
            this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

            checkDiv.style.position = "fixed";
            checkDiv.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
            checkDiv.style.position = checkDiv.style.top = "";

            innerDiv.style.overflow = "hidden";
            innerDiv.style.position = "relative";

            this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

            this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

            body.removeChild(container);
            jQuery.offset.initialize = jQuery.noop;
        },

        bodyOffset: function (body) {
            var top = body.offsetTop,
			left = body.offsetLeft;

            jQuery.offset.initialize();

            if (jQuery.offset.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function (elem, options, i) {
            var position = jQuery.css(elem, "position");

            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            var curElem = jQuery(elem),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css(elem, "top"),
			curCSSLeft = jQuery.css(elem, "left"),
			calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };


    jQuery.fn.extend({
        position: function () {
            if (!this[0]) {
                return null;
            }

            var elem = this[0],

            // Get *real* offsetParent
		offsetParent = this.offsetParent(),

            // Get correct offsets
		offset = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0} : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

            // Add offsetParent borders
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

            // Subtract the two offsets
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each(["Left", "Top"], function (i, name) {
        var method = "scroll" + name;

        jQuery.fn[method] = function (val) {
            var elem, win;

            if (val === undefined) {
                elem = this[0];

                if (!elem) {
                    return null;
                }

                win = getWindow(elem);

                // Return the scroll offset
                /* original jQuery code - contradicts with "offset" method, where the document scroll top position is calculated differently
                return win ? ("pageXOffset" in win) ? win[i ? "pageYOffset" : "pageXOffset"] :
				jQuery.support.boxModel && win.document.documentElement[method] ||
					win.document.body[method] :
				elem[method];
                */
                
                return win 
                    ? 
                        win[ i ? "pageYOffset" : "pageXOffset" ] || jQuery.support.boxModel && win.document.documentElement[method] || win.document.body[method] 
                    :
                        elem[method];
            }

            // Set the scroll offset
            return this.each(function () {
                win = getWindow(this);

                if (win) {
                    win.scrollTo(
					!i ? val : jQuery(win).scrollLeft(),
					 i ? val : jQuery(win).scrollTop()
				);

                } else {
                    this[method] = val;
                }
            });
        };
    });

    function getWindow(elem) {
        return jQuery.isWindow(elem) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
    }




    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each(["Height", "Width"], function (i, name) {

        var type = name.toLowerCase();

        // innerHeight and innerWidth
        jQuery.fn["inner" + name] = function () {
            var elem = this[0];
            return elem && elem.style ?
			parseFloat(jQuery.css(elem, type, "padding")) :
			null;
        };

        // outerHeight and outerWidth
        jQuery.fn["outer" + name] = function (margin) {
            var elem = this[0];
            return elem && elem.style ?
			parseFloat(jQuery.css(elem, type, margin ? "margin" : "border")) :
			null;
        };

        jQuery.fn[type] = function (size) {
            // Get window width or height
            var elem = this[0];
            if (!elem) {
                return size == null ? null : this;
            }

            if (jQuery.isFunction(size)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self[type](size.call(this, i, self[type]()));
                });
            }

            if (jQuery.isWindow(elem)) {
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                var docElemProp = elem.document.documentElement["client" + name];
                return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				elem.document.body["client" + name] || docElemProp;

                // Get document width or height
            } else if (elem.nodeType === 9) {
                // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

                // Get or set width or height on the element
            } else if (size === undefined) {
                var orig = jQuery.css(elem, type),
				ret = parseFloat(orig);

                return jQuery.isNaN(ret) ? orig : ret;

                // Set the width or height on the element (default to pixels if value is unitless)
            } else {
                return this.css(type, typeof size === "string" ? size : size + "px");
            }
        };

    });


    // Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;

    // @PATCH
    window.$.rebindWindowContext = function (win) {
        window = win;
        document = win.document;
        rootjQuery = $(document);
        return function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context, rootjQuery);
        }
    };

    var getText = function (elems) {
        var ret = "", elem;

        for (var i = 0; elems[i]; i++) {
            elem = elems[i];

            // Get the text from text nodes and CDATA nodes
            if (elem.nodeType === 3 || elem.nodeType === 4) {
                ret += elem.nodeValue;

                // Traverse everything else, except comment nodes
            } else if (elem.nodeType !== 8) {
                ret += getText(elem.childNodes);
            }
        }

        return ret;
    };

    jQuery.expr[':'].textEquals = function(el, i, m) {
        var searchText = m[3];

        return getText([el]).replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '') === searchText;
    }
})(window);
jQuery.fn.center = function () {
    this.css("position","absolute");
    this.css("top", Math.max(0, (($(window).height() - this.outerHeight()) / 2) + 
                                                $(window).scrollTop()) + "px");
    this.css("left", Math.max(0, (($(window).width() - this.outerWidth()) / 2) + 
                                                $(window).scrollLeft()) + "px");
    return this;
}


;
/*!
 * deep-diff.
 * Licensed under the MIT License.
 *
 * NOTE: Patched to handle Date objects from different frames (replaced all instanceof checks)
 */
// jshint ignore: start
if (Object.create) {
    ;(function (root, factory) {
        'use strict';
        if (typeof define === 'function' && define.amd) {
            // AMD. Register as an anonymous module.
            define([], factory);
        } else if (typeof exports === 'object') {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like environments that support module.exports,
            // like Node.
            module.exports = factory();
        } else {
            // Browser globals (root is window)
            root.DeepDiff = factory();
        }
    }(this, function (undefined) {
        'use strict';

        var $scope, conflict, conflictResolution = [];
        if (typeof global === 'object' && global) {
            $scope = global;
        } else if (typeof window !== 'undefined') {
            $scope = window;
        } else {
            $scope = {};
        }
        conflict = $scope.DeepDiff;
        if (conflict) {
            conflictResolution.push(
                function () {
                    if ('undefined' !== typeof conflict && $scope.DeepDiff === accumulateDiff) {
                        $scope.DeepDiff = conflict;
                        conflict        = undefined;
                    }
                });
        }

        // nodejs compatible on server side and in the browser.
        function inherits(ctor, superCtor) {
            ctor.super_    = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor : {
                    value        : ctor,
                    enumerable   : false,
                    writable     : true,
                    configurable : true
                }
            });
        }

        function Diff(kind, path) {
            Object.defineProperty(this, 'kind', {
                value      : kind,
                enumerable : true
            });
            if (path && path.length) {
                Object.defineProperty(this, 'path', {
                    value      : path,
                    enumerable : true
                });
            }
        }

        function DiffEdit(path, origin, value) {
            DiffEdit.super_.call(this, 'E', path);
            Object.defineProperty(this, 'lhs', {
                value      : origin,
                enumerable : true
            });
            Object.defineProperty(this, 'rhs', {
                value      : value,
                enumerable : true
            });
        }

        inherits(DiffEdit, Diff);

        function DiffNew(path, value) {
            DiffNew.super_.call(this, 'N', path);
            Object.defineProperty(this, 'rhs', {
                value      : value,
                enumerable : true
            });
        }

        inherits(DiffNew, Diff);

        function DiffDeleted(path, value) {
            DiffDeleted.super_.call(this, 'D', path);
            Object.defineProperty(this, 'lhs', {
                value      : value,
                enumerable : true
            });
        }

        inherits(DiffDeleted, Diff);

        function DiffArray(path, index, item) {
            DiffArray.super_.call(this, 'A', path);
            Object.defineProperty(this, 'index', {
                value      : index,
                enumerable : true
            });
            Object.defineProperty(this, 'item', {
                value      : item,
                enumerable : true
            });
        }

        inherits(DiffArray, Diff);

        function arrayRemove(arr, from, to) {
            var rest   = arr.slice((to || from) + 1 || arr.length);
            arr.length = from < 0 ? arr.length + from : from;
            arr.push.apply(arr, rest);
            return arr;
        }

        function realTypeOf(subject) {
            var type = typeof subject;
            if (type !== 'object') {
                return type;
            }

            if (subject === Math) {
                return 'math';
            } else if (subject === null) {
                return 'null';
            } else if (Array.isArray(subject)) {
                return 'array';
            } else if (Object.prototype.toString.call(subject) === '[object Date]') {
                return 'date';
            } else if (/^\/.*\//.test(subject.toString())) {
                return 'regexp';
            }
            return 'object';
        }

        function deepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
            path            = path || [];
            var currentPath = path.slice(0);
            if (typeof key !== 'undefined') {
                if (prefilter && prefilter(currentPath, key, { lhs : lhs, rhs : rhs })) {
                    return;
                }
                currentPath.push(key);
            }

            // Use string comparison for regexes
            if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
                lhs = lhs.toString();
                rhs = rhs.toString();
            }

            var ltype = typeof lhs;
            var rtype = typeof rhs;
            if (ltype === 'undefined') {
                if (rtype !== 'undefined') {
                    changes(new DiffNew(currentPath, rhs));
                }
            } else if (rtype === 'undefined') {
                changes(new DiffDeleted(currentPath, lhs));
            } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
                changes(new DiffEdit(currentPath, lhs, rhs));
            } else if (Object.prototype.toString.call(lhs) === '[object Date]' && Object.prototype.toString.call(rhs) === '[object Date]' && ((lhs - rhs) !== 0)) {
                changes(new DiffEdit(currentPath, lhs, rhs));
            } else if (ltype === 'object' && lhs !== null && rhs !== null) {
                stack = stack || [];
                if (stack.indexOf(lhs) < 0) {
                    stack.push(lhs);
                    if (Array.isArray(lhs)) {
                        var i, len = lhs.length;
                        for (i = 0; i < lhs.length; i++) {
                            if (i >= rhs.length) {
                                changes(new DiffArray(currentPath, i, new DiffDeleted(undefined, lhs[i])));
                            } else {
                                deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack);
                            }
                        }
                        while (i < rhs.length) {
                            changes(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i++])));
                        }
                    } else {
                        var akeys = Object.keys(lhs);
                        var pkeys = Object.keys(rhs);
                        akeys.forEach(function (k, i) {
                            var other = pkeys.indexOf(k);
                            if (other >= 0) {
                                deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack);
                                pkeys = arrayRemove(pkeys, other);
                            } else {
                                deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack);
                            }
                        });
                        pkeys.forEach(function (k) {
                            deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack);
                        });
                    }
                    stack.length = stack.length - 1;
                }
            } else if (lhs !== rhs) {
                if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
                    changes(new DiffEdit(currentPath, lhs, rhs));
                }
            }
        }

        function accumulateDiff(lhs, rhs, prefilter, accum) {
            accum = accum || [];
            deepDiff(lhs, rhs,
                function (diff) {
                    if (diff) {
                        accum.push(diff);
                    }
                },
                prefilter);
            return (accum.length) ? accum : undefined;
        }

        function applyArrayChange(arr, index, change) {
            if (change.path && change.path.length) {
                var it   = arr[index],
                    i, u = change.path.length - 1;
                for (i = 0; i < u; i++) {
                    it = it[change.path[i]];
                }
                switch (change.kind) {
                    case 'A':
                        applyArrayChange(it[change.path[i]], change.index, change.item);
                        break;
                    case 'D':
                        delete it[change.path[i]];
                        break;
                    case 'E':
                    case 'N':
                        it[change.path[i]] = change.rhs;
                        break;
                }
            } else {
                switch (change.kind) {
                    case 'A':
                        applyArrayChange(arr[index], change.index, change.item);
                        break;
                    case 'D':
                        arr = arrayRemove(arr, index);
                        break;
                    case 'E':
                    case 'N':
                        arr[index] = change.rhs;
                        break;
                }
            }
            return arr;
        }

        function applyChange(target, source, change) {
            if (target && source && change && change.kind) {
                var it   = target,
                    i    = -1,
                    last = change.path ? change.path.length - 1 : 0;
                while (++i < last) {
                    if (typeof it[change.path[i]] === 'undefined') {
                        it[change.path[i]] = (typeof change.path[i] === 'number') ? [] : {};
                    }
                    it = it[change.path[i]];
                }
                switch (change.kind) {
                    case 'A':
                        applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
                        break;
                    case 'D':
                        delete it[change.path[i]];
                        break;
                    case 'E':
                    case 'N':
                        it[change.path[i]] = change.rhs;
                        break;
                }
            }
        }

        function revertArrayChange(arr, index, change) {
            if (change.path && change.path.length) {
                // the structure of the object at the index has changed...
                var it   = arr[index],
                    i, u = change.path.length - 1;
                for (i = 0; i < u; i++) {
                    it = it[change.path[i]];
                }
                switch (change.kind) {
                    case 'A':
                        revertArrayChange(it[change.path[i]], change.index, change.item);
                        break;
                    case 'D':
                        it[change.path[i]] = change.lhs;
                        break;
                    case 'E':
                        it[change.path[i]] = change.lhs;
                        break;
                    case 'N':
                        delete it[change.path[i]];
                        break;
                }
            } else {
                // the array item is different...
                switch (change.kind) {
                    case 'A':
                        revertArrayChange(arr[index], change.index, change.item);
                        break;
                    case 'D':
                        arr[index] = change.lhs;
                        break;
                    case 'E':
                        arr[index] = change.lhs;
                        break;
                    case 'N':
                        arr = arrayRemove(arr, index);
                        break;
                }
            }
            return arr;
        }

        function revertChange(target, source, change) {
            if (target && source && change && change.kind) {
                var it = target,
                    i, u;
                u      = change.path.length - 1;
                for (i = 0; i < u; i++) {
                    if (typeof it[change.path[i]] === 'undefined') {
                        it[change.path[i]] = {};
                    }
                    it = it[change.path[i]];
                }
                switch (change.kind) {
                    case 'A':
                        // Array was modified...
                        // it will be an array...
                        revertArrayChange(it[change.path[i]], change.index, change.item);
                        break;
                    case 'D':
                        // Item was deleted...
                        it[change.path[i]] = change.lhs;
                        break;
                    case 'E':
                        // Item was edited...
                        it[change.path[i]] = change.lhs;
                        break;
                    case 'N':
                        // Item is new...
                        delete it[change.path[i]];
                        break;
                }
            }
        }

        function applyDiff(target, source, filter) {
            if (target && source) {
                var onChange = function (change) {
                    if (!filter || filter(target, source, change)) {
                        applyChange(target, source, change);
                    }
                };
                deepDiff(target, source, onChange);
            }
        }

        Object.defineProperties(accumulateDiff, {

            diff           : {
                value      : accumulateDiff,
                enumerable : true
            },
            observableDiff : {
                value      : deepDiff,
                enumerable : true
            },
            applyDiff      : {
                value      : applyDiff,
                enumerable : true
            },
            applyChange    : {
                value      : applyChange,
                enumerable : true
            },
            revertChange   : {
                value      : revertChange,
                enumerable : true
            },
            isConflict     : {
                value      : function () {
                    return 'undefined' !== typeof conflict;
                },
                enumerable : true
            },
            noConflict     : {
                value      : function () {
                    if (conflictResolution) {
                        conflictResolution.forEach(function (it) {
                            it();
                        });
                        conflictResolution = null;
                    }
                    return accumulateDiff;
                },
                enumerable : true
            }
        });

        return accumulateDiff;
    }));
}
;
/*
 * jQuery scrollintoview() plugin and :scrollable selector filter
 *
 * Version 1.8 (14 Jul 2011)
 * Requires jQuery 1.4 or newer
 *
 * Copyright (c) 2011 Robert Koritnik
 * Licensed under the terms of the MIT license
 * http://www.opensource.org/licenses/mit-license.php
 */
(function(f){var c={vertical:{x:false,y:true},horizontal:{x:true,y:false},both:{x:true,y:true},x:{x:true,y:false},y:{x:false,y:true}};var b={duration:"fast",direction:"both"};var e=/^(?:html)$/i;var g=function(k,j){j=j||(document.defaultView&&document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(k,null):k.currentStyle);var i=document.defaultView&&document.defaultView.getComputedStyle?true:false;var h={top:(parseFloat(i?j.borderTopWidth:f.css(k,"borderTopWidth"))||0),left:(parseFloat(i?j.borderLeftWidth:f.css(k,"borderLeftWidth"))||0),bottom:(parseFloat(i?j.borderBottomWidth:f.css(k,"borderBottomWidth"))||0),right:(parseFloat(i?j.borderRightWidth:f.css(k,"borderRightWidth"))||0)};return{top:h.top,left:h.left,bottom:h.bottom,right:h.right,vertical:h.top+h.bottom,horizontal:h.left+h.right}};var d=function(h){var j=f(window);var i=e.test(h[0].nodeName);return{border:i?{top:0,left:0,bottom:0,right:0}:g(h[0]),scroll:{top:(i?j:h).scrollTop(),left:(i?j:h).scrollLeft()},scrollbar:{right:i?0:h.innerWidth()-h[0].clientWidth,bottom:i?0:h.innerHeight()-h[0].clientHeight},rect:(function(){var k=h[0].getBoundingClientRect();return{top:i?0:k.top,left:i?0:k.left,bottom:i?h[0].clientHeight:k.bottom,right:i?h[0].clientWidth:k.right}})()}};f.fn.extend({scrollintoview:function(j){j=f.extend({},b,j);j.direction=c[typeof(j.direction)==="string"&&j.direction.toLowerCase()]||c.both;var n="";if(j.direction.x===true){n="horizontal"}if(j.direction.y===true){n=n?"both":"vertical"}var l=this.eq(0);var i=l.closest(":scrollable("+n+")");if(i.length>0){i=i.eq(0);var m={e:d(l),s:d(i)};var h={top:m.e.rect.top-(m.s.rect.top+m.s.border.top),bottom:m.s.rect.bottom-m.s.border.bottom-m.s.scrollbar.bottom-m.e.rect.bottom,left:m.e.rect.left-(m.s.rect.left+m.s.border.left),right:m.s.rect.right-m.s.border.right-m.s.scrollbar.right-m.e.rect.right};var k={};if(j.direction.y===true){if(h.top<0){k.scrollTop=m.s.scroll.top+h.top}else{if(h.top>0&&h.bottom<0){k.scrollTop=m.s.scroll.top+Math.min(h.top,-h.bottom)}}}if(j.direction.x===true){if(h.left<0){k.scrollLeft=m.s.scroll.left+h.left}else{if(h.left>0&&h.right<0){k.scrollLeft=m.s.scroll.left+Math.min(h.left,-h.right)}}}if(!f.isEmptyObject(k)){if(e.test(i[0].nodeName)){i=f("html,body")}i.animate(k,j.duration).eq(0).queue(function(o){f.isFunction(j.complete)&&j.complete.call(i[0]);o()})}else{f.isFunction(j.complete)&&j.complete.call(i[0])}}return this}});var a={auto:true,scroll:true,visible:false,hidden:false};f.extend(f.expr[":"],{scrollable:function(k,i,n,h){var m=c[typeof(n[3])==="string"&&n[3].toLowerCase()]||c.both;var l=(document.defaultView&&document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(k,null):k.currentStyle);var o={x:a[l.overflowX.toLowerCase()]||false,y:a[l.overflowY.toLowerCase()]||false,isRoot:e.test(k.nodeName)};if(!o.x&&!o.y&&!o.isRoot){return false}var j={height:{scroll:k.scrollHeight,client:k.clientHeight},width:{scroll:k.scrollWidth,client:k.clientWidth},scrollableX:function(){return(o.x||o.isRoot)&&this.width.scroll>this.width.client},scrollableY:function(){return(o.y||o.isRoot)&&this.height.scroll>this.height.client}};return m.y&&j.scrollableY()||m.x&&j.scrollableX()}})})(jQuery);;
if (typeof JooseX != "undefined" && !JooseX.SimpleRequest) {;
Class("JooseX.SimpleRequest", {

    have : {
    	req : null
	},

    
    methods: {
    	
        initialize: function () {
            if (window.XMLHttpRequest)
                this.req = new XMLHttpRequest()
            else
                this.req = new ActiveXObject("Microsoft.XMLHTTP")
        },
        
        
        getText: function (urlOrOptions, async, callback, scope) {
            var req = this.req
            
            var headers
            var url
            
            if (typeof urlOrOptions != 'string') {
                headers = urlOrOptions.headers
                url = urlOrOptions.url
                async = async || urlOrOptions.async
                callback = callback || urlOrOptions.callback
                scope = scope || urlOrOptions.scope
            } else url = urlOrOptions
            
            req.open('GET', url, async || false)
            
            if (headers) Joose.O.eachOwn(headers, function (value, name) {
                req.setRequestHeader(name, value)
            })
            
            try {
                req.onreadystatechange = function (event) {  
                    if (async && req.readyState == 4) {  
                        // status is set to 0 for failed cross-domain requests..
                        // but if the response text presents - we treat this as successfull request
                        // see https://www.assembla.com/spaces/bryntum/tickets/590
                        if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                            callback.call(scope || this, true, req.responseText)
                        else 
                            callback.call(scope || this, false, "File not found: " + url)
                    }  
                };  
                req.send(null)
            } catch (e) {
                throw "File not found: " + url
            }
            
            if (!async)
                if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                    return req.responseText; 
                else 
                    throw "File not found: " + url
            
            return null
        }
    }
})
;
};
/**
@class Siesta.Test.Action.Role.HasTarget

This is a mixin, allowing the action to have "target" attribute, also aliased as "el". Target will be also passed
further on chain, as the argument after "next":

    t.chain(
        {
            action      : 'click',
            target      : buttonComp        
        },
        function (next, buttonComp) {
            // target is available as 2nd argument
        
            next()
        },
        {
            action      : 'click',
            target      : '>>button',
            offset      : [10, 20]
        },
        function (next, buttonComp) {
            // various queries will be resolved down to Ext.Component instance or DOM element
        
            next()
        },
        ...
    )
    
If needed, this behavior can be disabled with {@link #passTargetToNext} option.

*/
Role('Siesta.Test.Action.Role.HasTarget', {
    
        
    has : {
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} [target=undefined] 
         * 
         * A target for action. See {@link Siesta.Test.ActionTarget} for various values that can be provided.
         * 
         * **Important.** If the function is provided for this config, it will be called and returning value used as actual target. 
         * This is useful, since sometimes target for the action depends from the previous step and 
         * is not yet available during `t.chain` call. 
         * 
         * For example, you want to click on the button which opens a window and then click on something in the window. Compare:
         * 

    t.chain(
        // clicking on button opens the window
        {
            action      : 'click',
            target      : buttonComp        
        },
        // FRAGILE: `windowComp` could not be rendered yet - `buttonComp` is not yet clicked!
        {
            action      : 'click',
            target      : windowComp.el.down('.clickArea')  
        }
        
        // MORE ROBUST: taking the "el" right before this action starts
        {
            action      : 'click',
            target      : function () {
                return windowComp.el.down('.clickArea')
            } 
        }
    )
         * 
         * Target will be available in the next step as the 2nd argument. See {@link Siesta.Test.Action.Role.HasTarget}
         * 
         * This config option can also be provided as "el" 
         */
        target              : { required : false },

        normalizedTarget    : null,
        cachedTarget        : null,
        
        /**
         * @cfg {Object} el 
         * 
         * An alias for {@link #target} 
         */
        
        /**
         * @cfg {Boolean} passTargetToNext Whether to pass the target further on chain as the first argument
         */
        passTargetToNext    : true,


        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        options             : null,

        /**
         * @cfg {Array} offset
         *
         * An offset in X, Y coordinates from the targeted element. The offset can be expressed in 3 different ways.
         * Integers             : [10, 20]       // offset 10px from left, 20px from top
         * Percent              : ["10%", 20]    // offset 10% from left, 20px from top
         * Percent + offset     : ["100%-2", 20] // offset -2px from right, 20px from top
         */
        offset              : null,

        waitForTarget       : true
    },
    
    
    after : {
        initialize : function () {
            if (!this.passTargetToNext) return
            
            var me          = this
            var prevNext    = this.next

            this.next       = function () {
                prevNext.call(this, me.normalizedTarget);
            }
        }
    },

    
    methods : {
        
        BUILD : function (config) {
            // allow "el" as synonym for "target"
            if (config.el && !config.target) config.target = config.el
            
            return config
        },
        

        getTarget : function () {
            if (this.cachedTarget) return this.cachedTarget
            
            var test        = this.test;
            var target      = this.target || test.currentPosition;

            if (test.typeOf(target) === 'Function') target = target.call(test, this);
            
            this.normalizedTarget   = test.normalizeActionTarget(target, true)

            return this.cachedTarget   = target
        }
    }
});
;
/**

@class Siesta.Test.Action.Swipe
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "swipe" shortcut:

    t.chain(
        {
            action      : 'swipe',
            target      : someDOMElement
        },
        // or
        {
            swipe       : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.SenchaTouch#swipe swipe} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Swipe', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod          : 'swipe',
         
        /**
         * @cfg {String} direction Either 'left', 'right', 'up' or 'down'
         */
        direction                  : 'left'
    },

    
    methods : {
        
        process : function () {
            this.test.swipe(this.getTarget(), this.direction, this.next)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('swipe', Siesta.Test.Action.Swipe)
;
/**

@class Siesta.Test.Action.Pinch
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "swipe" shortcut:

    t.chain(
        {
            action      : 'swipe',
            target      : someDOMElement
        },
        // or
        {
            swipe       : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.SenchaTouch#swipe swipe} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Pinch', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod          : 'pinch',
         
        /**
         * @cfg {String} scale The scale for the pinch operation
         */
        scale                       : 2,
        
        target2                     : null,
        offset2                     : null,
        
        cachedTarget2               : null
    },

    
    methods : {
        
        process : function () {
            this.test.pinch(this.getTarget(), this.getTarget2(), this.scale, this.next, null, this.options, this.offset, this.offset2)
        },
        
        
        getTarget2 : function () {
            if (this.cachedTarget2) return this.cachedTarget2
            
            var test        = this.test;
            var target2     = this.target2

            if (test.typeOf(target2) === 'Function') target2 = target2.call(test, this);
            
            return this.cachedTarget2   = target2
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('pinch', Siesta.Test.Action.Pinch)
;
/**

@class Siesta.Test.Action.LongPress
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "click" shortcut:

    t.chain(
        {
            action      : 'longpress',
            target      : someDOMElement
        },
        // or
        {
            longpress   : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.SenchaTouch#longpress longpress} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.LongPress', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'longPress'
    },

    
    methods : {
        
        process : function () {
            this.test.longpress(this.getTarget(), this.next, null, this.options, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('longpress', Siesta.Test.Action.LongPress)
;
/**

@class Siesta.Test.Action.Tap
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "tap" shortcut:

    t.chain(
        {
            action      : 'tap',
            target      : someDOMElement
        },
        // or
        {
            tap         : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.Browser#tap tap} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Tap', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'tap'
    },

    
    methods : {
        
        process : function () {
            this.test.tap(this.getTarget(), this.next, null, this.options, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('tap', Siesta.Test.Action.Tap);
/**

@class Siesta.Test.Action.DoubleTap
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#doubleClick double tap} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "doubletap" or "doubleTap" shortcuts:

    t.chain(
        {
            action      : 'doubletap',
            target      : someDOMElement
        },
        // or
        {
            doubletap   : someDOMElement,
            offset      : [20,20] // click 20px from the left/top corner of the element
        }
    )


*/
Class('Siesta.Test.Action.DoubleTap', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'doubleTap'
    },

    
    methods : {
        
        process : function () {
            this.test.doubleTap(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('doubletap', Siesta.Test.Action.DoubleTap)
;
/**

@class Siesta.Test.Action.TouchDrag
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with the "touchDrag" shortcut:

    t.chain(
        {
            action      : 'touchDrag',
            target      : someDOMElementOrArray,
            to          : someDOMElementOrArray
        },
        {
            action      : 'touchDrag',
            target      : someDOMElementOrArray,
            by          : [ 10, 10 ]
        },
        // or
        {
            touchDrag   : someDOMElementOrArray,
            to          : someDOMElementOrArray
        }
    )

This action will perform a {@link Siesta.Test.Browser#dragTo dragTo} or {@link Siesta.Test.Browser#dragBy dragBy} actions on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.TouchDrag', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
    
    has : {
        requiredTestMethod  : 'touchDragTo',
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} target
         * 
         * The initial point of dragging operation. Can be provided as Siesta.Test.ActionTarget or the function returning it. 
         * Will also be passed further to the next step.
         */
         
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} source
         * 
         * Alias for {@link #target}. This may sound confusing, but "target" of "drag" action is its "source" in the same time.   
         */
         
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} to 
         * 
         * The target point of dragging operation. Can be provided as the DOM element, the array with screen coordinates: `[ x, y ]`, or the function
         * returning one of those.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        to                  : null,

        /**
         * @cfg {Array} fromOffset
         *
         * An offset in X, Y coordinates from the source element. Can be also specified as `offset` config.
         */
        fromOffset          : null,

        /**
         * @cfg {Array} toOffset
         *
         * An offset in X, Y coordinates from the targeted element
         */
        toOffset            : null,

        /**
         * @cfg {Array/Function} by 
         * 
         * The delta for dragging operation. Should be provided as the array with delta value for each coordinate: `[ dX, dY ]` or the function returning such.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        by                  : null,
        
        
        /**
         * @cfg {Boolean} dragOnly
         * 
         * True to skip the mouseup and not finish the drop operation (one can start another drag operation, emulating the pause during drag-n-drop).
         */
        dragOnly            : false,

        byOrToMissingText   : 'Either "to" or "by" configuration option is required for "drag" step',
        byAndToDefinedText  : 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
    },

    
    override : {
        BUILD : function (config) {
            // allow "source" as synonym for "target"
            // sounds weird, but "target" in action domain means source point for dragging 
            if (config.source && !config.target) config.target = config.source
            
            return this.SUPER(config)
        }
    },
    
    
    methods : {
        
        initialize : function () {
            this.SUPER()
            
            if (!this.to && !this.by)   throw this.byOrToMissingText
            if (this.to && this.by)     throw this.byAndToDefinedText
        },
        
        
        getTo : function () {
            if (this.test.typeOf(this.to) == 'Function')
                return this.to.call(this.test, this)
            else
                return this.to
        },
        
        
        getBy : function () {
            if (this.test.typeOf(this.by) == 'Function')
                return this.by.call(this.test, this)
            else
                return this.by
        },

        
        process : function () {
            var next                = this.next;
            var test                = this.test
            var target              = this.getTarget();
            var normalizedTarget    = test.normalizeActionTarget(target, true)
            
            if (this.to) {
                test.touchDragTo(target, this.getTo(), function() { next(normalizedTarget || test.normalizeActionTarget(target)); }, null, this.options, this.dragOnly, this.fromOffset || this.offset, this.toOffset)
            } else {
                test.touchDragBy(target, this.getBy(), function() { next(normalizedTarget || test.normalizeActionTarget(target)); }, null, this.options, this.dragOnly, this.fromOffset || this.offset)
            }
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('touchdrag', Siesta.Test.Action.TouchDrag);
/**

@class Siesta.Test.Action.MouseDown
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in a `t.chain` call with "mouseDown" shortcut:

    t.chain(
        {
            action      : 'mouseDown',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            mousedown   : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#MouseDown MouseDown} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.MouseDown', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'mouseDown'
    },

    
    methods : {
        
        process : function () {
            // This method is synchronous
            this.test.mouseDown(this.getTarget(), this.options, this.offset, this.next, this, this.waitForTarget);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('mouseDown', Siesta.Test.Action.MouseDown)
Siesta.Test.ActionRegistry().registerAction('fingerDown', Siesta.Test.Action.MouseDown)
;
/**

@class Siesta.Test.Action.MouseUp
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in a `t.chain` call with "mouseUp" shortcut:

    t.chain(
        {
            action      : 'mouseUp',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            mouseup     : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#mouseUp mouseUp} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.MouseUp', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'mouseUp'
    },

    
    methods : {
        
        process : function () {
            // This method is synchronous
            this.test.mouseUp(this.getTarget(), this.options, this.offset);

            this.next()
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('mouseUp', Siesta.Test.Action.MouseUp)
Siesta.Test.ActionRegistry().registerAction('fingerUp', Siesta.Test.Action.MouseUp)
;
/**

@class Siesta.Test.Action.Click
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "click" shortcut:

    t.chain(
        {
            action      : 'click',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            click       : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#click click} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Click', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'click'
    },

    methods : {
        
        process : function () {
            this.test.click(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('click', Siesta.Test.Action.Click);
;
/**

@class Siesta.Test.Action.DoubleClick
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#doubleClick double click} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "doubleclick" or "doubleClick" shortcuts:

    t.chain(
        {
            action      : 'doubleclick',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            doubleclick : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
        
    )


*/
Class('Siesta.Test.Action.DoubleClick', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'doubleClick'
    },

    
    methods : {
        
        process : function () {
            this.test.doubleClick(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('doubleclick', Siesta.Test.Action.DoubleClick)
Siesta.Test.ActionRegistry().registerAction('dblclick', Siesta.Test.Action.DoubleClick)
;
/**

@class Siesta.Test.Action.RightClick
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#rightClick right click} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "rightclick" or "rightClick" shortcuts:

    t.chain(
        {
            action      : 'rightclick',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            rightclick  : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )


*/
Class('Siesta.Test.Action.RightClick', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'rightClick'
    },

    
    methods : {
        
        process : function () {
            this.test.rightClick(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('rightclick', Siesta.Test.Action.RightClick)
Siesta.Test.ActionRegistry().registerAction('contextmenu', Siesta.Test.Action.RightClick);
/**

@class Siesta.Test.Action.Type
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will {@link Siesta.Test.Browser#type type} the provided {@link #text} into the provided {@link #target}. For more
 information about how you can type special characters and hold special keys such as ALT or SHIFT, please see the docs for the {@link Siesta.Test.Browser#type type} method.
 The target can be a DOM element or, in case you are using the Siesta.Test.ExtJS class - an instance of a Ext.Component (field component for example).

This action can be included in a `t.chain` call with the "type" shortcut. **Note** that unlike other actions, in its compact
form the value of the "type" property should contain the text to type, not the target of action.

    t.chain(
         {
             // "type" into the currently focused DOM element
             type        : 'Some text[ENTER]'
         },
         // or
         {
             action      : 'type',
             target      : someDOMElement,
             text        : 'Some text',
             options     : { shiftKey : true }
         },
         // or
         {
            // NOTE: "type" contains text to type, not the action target as in other actions
            type        : 'Some text',
            target      : someDOMElement
         }
    );

*/
Class('Siesta.Test.Action.Type', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'type',

        /**
         * @cfg {String} text
         *
         * The text to type into the target
         */
        text                : '',

        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        options             : null,

        /**
         * @cfg {String} clearExisting
         *
         *  true to clear existing text in the target before typing
         */
        clearExisting       : false
    },


    methods : {

        process : function () {
            var waitForTarget = this.waitForTarget || !!this.target;

            // By default use the current focused element as target
            this.target = this.target || this.test.activeElement();

            // additional "getTarget" to allow functions as "target" value
            this.test.type(this.getTarget(), this.text, this.next, null, this.options, this.clearExisting, waitForTarget);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('type', Siesta.Test.Action.Type);
/**

@class Siesta.Test.Action.Drag
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with the "drag" shortcut:

    t.chain(
        {
            action      : 'drag',
            target      : someDOMElementOrArray,
            to          : someDOMElementOrArray
        },
        {
            action      : 'drag',
            target      : someDOMElementOrArray,
            by          : [ 10, 10 ]
        },
        // or
        {
            drag        : someDOMElementOrArray,
            to          : someDOMElementOrArray
        }
    )

This action will perform a {@link Siesta.Test.Browser#dragTo dragTo} or {@link Siesta.Test.Browser#dragBy dragBy} actions on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Drag', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
    
    has : {
        requiredTestMethod  : 'dragTo',
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} target
         * 
         * The initial point of dragging operation. Can be provided as Siesta.Test.ActionTarget or the function returning it. 
         * Will also be passed further to the next step.
         */
         
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} source
         * 
         * Alias for {@link #target}. This may sound confusing, but "target" of "drag" action is its "source" in the same time.   
         */
         
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} to 
         * 
         * The target point of dragging operation. Can be provided as the DOM element, the array with screen coordinates: `[ x, y ]`, or the function
         * returning one of those.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        to                  : null,

        /**
         * @cfg {Array} fromOffset
         *
         * An offset in X, Y coordinates from the source element. Can be also specified as `offset` config.
         */
        fromOffset          : null,

        /**
         * @cfg {Array} toOffset
         *
         * An offset in X, Y coordinates from the targeted element
         */
        toOffset            : null,

        /**
         * @cfg {Array/Function} by 
         * 
         * The delta for dragging operation. Should be provided as the array with delta value for each coordinate: `[ dX, dY ]` or the function returning such.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        by                  : null,
        
        
        /**
         * @cfg {Boolean} dragOnly
         * 
         * True to skip the mouseup and not finish the drop operation (one can start another drag operation, emulating the pause during drag-n-drop).
         */
        dragOnly            : false,

        byOrToMissingText   : 'Either "to" or "by" configuration option is required for "drag" step',
        byAndToDefinedText  : 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
    },

    
    override : {
        BUILD : function (config) {
            // allow "source" as synonym for "target"
            // sounds weird, but "target" in action domain means source point for dragging 
            if (config.source && !config.target) config.target = config.source
            
            return this.SUPER(config)
        }
    },
    
    
    methods : {
        
        initialize : function () {
            this.SUPER()
            
            if (!this.to && !this.by)   throw this.byOrToMissingText
            if (this.to && this.by)     throw this.byAndToDefinedText
        },
        
        
        getTo : function () {
            if (this.test.typeOf(this.to) == 'Function')
                return this.to.call(this.test, this)
            else
                return this.to
        },
        
        
        getBy : function () {
            if (this.test.typeOf(this.by) == 'Function')
                return this.by.call(this.test, this)
            else
                return this.by
        },

        
        process : function () {
            var next                = this.next;
            var test                = this.test
            var target              = this.getTarget();
            var normalizedTarget    = test.normalizeActionTarget(target, true)
            
            if (this.to) {
                test.dragTo(target, this.getTo(), function() { next(normalizedTarget || test.normalizeActionTarget(target, true)); }, null, this.options, this.dragOnly, this.fromOffset || this.offset, this.toOffset, this.waitForTarget)
            } else {
                test.dragBy(target, this.getBy(), function() { next(normalizedTarget || test.normalizeActionTarget(target, true)); }, null, this.options, this.dragOnly, this.fromOffset || this.offset, this.waitForTarget)
            }
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('drag', Siesta.Test.Action.Drag);
/**

@class Siesta.Test.Action.MonkeyTest
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in a `t.chain` call with "monkeyTest" shortcut:

    t.chain(
        { monkeyTest   : '.someSelector' }
    )

This action will perform a {@link Siesta.Test.Browser#MouseDown MouseDown} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.MonkeyTest', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'monkeyTest',
        
        nbrInteractions     : 10,
        
        hasOwnAsyncFrame    : true
    },

    
    methods : {
        
        process : function () {
            this.test.monkeyTest(this.getTarget(), this.nbrInteractions, this.next);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('monkeyTest', Siesta.Test.Action.MonkeyTest)
Siesta.Test.ActionRegistry().registerAction('monkey', Siesta.Test.Action.MonkeyTest)
;
/**

@class Siesta.Test.Action.MoveCursor
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "moveCursor" shortcut:

    t.chain(
        {
            action      : 'moveCursor',
            to          : 'div.someClass'   // A div with class='someClass'
        },
        {
            action      : 'moveCursor',
            to          : [400, 300]        // Target pixel coordinates
        },
        {
            action      : 'moveCursor',
            by          : [20, 10]  // 20 px right, 10 px down
        }
    )

This action will perform a {@link Siesta.Test.Simulate.Mouse#moveCursorTo moveCursorTo} to the provided 'to' destination or the relative 'by' offset.

*/
Class('Siesta.Test.Action.MoveCursor', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        requiredTestMethod  : 'moveMouseTo',
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} to 
         * 
         * The target point the cursor should be moved to. Can be provided as a DOM element, an array with client coordinates: `[ x, y ]`, or a function
         * returning one of those. You can additionally pass an 'offset' array to click at a point relative to the XY position of the target.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        to                  : null,
        
        
        /**
         * @cfg {Array/Function} by 
         * 
         * The delta for moving cursor. Should be provided as the array with delta value for each coordinate: `[ dX, dY ]` or the function returning such.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        by                  : null,

        /**
         * @cfg {Array} offset
         *
         * An offset in X, Y coordinates from the targeted element (only applicable when using the 'to' target option.
         */
        offset : null
    },

    
    methods : {
        getTo : function () {
            if (this.test.typeOf(this.to) == 'Function')
                return this.to.call(this.test, this)
            else
                return this.to
        },
        
        
        getBy : function () {
            if (this.test.typeOf(this.by) == 'Function')
                return this.by.call(this.test, this)
            else
                return this.by
        },

        process : function () {
            var test = this.test;
            var next = this.next;

            if (this.to) {
                var to                  = this.getTo()
                
                var normalizedTarget    = test.normalizeActionTarget(to, false)
                
                test.moveMouseTo(to, function() { next(normalizedTarget); }, null, this.offset)
            } else {
                var by                  = this.getBy()
                var currentXY           = test.currentPosition
                
                var normalizedTarget    = test.normalizeActionTarget([ currentXY[ 0 ] + by[ 0 ], currentXY[ 1 ] + by[ 1 ] ]);

                test.moveMouseBy(by, function() { next(normalizedTarget); })
            }
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('moveCursor', Siesta.Test.Action.MoveCursor)
Siesta.Test.ActionRegistry().registerAction('moveMouse', Siesta.Test.Action.MoveCursor)
Siesta.Test.ActionRegistry().registerAction('moveFinger', Siesta.Test.Action.MoveCursor)
;
/**

@class Siesta.Test.Action.MoveCursorTo
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "moveCursorTo" shortcut:

    t.chain(
        {
            action          : 'moveCursorTo',
            target          : someDOMElement
        },
        // or
        {
            moveCursorTo    : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.Simulate.Mouse#moveCursorTo moveCursorTo} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.MoveCursorTo', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'moveMouseTo',
        target              : { required : true }
    },

    
    methods : {
        
        process : function () {
            this.test.moveMouseTo(this.getTarget(), this.next, null, this.offset, this.waitForTarget)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('moveCursorTo', Siesta.Test.Action.MoveCursorTo)
Siesta.Test.ActionRegistry().registerAction('moveMouseTo', Siesta.Test.Action.MoveCursorTo)
Siesta.Test.ActionRegistry().registerAction('moveFingerTo', Siesta.Test.Action.MoveCursorTo)
;
/**

@class Siesta.Test.Action.SetUrl
@extends Siesta.Test.Action

Used to set the URL of the test page. The url must be on the same domain as Siesta itself.

    t.chain(
        { setUrl      : 'www.yourdomain.com' }
    )

This action will perform a {@link Siesta.Test.Browser#setUrl setUrl} call using the provided {@link #value}.

*/
Class('Siesta.Test.Action.SetUrl', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {String} The URL to navigate to
         */
        value              : null,
        setUrl             : null,

        requiredTestMethod  : 'setUrl'
    },

    
    methods : {
        
        process : function () {
            var value   = this.setUrl || this.value;
            var test    = this.test;

            test.setUrl(value, this.next);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('setUrl', Siesta.Test.Action.SetUrl);
;
/**

@class Siesta.Test.Action.SetValue
@extends Siesta.Test.Action

Used to set value to an Ext.form.Field (text input, checkbox, radio button etc.) This action can be used in a `t.chain` call with the "setValue" shortcut:

    t.chain(
        {
            setValue    : 'Some text',
            target      : '.textInput'
        }
    )

This action will perform a {@link Siesta.Test.ExtJS#setValue setValue} call on the provided {@link #target}.

*/
Class('Siesta.Test.Action.SetValue', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Ext.Component/String/Function} A component instance or a component query to resolve, or a function, returning such. 
         */
        target              : null,
        
        setValue            : null,
        
        requiredTestMethod  : 'setValue'
    },

    
    methods : {
        
        process : function () {
            var target  = this.target;
            var test    = this.test;

            if (test.typeOf(target) === 'Function') target = target.call(test, this);

            test.setValue(target, this.setValue, this.next, null);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('setValue', Siesta.Test.Action.SetValue);
;
/**
 @class Siesta.Test.Simulate.Mouse

 This is a mixin, providing the mouse events simulation functionality.
 */

//        Copyright (c) 2011 John Resig, http://jquery.com/

//        Permission is hereby granted, free of charge, to any person obtaining
//        a copy of this software and associated documentation files (the
//        "Software"), to deal in the Software without restriction, including
//        without limitation the rights to use, copy, modify, merge, publish,
//        distribute, sublicense, and/or sell copies of the Software, and to
//        permit persons to whom the Software is furnished to do so, subject to
//        the following conditions:

//        The above copyright notice and this permission notice shall be
//        included in all copies or substantial portions of the Software.

//        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
//        LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//        OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
//        WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


Role('Siesta.Test.Simulate.Mouse', {

    requires        : [
        'simulateEvent', 'getSimulateEventsWith', 'normalizeElement', 'isTextInput'
    ],

    has: {
        /**
         * @cfg {Int} dragDelay The delay between individual drag events (mousemove)
         */
        dragDelay                       : 25,

        /**
         *  @cfg {Boolean} moveCursorBetweenPoints True to move the mouse cursor between for example two clicks on 
         *  separate elements (for better visual experience)
         */
        moveCursorBetweenPoints         : true,

        pathBatchSize                   : $.browser.msie ? 10 : 5,
        
        mouseMovePrecision              : 1,
        
        enableUnreachableClickWarning   : true,

        autoScrollElementsIntoView      : true,

        overEls                         : Joose.I.Array,
        
        delayAfterScrollIntoView        : 200,
        
        mouseState                      : 'up'
    },


    after : {
        cleanup : function () {
            this.overEls        = null
        }
    },


    methods: {
        // private
        createMouseEvent: function (type, options, el) {
            var event;
            var global      = this.global

            options         = $.extend({
                bubbles     : !/(ms)?(mouse|pointer)enter/i.test(type) && !/(ms)?(mouse|pointer)leave/i.test(type),
                cancelable  : !/(ms)?(mouse|pointer)move/i.test(type),
                view        : global,
                detail      : 0,

                screenX     : 0,
                screenY     : 0,

                ctrlKey     : false,
                altKey      : false,
                shiftKey    : false,
                metaKey     : false,

                button          : 0,
                relatedTarget   : undefined

            }, options);

            if (!("clientX" in options) || !("clientY" in options)) {
                var center  = this.findCenter(el);

                options     = $.extend({
                    clientX: center[0],
                    clientY: center[1]
                }, options);
            }

            // Not supported in IE
            if ("screenX" in window) {
                options = $.extend(options, {
                    screenX: global.screenX + options.clientX,
                    screenY: global.screenY + options.clientY
                });
            }

            var doc         = el.ownerDocument;

            // use W3C standard when available and allowed by "simulateEventsWith" option
            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                var isPointer   = type.match(/^(ms)?pointer/i)

                event           = doc.createEvent(isPointer ? (isPointer[ 1 ] ? 'MS' : '') + 'PointerEvent' : 'MouseEvents');

                event[ isPointer ? 'initPointerEvent' : 'initMouseEvent' ](
                    type, options.bubbles, options.cancelable, options.view, options.detail,
                    options.screenX, options.screenY, options.clientX, options.clientY,
                    options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,
                    options.button, options.relatedTarget || doc.documentElement,
                    // the following extra args are used in the "initPointerEvent"
                    // offsetX, offsetY
                    null, null,
                    // width, height
                    null, null,
                    // pressure, rotation
                    null, null,
                    // tiltX, tiltY
                    null, null,
                    // pointerId
                    null,
                    // pointerType
                    // NOTE: this has to be set to "mouse" (IE11) or 4 (IE10, 11) because otherwise
                    // ExtJS5 blocks the event
                    // need to investigate what happens in SenchaTouch
                    4,//'mouse',
                    // timestamp, isPrimary
                    null, null
                );


            } else if (doc.createEventObject) {
                event       = doc.createEventObject();

                $.extend(event, options);

                event.button = { 0: 1, 1: 4, 2: 2 }[ event.button ] || event.button;
            }

            // Mouse over is used in some certain edge cases which interfer with this tracking
            if (type !== 'mouseover' && type !== 'mouseout') {
                var elWindow    = doc.defaultView || doc.parentWindow;
                var cursorX     = options.clientX;
                var cursorY     = options.clientY;

                // Potentially we're interacting with an element inside a nested frame, which means the coordinates are local to that frame
                if (elWindow !== global) {
                    var offsets = this.$(elWindow.frameElement).offset();

                    cursorX     += offsets.left;
                    cursorY     += offsets.top;
                }

                if (!options.doNotUpdateCurrentPosition) {
                    this.currentPosition[ 0 ]   = cursorX;
                    this.currentPosition[ 1 ]   = cursorY;
                }
            }

            return event;
        },


        /**
         * This method will simulate a mouse move to an xy-coordinate or an element (the center of it)
         *
         * @param {Siesta.Test.ActionTarget} target Target point to move the mouse to.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        moveMouseTo : function(target, callback, scope, offset, waitForTarget) {
            if (!target) {
                throw 'Trying to call moveMouseTo without a target';
            }

            // TODO this method should also accept an options object, so user can for example hold CTRL key during mouse operation
//            options.clientX = options.clientX != null ? options.clientX : data.xy[0];
//            options.clientY = options.clientY != null ? options.clientY : data.xy[1];

            if (waitForTarget !== false) {
                this.waitForTargetAndSyncMousePosition(target, offset, function() {
                    this.afterMouseInteraction();
                    callback.call(scope || this);
                }, [], false);
            } else {
                // skip warning about clicking in an unreachable point of the element at this step
                // when mouse position is not yet updated
                // potentially the element will become reachable when the mouse is moved to the required point
                var data        = this.getNormalizedTopElementInfo(target, true, 'moveMouseTo', offset);

                if (data) {
                    this.syncCursor(data.globalXY, callback || function() {});
                } else {
                    // No point in continuing
                    callback && callback.call(scope || this);
                }
            }
        },


        /**
         * Alias for moveMouseTo, this method will simulate a mouse move to an xy-coordinate or an element (the center of it)
         * @param {Siesta.Test.ActionTarget} target Target point to move the mouse to.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        moveCursorTo : function(target, callback, scope, offset) {
            this.moveMouseTo.apply(this, arguments);
        },

        /**
         * This method will simulate a mouse move by an x a y delta amount
         * @param {Array} delta The delta x and y distance to move, e.g. [20, 20] for 20px down/right, or [0, 10] for just 10px down.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} [scope] the scope for the callback
         */
        moveMouseBy : function(delta, callback, scope) {
            this.moveCursorBy.apply(this, arguments);
        },

        /**
         * This method will simulate a mouse move by an x and y delta amount
         * @param {Array} delta The delta x and y distance to move, e.g. [20, 20] for 20px down/right, or [0, -10] for 10px up.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} [scope] the scope for the callback
         */
        moveCursorBy : function(delta, callback, scope) {
            if (!delta) {
                throw 'Trying to call moveCursorBy without relative distances';
            }

            // Normalize target
            var target = [this.currentPosition[0] + delta[0], this.currentPosition[1] + delta[1]];

            this.moveMouse(this.currentPosition, target, callback, scope);
        },

        // private
        moveMouse : function (xy, xy2, callback, scope, pathBatchSize, async, options, mouseMovePrecision) {
            var me          = this

            this.movePointerTemplate({
                xy              : xy,
                xy2             : xy2,
                callback        : callback,
                scope           : scope,
                options         : options || {},

                overEls         : this.overEls,
                interval        : async !== false ? this.dragDelay : 0,
                callbackDelay   : async !== false ? 50 : 0,
                pathBatchSize   : pathBatchSize || me.pathBatchSize,
                mouseMovePrecision : mouseMovePrecision || me.mouseMovePrecision,

                onVoidOverEls   : function () {
                    return me.overEls  = []
                },

                onPointerEnter  : function (el, options, suppressLog) {
                    me.simulateEvent(el, "mouseenter", options, suppressLog)
                },

                onPointerLeave  : function (el, options, suppressLog) {
                    me.simulateEvent(el, "mouseleave", options, suppressLog)
                },

                onPointerOver   : function (el, options, suppressLog) {
                    me.simulateEvent(el, "mouseover", options, suppressLog)
                },

                onPointerOut    : function (el, options, suppressLog) {
                    me.simulateEvent(el, "mouseout", options, suppressLog)
                },

                onPointerMove   : function (el, options, suppressLog) {
                    me.simulateEvent(el, "mousemove", options, suppressLog)
                }
            })
        },
        
        
        nodeIsUnloaded : function (el) {
            try {
                el && el.tagName
                
                var doc     = el.ownerDocument
                var win     = doc && (doc.defaultView || doc.parentWindow)
                
                return !Boolean(win)
            } catch (e) {
                // exception here probably means the "lastOverEl" is from freed context (unloaded page)
                // access to such elements throws exceptions in IE
                el          = null
                
                return true
            }
        },


        // xy, xy2, overEls, callback, scope, pathBatchSize, interval, callbackDelay, options,
        // onPointerEnter, onPointerLeave, onPointerOver, onPointerOut, onPointerMove
        movePointerTemplate: function (args) {
            var document    = this.global.document,
                me          = this,
                overEls     = args.overEls,
                // Remember last visited element, since a previous action may have changed the DOM
                // which possibly should trigger a mouseout event
                lastOverEl  = overEls[ overEls.length - 1 ];
                
            if (lastOverEl && this.nodeIsUnloaded(lastOverEl)) {
                lastOverEl  = null
                overEls     = args.onVoidOverEls()
            }
            
            // always simulate drag with 1px precision
            var mouseMovePrecision  = me.mouseState == 'down' ? 1 : args.mouseMovePrecision || me.mouseMovePrecision
            var pathBatchSize       = Math.max(args.pathBatchSize, mouseMovePrecision)
            var options             = args.options || {}

            var path        = this.getPathBetweenPoints(args.xy, args.xy2);

            var supports    = Siesta.Harness.Browser.FeatureSupport().supports

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                interval        : args.interval,
                callbackDelay   : args.callbackDelay,

                observeTest     : this,

                processor       : function (data, index) {
                    var fromIndex   = data.sourceIndex,
                        toIndex     = data.targetIndex;
                        
//                    console.log("from index: %s, to index: %s", fromIndex, toIndex)
                        
                    // replace 0 with 1 to avoid infinite loop
                    var delta       = Math.min(toIndex - fromIndex, mouseMovePrecision) || 1

                    for (var j = fromIndex; j <= toIndex; j += delta) {
                        var point       = path[ j ];
                        
//                        console.log("point : " + point)
                        
                        var x           = point[ 0 ]
                        var y           = point[ 1 ]
                        var targetEl    = me.elementFromPoint(x, y);

                        // Might get null here if moving over a non-initialized frame (seen in Chrome)
                        if (targetEl) {

                            if (targetEl.ownerDocument !== document) {
                                var win = targetEl.ownerDocument.defaultView || targetEl.ownerDocument.parentWindow;

                                var offsetsToTopWindow = me.$(win.frameElement).offset();

                                x       -= offsetsToTopWindow.left;
                                y       -= offsetsToTopWindow.top;
                            }

                            if (targetEl !== lastOverEl) {
                                for (var i = overEls.length - 1; i >= 0; i--) {
                                    var el = overEls[ i ];
                                    
                                    if (me.nodeIsUnloaded(el))
                                        overEls.splice(i, 1);
                                    else
                                        if (el !== targetEl && me.$(el).has(targetEl).length === 0) {
                                            if (supports.mouseEnterLeave) {
                                                args.onPointerLeave(el, $.extend({ clientX: x, clientY: y, relatedTarget : targetEl}, options))
                                            }
                                            overEls.splice(i, 1);
                                        }
                                }

                                if (lastOverEl) {
                                    args.onPointerOut(lastOverEl, $.extend({ clientX: x, clientY: y, relatedTarget : targetEl}, options))
                                }

                                if (supports.mouseEnterLeave && jQuery.inArray(targetEl, overEls) == -1) {
                                    var els                 = []
                                    var docEl               = targetEl.ownerDocument.documentElement

                                    var mouseEnterEl        = targetEl

                                    // collecting all the els for which to fire the "mouseenter" event, strictly speaking these can be any elements
                                    // (because of absolute positioning) but in most cases it will be just parent elements
                                    while (mouseEnterEl && mouseEnterEl != docEl) {
                                        els.unshift(mouseEnterEl)
                                        mouseEnterEl        = mouseEnterEl.parentNode
                                    }

                                    for (var i = 0; i < els.length; i++) {
                                        if (jQuery.inArray(els[ i ], overEls) == -1) {
                                            args.onPointerEnter(els[ i ], $.extend({ clientX: x, clientY: y, relatedTarget : lastOverEl}, options))

                                            overEls.push(els[ i ]);
                                        }
                                    }
                                }

                                args.onPointerOver(targetEl, $.extend({ clientX: x, clientY: y, relatedTarget : lastOverEl}, options))

                                lastOverEl = targetEl;
                            }

                            args.onPointerMove(targetEl, $.extend({ clientX: x, clientY: y }, options), j < toIndex)
                        }
                        // eof (targetEl)
                    }
                    // eof for
                }
            });

            for (var i = 0, l = path.length; i < l; i += pathBatchSize) {
                queue.addStep({
                    sourceIndex       : i,
                    targetIndex       : Math.min(i + pathBatchSize - 1, path.length - 1)
                });
            }

            var async2       = this.beginAsync()

            queue.run(function () {
                me.endAsync(async2);

                me.processCallbackFromTest(args.callback, null, args.scope || me)
            })
        },

        // This method is called before mouse interactions (the "method" param, along with its "args") to assure that target is visible and reachable.
        // It also handles cases where the target is moved or made unreachable while the cursor is moving towards it.
        // In such unusual cases, a wait is added and the method calls itself to start over
        waitForTargetAndSyncMousePosition : function(target, offset, method, args, waitForTargetTop, syncMousePosition) {
            var originalXY;
            var targetIsNotAPoint                   = this.typeOf(target) != 'Array';
            var oldSuppressPassedWaitForAssertion   = this.suppressPassedWaitForAssertion;
            
            this.suppressPassedWaitForAssertion     = true;

            this.chain(
                { waitForAnimations : [] },

                // Initial wait for target to be
                // 1. in the dom,
                // 2. visible
                targetIsNotAPoint && { waitForElementVisible : target },

                targetIsNotAPoint && this.autoScrollElementsIntoView 
                    ? 
                function (next) {
                    if (this.scrollTargetIntoView(target, offset) === true)
                        // this "waitFor" has been added because of Ext6 behaviour (see https://www.assembla.com/spaces/bryntum/tickets/2211#/activity/ticket:)
                        // Ext6 listens to scroll event on grid view and sets the "pointer-event : none" on the grid view el in the handler
                        // Problem happens during click.
                        // Seems, depending from browser engine, "scroll" event may be fired after slight delay, already after the "mousedown"
                        // even has been fired, then, with "pointer-events" none on grid view, grid container becomes a top element
                        // and further `mouseup` and `click` happens on it, instead of original element
                        // the "pointer-event" style is reset back in the another ExtJS handler, which is buffered for 100ms
                        // so we need to wait > 100ms, waiting for 200ms
                        // potential race condition
                        this.waitFor(this.delayAfterScrollIntoView, next)
                    else
                        next()
                }
                    :
                null,
                    
                function (next) {
                    var data    = this.getNormalizedTopElementInfo(target, true, method.toString(), offset);

                    originalXY  = data.globalXY;

                    if (this.moveCursorBetweenPoints && syncMousePosition !== false) {
                        this.syncCursor(originalXY, next);
                    } else {
                        next();
                    }
                },

                // After moving cursor, we again wait as something might have changed in the while we moved the cursor
                waitForTargetTop !== false && targetIsNotAPoint && function (next) {
                    this.waitForTarget(target, next, this, null, offset);
                },

                function(next) {
                    var data = this.getNormalizedTopElementInfo(target, true, method.toString(), offset);
                    var newXY = data && data.globalXY;

                    // If target has moved or disappeared, start over after a short wait
                    if (targetIsNotAPoint && (!data || originalXY[0] !== newXY[0] || originalXY[1] !== newXY[1])){
                        this.diag(Siesta.Resource('Siesta.Test.Browser','targetMoved'));

                        this.waitFor(100, function() {
                            this.waitForTargetAndSyncMousePosition(target, offset, method, args, waitForTargetTop, syncMousePosition);
                        });
                    } else {
                        this.suppressPassedWaitForAssertion = oldSuppressPassedWaitForAssertion;

                        // Here we're done - call original method
                        method.apply(this, args);
                    }
                }
            )
        },

        // Check if the mouse interaction triggered a DOM update causing the last interacted element to be removed from the DOM
        // In this case we should simulate a new 'mouseover' event on whatever appeared under the cursor.
        afterMouseInteraction : function() {
            var overEls         = this.overEls,
                lastOverEl      = overEls[ overEls.length - 1 ]

            // URL might have changed, then ignore
            if (!this.global.document.body) return;

            if (lastOverEl) {
                if (this.nodeIsUnloaded(lastOverEl)) {
                    lastOverEl  = null
                    this.overEls = []
                    
                    // after page reload we want to simulate the `mouseover` 
                    // for the element appeared at the current cursor position
                    this.mouseOver(this.currentPosition);
                } else {
                    var doc     = lastOverEl.ownerDocument;

                    if (!$.contains(lastOverEl, doc.body)) 
                        this.mouseOver(this.currentPosition);
                }
            }
        },


        // el - the target
        // callback
        // scope
        // options for the events emitted
        // actionName (string) - "rightClick", "click" or "doubleClick"
        // offset
        // performTargetCheck, true to waitFor target appearing - false to avoid
        genericMouseClick : function (el, callback, scope, options, actionName, offset, performTargetCheck) {
            if (jQuery.isFunction(el)) {
                scope       = callback;
                callback    = el;
                el          = null;
            }

            el              = el || this.currentPosition

            if (performTargetCheck !== false && callback) {
                this.waitForTargetAndSyncMousePosition(el, offset, this.genericMouseClick, [el, callback, scope, options, actionName, offset, false]);
                return;
            }

            options         = options || {};

            // skip warning about clicking in an unreachable point of the element at this step
            // when mouse position is not yet updated
            // potentially the element will become reachable when the mouse is moved to the required point
            var data        = this.getNormalizedTopElementInfo(el, true, actionName, offset);
            
            if (!data) {
                // No point in continuing
                callback && callback.call(scope || this);
                return;
            }

            // marking data as preliminary, indicating that it should be updated before the click
            data.originalEl     = el
            data.method         = actionName
            data.offset         = offset

            options.clientX = options.clientX != null ? options.clientX : data.localXY[ 0 ];
            options.clientY = options.clientY != null ? options.clientY : data.localXY[ 1 ];

            this[ actionName ](data, callback, scope, options);
        },

        /**
         * This method will simulate a mouse click in the center of the specified DOM/Ext element,
         * or at current cursor position if no target is provided.
         *
         * Note, that it will first calculate the centeral point of the specified element and then
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.
         *
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mouseup`, `click`
         *
         * Example:
         *
         *      t.click(t.getFirstRow(grid), function () { ... })
         *
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         *
         *      t.click(function () { ... })
         *
         * @param {Siesta.Test.ActionTarget} [el] One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element
         * @param {Function} [callback] A function to call after click.
         * @param {Object} [scope] The scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        click: function (el, callback, scope, options, offset, waitForTarget) {
            this.genericMouseClick(el, callback, scope, options, 'simulateMouseClick', offset, waitForTarget)
        },


        /**
         * This method will simulate a mouse right click in the center of the specified DOM/Ext element,
         * or at current cursor position if no target is provided.
         *
         * Note, that it will first calculate the centeral point of the specified element and then
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.
         *
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mouseup`, `contextmenu`
         *
         * Example:
         *
         *      t.click(t.getFirstRow(grid), function () { ... })
         *
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         *
         *      t.click(function () { ... })
         *
         * @param {Siesta.Test.ActionTarget} [el] One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element
         * @param {Function} [callback] A function to call after click.
         * @param {Object} [scope] The scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        rightClick: function (el, callback, scope, options, offset, waitForTarget) {
            this.genericMouseClick(el, callback, scope, options, 'simulateRightClick', offset, waitForTarget)
        },


        /**
         * This method will simulate a mouse double click in the center of the specified DOM/Ext element,
         * or at current cursor position if no target is provided.
         *
         * Note, that it will first calculate the centeral point of the specified element and then
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.
         *
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mouseup`, `click`, `mousedown`, `mouseup`, `click`, `dblclick`
         *
         * Example:
         *
         *      t.click(t.getFirstRow(grid), function () { ... })
         *
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         *
         *      t.click(function () { ... })
         *
         * @param {Siesta.Test.ActionTarget} [el] One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element
         * @param {Function} [callback] A function to call after click.
         * @param {Object} [scope] The scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        doubleClick: function (el, callback, scope, options, offset, waitForTarget) {
            this.genericMouseClick(el, callback, scope, options, 'simulateDoubleClick', offset, waitForTarget)
        },

        /**
         * This method will simulate a mousedown event in the center of the specified DOM element,
         * or at current cursor position if no target is provided.
         *
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @param {Function} [callback] A function to call after mousedown.
         * @param {Object} [scope] The scope for the callback
         */
        mouseDown: function (el, options, offset, callback, scope, performTargetCheck) {
            this.genericMouseClick(el, callback, scope, options, 'simulateMouseDown', offset, performTargetCheck);
        },

        simulateMouseDown: function (clickInfo, callback, scope, options) {
            this.processMouseClickSteps(
                clickInfo,
                callback,
                scope,
                options,
                [
                    { event : "mousedown", focus : true }
                ]
            );
        },

        /**
         * This method will simulate a mousedown event in the center of the specified DOM element,
         * or at current cursor position if no target is provided.
         *
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        mouseUp: function (el, options, offset) {
            var info        = this.getNormalizedTopElementInfo(el, true, 'mouseUp', offset);

            if (!info) return;

            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];

            el              = info.el || el;

            this.simulateEvent(el, 'mouseup', options);
        },

        /**
         * This method will simulate a mouseover event in the center of the specified DOM element.
         *
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         */
        mouseOver: function (el, options) {
            var info        = this.getNormalizedTopElementInfo(el, true);

            if (!info) return;

            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];

            this.simulateEvent(el, 'mouseover', options);
        },

        /**
         * This method will simulate a mouseout event in the center of the specified DOM element.
         *
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         */
        mouseOut: function (el, options) {
            var info        = this.getNormalizedTopElementInfo(el, true);

            if (!info) return;

            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];

            this.simulateEvent(el, 'mouseout', options);
        },


        processMouseClickSteps : function (clickInfo, callback, scope, options, steps) {
            // trying to get the top element again, enabling the warning if needed
            // do it here and not in the `genericMouseClick` method to allow scenario
            // when target element appears when mouse moves to the click point
            if (clickInfo.originalEl && this.enableUnreachableClickWarning) {
                this.getNormalizedTopElementInfo(clickInfo.originalEl, false, clickInfo.method, clickInfo.offset)
            }

            var me          = this

            var x           = clickInfo.globalXY[ 0 ]
            var y           = clickInfo.globalXY[ 1 ]
            var isOption    = clickInfo.el.nodeName.toLowerCase() === 'option';

            var doc         = me.global.document
            
            var prevScrollTop   = doc.body.scrollTop

            // re-evaluate the target el - it might have changed while we were syncing the cursor position
            var target      = isOption ? clickInfo.el : me.elementFromPoint(x, y, false, clickInfo.el)

            var targetHasChanged    = false

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                interval        : callback ? 10 : 0,
                callbackDelay   : me.afterActionDelay,

                observeTest     : this,

                processor       : function (data) {
                    // XXX this has to be investigated more deeply (notably the <body> vs <html> scrolling, etc)
                    // - When simulating events browser performs weird scrolls on the document.
                    // Seems it tries to make the point of simulated event visible on the screen.
                    // This is native browser behavior over of our control.
                    // Thing is, when the document is scrolled, `elementFromPoint` returns different
                    // element for the same point. Because of that the logic for clicks is vulnerable.
                    // Scenario is - "mousedown" (or may be "mouseup") is simulated, scroll position changes
                    // futher "click" event happens on different element
                    
                    // body can be absent if the doubleclick happens on the anchor and page is reloaded in the middle 
                    // of double click
                    var delta       = doc.body ? doc.body.scrollTop - prevScrollTop : 0
                    var el          = isOption ? target : me.elementFromPoint(x, y - delta, false, target)

                    if (!isOption && data.recaptureTarget) { target = el; targetHasChanged = false }

                    // The "click" event should be canceled if "mousedown/up" happened on different elements,
                    // _unless_ these elements has parent/child relationship
                    if (!isOption && el != target && !($.contains(el, target) || $.contains(target, el))) targetHasChanged = true

                    if (targetHasChanged && data.cancelIfTargetChanged) return

                    var event = me.simulateEvent(el, data.event, options, data.suppressLog);
                    
                    if (event.type == 'mousedown') 
                        me.mouseState    = 'down'
                    else
                        if (event.type == 'mouseup')
                            me.mouseState    = 'up'

                    if (data.focus) me.mimicFocusOnMouseDown(el, event)
                }
            })

            Joose.A.each(steps, function (step) { queue.addStep(step) })

            var async   = me.beginAsync();

            queue.run(function () {
                me.endAsync(async);

                me.afterMouseInteraction();

                me.processCallbackFromTest(callback, null, scope || me)
            })
        },


        // private
        simulateMouseClick: function (clickInfo, callback, scope, options) {
            this.processMouseClickSteps(
                clickInfo,
                callback,
                scope,
                options,
                [
                    { event : "mousedown", suppressLog : true, focus : true },
                    { event : "mouseup", suppressLog : true },
                    { event : "click", suppressLog : false, cancelIfTargetChanged : true }
                ]
            )
        },

        // private
        simulateRightClick: function (clickInfo, callback, scope, options) {
            // Mac doesn't fire mouseup when right clicking
            var isMac = navigator.platform.indexOf('Mac') > -1;

            options         = options || {};
            options.button  = 2;

            this.processMouseClickSteps(
                clickInfo,
                callback,
                scope,
                options,
                [
                    { event : "mousedown", suppressLog : false, focus : true }
                ].concat(isMac ? [] :
                    [{ event : "mouseup", suppressLog : true }]
                ).concat(
                    [{ event : "contextmenu", suppressLog : false }]
                )
            )
        },

        // private
        simulateDoubleClick: function (clickInfo, callback, scope, options) {
            this.processMouseClickSteps(
                clickInfo,
                callback,
                scope,
                options,
                [
                    { event : "mousedown", suppressLog : false, focus : true },
                    { event : "mouseup", suppressLog : true },
                    { event : "click", suppressLog : false, cancelIfTargetChanged : true },
                    { event : "mousedown", suppressLog : false, recaptureTarget : true, focus : true },
                    { event : "mouseup", suppressLog : true },
                    { event : "click", suppressLog : true, cancelIfTargetChanged : true },
                    { event : "dblclick", suppressLog : false, cancelIfTargetChanged : true }
                ]
            )
        },

        // private
        syncCursor : function(toXY, callback, args) {
            var me          = this
            var fromXY      = this.currentPosition;

            args            = args || [];

            if (toXY[0] !== fromXY[0] || toXY[1] !== fromXY[1]) {

                this.moveMouse(fromXY, toXY, function() {
                    callback && callback.apply(me, args);
                });
            } else
            // already aligned
                callback && callback.apply(this, args);
        },


        /**
         * This method will simulate a drag and drop operation between either two points or two DOM elements.
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mousemove` (along the mouse path), `mouseup`
         *
         * @deprecated This method is deprecated in favor of {@link #dragTo} and {@link #dragBy} methods
         * @param {Siesta.Test.ActionTarget} source Either an element, or [x,y] as the drag starting point
         * @param {Siesta.Test.ActionTarget} [target] Either an element, or [x,y] as the drag end point
         * @param {Array} [delta] the amount to drag from the source coordinate, expressed as [x,y]. [50, 10] will drag 50px to the right and 10px down.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the drag operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Object} options any extra options used to configure the DOM event
         */
        drag: function (source, target, delta, callback, scope, options) {
            if (!source) {
                throw 'No drag source defined';
            }

            if (target) {
                this.dragTo(source, target, callback, scope, options);
            } else {
                this.dragBy(source, delta, callback, scope, options);
            }
        },

        /**
         * This method will simulate a drag and drop operation between either two points or two DOM elements.
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mousemove` (along the mouse path), `mouseup`
         *
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value for the drag starting point
         * @param {Siesta.Test.ActionTarget} target {@link Siesta.Test.ActionTarget} value for the drag end point
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the drag operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} [sourceOffset] An X,Y offset relative to the source. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @param {Array} [targetOffset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        dragTo : function (source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset, performTargetCheck) {
            if (!target) throw 'No drag target defined';

            source              = source || this.currentPosition;
            options             = options || {};

            if (performTargetCheck !== false && callback) {
                this.waitForTargetAndSyncMousePosition(source, sourceOffset, this.dragTo, [source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset, false]);
                return;
            }

            // normalize source and target
            var sourceContext   = this.getNormalizedTopElementInfo(source, true, 'dragTo: Source', sourceOffset);
            var targetContext   = this.getNormalizedTopElementInfo(target, false, 'dragTo: Target', targetOffset);

            if (!targetContext) {
                this.processCallbackFromTest(callback, null, scope || this);
                return;
            }

            this.simulateDrag(sourceContext.globalXY, targetContext.globalXY, function() {
                this.afterMouseInteraction();

                callback.call(scope || this);
            }, null, options, dragOnly);
        },

        /**
         * This method will simulate a drag and drop operation from a point (or DOM element) and move by a delta.
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mousemove` (along the mouse path), `mouseup`
         *
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value as the drag starting point
         * @param {Array} delta The amount to drag from the source coordinate, expressed as [x,y]. E.g. [50, 10] will drag 50px to the right and 10px down.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the drag operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        dragBy : function (source, delta, callback, scope, options, dragOnly, offset, performTargetCheck) {
            if (!delta) throw 'No drag delta defined';

            source              = source || this.currentPosition;

            if (performTargetCheck !== false && callback) {
                this.waitForTargetAndSyncMousePosition(source, offset, this.dragBy, [source, delta, callback, scope, options, dragOnly, offset, false]);
                return;
            }

            var sourceContext   = this.getNormalizedTopElementInfo(source, true, 'dragBy: Source', offset);

            if (!sourceContext) {
                // No target found, abort.
                callback && callback.call(scope || this);
                return;
            }
            var sourceXY        = sourceContext.globalXY;
            var targetXY        = [ sourceXY[0] + delta[0], sourceXY[1] + delta[1] ];

            this.simulateDrag(sourceXY, targetXY, function() {
                this.afterMouseInteraction();

                callback.call(scope || this);
            }, null, options, dragOnly);
        },

        // private
        simulateDrag: function (sourceXY, targetXY, callback, scope, options, dragOnly) {
            var me          = this
            options         = options || {};

            // For drag operations we should always use the top level document.elementFromPoint
            var source      = me.elementFromPoint(sourceXY[0], sourceXY[1], false);
            var target      = me.elementFromPoint(targetXY[0], targetXY[1], false);

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                interval        : me.dragDelay,
                callbackDelay   : me.afterActionDelay,

                observeTest     : this
            });

            queue.addStep({
                processor : function () {
                    me.simulateEvent(source, "mouseover", $.extend({ clientX: sourceXY[0], clientY: sourceXY[1]}, options));
                }
            });

            queue.addStep({
                processor : function () {
                    // Fetch source el again since the mouseover might trigger another element to go visible.
                    source  = me.elementFromPoint(sourceXY[0], sourceXY[1], false, source);
                    me.simulateEvent(source, "mouseover", $.extend({ clientX: sourceXY[0], clientY: sourceXY[1]}, options));
                }
            });

            queue.addStep({
                processor : function () {
                    var event = me.simulateEvent(source, "mousedown", $.extend({ clientX: sourceXY[0], clientY: sourceXY[1]}, options));

                    me.mimicFocusOnMouseDown(source, event);
                }
            });

            queue.addStep({
                isAsync     : true,

                processor   : function (data) {
                    me.moveMouse(sourceXY, targetXY, data.next, this, null, true, options, 1);
                }
            });

            var el;

            queue.addStep({
                processor : function () {
                    el      = me.elementFromPoint(targetXY[0], targetXY[1], false);
                    me.simulateEvent(el, 'mouseover', $.extend({ clientX: targetXY[0], clientY: targetXY[1] }, options));
                }
            });

            if (!dragOnly) {
                queue.addStep({
                    processor : function () {
                        me.simulateEvent(el, 'mouseup', $.extend({ clientX: targetXY[0], clientY: targetXY[1] }, options));
                    }
                });

                queue.addStep({
                    processor : function () {
                        if (el && (el === source || $.contains(source, el))) {
                            me.simulateEvent(source, 'click', $.extend({ clientX: targetXY[0], clientY: targetXY[1] }, options));
                        }
                    }
                });
            }


            var async       = this.beginAsync();

            queue.run(function () {
                me.endAsync(async)

                me.processCallbackFromTest(callback, null, scope || me)
            });
        },

        mimicFocusOnMouseDown : function (el, mouseDownEvent) {

            // only do focus if `mousedown` event is not prevented by outside world
            if (this.isEventPrevented(mouseDownEvent)) return;

            // if we've clicked text input element just do regular focus
            if (this.isElementFocusable(el)) {
                this.focus(el, true)
                return
            }

            var doc         = el.ownerDocument
            var win         = doc.defaultView || doc.parentWindow
            var body        = doc.body

            if (!body) return;

            // otherwise focus the nearest parent with non-null `tabIndex` attribute
            // as an edge case an "<html> element can be clicked
            while (el && el != body && el != doc) {
                // IE-specific: don't look up the parent nodes when clicked an element with "unselectable" attribute set to "on"
                // and do not focus the body
                // "unselectable" attr should not be used to determine focusability state
                if ($.browser.msie && el.getAttribute('unselectable') == 'on') return

                if (this.isElementFocusable(el)) {
                    this.focus(el, true)
                    return
                }

                el          = el.parentNode
            }

            // focus body as the last resort to trigger the "blur" event on the currently focused element
            this.focus(body || doc.documentElement, true)
        }
    }
});
;
/**
@class Siesta.Test.Simulate.KeyCodes
@singleton

This is a singleton class, containing the mnemonical names for various advanced key codes. You can use this names in the {@link Siesta.Test.Browser#type} method, like this:

    t.type(el, 'Foo bar[ENTER]', function () {
        ...
    })

Below is the full list:

 - `BACKSPACE`

 - `TAB`

 - `RETURN`
 - `ENTER`

 - `SHIFT`
 - `CTRL`
 - `ALT`

 - `PAUSE-BREAK`
 - `CAPS`
 - `ESCAPE`
 - `NUM-LOCK`
 - `SCROLL-LOCK`
 - `PRINT`

 - `PAGE-UP`
 - `PAGE-DOWN`
 - `END`
 - `HOME`
 - `LEFT`
 - `UP`
 - `RIGHT`
 - `DOWN`
 - `INSERT`
 - `DELETE`


 - `NUM0`
 - `NUM1`
 - `NUM2`
 - `NUM3`
 - `NUM4`
 - `NUM5`
 - `NUM6`
 - `NUM7`
 - `NUM8`
 - `NUM9`

 - `F1`
 - `F2`
 - `F3`
 - `F4`
 - `F5`
 - `F6`
 - `F7`
 - `F8`
 - `F9`
 - `F10`
 - `F11`
 - `F12`

 */
Singleton('Siesta.Test.Simulate.KeyCodes', {

    methods : {
        isNav : function (k) {
            var keys = this.keys

            return (k >= 33 && k <= 40) ||
                k == keys.RETURN ||
                k == keys.TAB ||
                k == keys.ESCAPE;
        },

        isSpecial : function (k) {

            return k === this.keys.BACKSPACE ||
                (k >= 16 && k <= 20) ||
                (k >= 44 && k <= 46) ||
                k === 91;
        },

        isModifier : function(k) {
            return k === this.keys.SHIFT ||
                   k === this.keys.CTRL ||
                   k === this.keys.ALT ||
                   k === this.keys.CMD; // TODO add check to make sure it's a Mac?
        },

        fromCharCode : function (code, readableForm) {
            var keys    = this.keys
            
            for (var key in keys) if (keys[ key ] === code && (!readableForm || key.length > 1)) return key;
        }
    },

    has : {
        // FROM Syn library by JupiterJS, MIT License. www.jupiterjs.com

        // key codes
        keys : {

            init : {
                //backspace
                '\b'          : 8,
                'BACKSPACE'   : 8,

                //tab
                '\t'          : 9,
                'TAB'         : 9,

                //enter
                '\r'          : 13,
                'RETURN'      : 13,
                'ENTER'       : 13,

                //special
                'SHIFT'       : 16,
                'CTRL'        : 17,
                'ALT'         : 18,
                'CMD'         : 91, // Mac

                //weird
                'PAUSE-BREAK' : 19,
                'CAPS'        : 20,
                'ESCAPE'      : 27,
                'NUM-LOCK'    : 144,
                'SCROLL-LOCK' : 145,
                'PRINT'       : 44,

                //navigation
                'PAGE-UP'     : 33,
                'PAGE-DOWN'   : 34,
                'END'         : 35,
                'HOME'        : 36,
                'LEFT'        : 37,
                'UP'          : 38,
                'RIGHT'       : 39,
                'DOWN'        : 40,
                'INSERT'      : 45,
                'DELETE'      : 46,

                //normal characters
                ' '           : 32,
                '0'           : 48,
                '1'           : 49,
                '2'           : 50,
                '3'           : 51,
                '4'           : 52,
                '5'           : 53,
                '6'           : 54,
                '7'           : 55,
                '8'           : 56,
                '9'           : 57,
                'A'           : 65,
                'B'           : 66,
                'C'           : 67,
                'D'           : 68,
                'E'           : 69,
                'F'           : 70,
                'G'           : 71,
                'H'           : 72,
                'I'           : 73,
                'J'           : 74,
                'K'           : 75,
                'L'           : 76,
                'M'           : 77,
                'N'           : 78,
                'O'           : 79,
                'P'           : 80,
                'Q'           : 81,
                'R'           : 82,
                'S'           : 83,
                'T'           : 84,
                'U'           : 85,
                'V'           : 86,
                'W'           : 87,
                'X'           : 88,
                'Y'           : 89,
                'Z'           : 90,

                //NORMAL-CHARACTERS, NUMPAD
                'NUM0'        : 96,
                'NUM1'        : 97,
                'NUM2'        : 98,
                'NUM3'        : 99,
                'NUM4'        : 100,
                'NUM5'        : 101,
                'NUM6'        : 102,
                'NUM7'        : 103,
                'NUM8'        : 104,
                'NUM9'        : 105,
                '*'           : 106,
                '+'           : 107,
                '-'           : 109,
                '.'           : 110,

                //normal-characters, others
                '/'           : 111,
                ';'           : 186,
                '='           : 187,
                ','           : 188,
                '-'           : 189,
                '.'           : 190,
                '/'           : 191,
                '`'           : 192,
                '['           : 219,
                '\\'          : 220,
                ']'           : 221,
                "'"           : 222,

                'F1'  : 112,
                'F2'  : 113,
                'F3'  : 114,
                'F4'  : 115,
                'F5'  : 116,
                'F6'  : 117,
                'F7'  : 118,
                'F8'  : 119,
                'F9'  : 120,
                'F10' : 121,
                'F11' : 122,
                'F12' : 123
            }
        }
        // eof key codes
    }
    // eof has
});;
/**
@class Siesta.Test.Simulate.Keyboard

This is a mixin, providing the keyboard events simulation functionality.


*/

//        Copyright (c) 2011 John Resig, http://jquery.com/

//        Permission is hereby granted, free of charge, to any person obtaining
//        a copy of this software and associated documentation files (the
//        "Software"), to deal in the Software without restriction, including
//        without limitation the rights to use, copy, modify, merge, publish,
//        distribute, sublicense, and/or sell copies of the Software, and to
//        permit persons to whom the Software is furnished to do so, subject to
//        the following conditions:

//        The above copyright notice and this permission notice shall be
//        included in all copies or substantial portions of the Software.

//        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
//        LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//        OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
//        WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


Role('Siesta.Test.Simulate.Keyboard', {

    requires        : [ 'simulateEvent', 'getSimulateEventsWith', 'getElementAtCursor' ],

    has : {
        eventName           : "KeyboardEvent" in window ? "KeyboardEvent" : ("KeyEvent" in window ? "KeyEvents" : null)
    },

    methods: {

        // TODO switch to KeyboardEvent https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent
        // private
        createKeyboardEvent: function (type, options, el) {
            var evt;

            var e = $.extend({ bubbles: true, cancelable: true, view: this.global,
                ctrlKey: false, altKey: false, shiftKey: false, metaKey: false,
                keyCode: 0, charCode: 0
            }, options);

            var doc = el.ownerDocument;

            // use W3C standard when available and allowed by "simulateEventsWith" option
            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                try {
                    evt = doc.createEvent(this.eventName);
                    evt.initKeyEvent(type, e.bubbles, e.cancelable, e.view, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.keyCode, e.charCode);
                } catch (err) {
                    evt = doc.createEvent("Events");
                    evt.initEvent(type, e.bubbles, e.cancelable);
                    $.extend(evt, { view: e.view,
                        ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey, metaKey: e.metaKey,
                        keyCode: e.keyCode, charCode: e.charCode
                    });
                }
            } else if (doc.createEventObject) {
                evt = doc.createEventObject();
                $.extend(evt, e);
            }
            if ($.browser.msie || $.browser.opera) {
                evt.keyCode = (e.charCode > 0) ? e.charCode : e.keyCode;
                evt.charCode = undefined;
            }

            return evt;
        },

        // private
        createTextEvent: function (type, options, el) {
            var doc         = el.ownerDocument;
            var event       = null;

            // only for Webkit / IE for now
            if (doc.createEvent) {
                try {
                    event = doc.createEvent('TextEvent');

                    if (event && event.initTextEvent) {
                        event.initTextEvent(
                            type,
                            true,
                            true,
                            this.global,
                            options.text,
                            // IE ONLY below here
                            0,
                            window.navigator.userLanguage || window.navigator.language
                        );
                        return event;
                    }
                }
                catch(e) {}
            }

            return null;
        },


        /*!
         * Based on:
         * 
         * @license EmulateTab
         * Copyright (c) 2011, 2012 The Swedish Post and Telecom Authority (PTS)
         * Developed for PTS by Joel Purra <http://joelpurra.se/>
         * Released under the BSD license.
         *
         * A jQuery plugin to emulate tabbing between elements on a page.
         */
        findNextFocusable : function (el, offset) {
            var $el         = this.$(el)

            var $focusable  = this.$(":focus, :input, a[href], [tabindex], body", el.ownerDocument)
                .not(":disabled")
                .not(":hidden")
                .not("a[href]:empty")


            var escapeSelectorName  = function (str) {
                // Based on http://api.jquery.com/category/selectors/
                // Still untested
                return str.replace(/(!"#$%&'\(\)\*\+,\.\/:;<=>\?@\[\]^`\{\|\}~)/g, "\\\\$1");
            }

            var isRadio     = false
            var selector

            if (el.tagName === "INPUT" && el.type === "radio" && el.name !== "" ) {
                isRadio     = true
                selector    = "input[type=radio][name=" + escapeSelectorName(el.name) + "]"
            }

            var processed       = []

            for (var i = 0; i < $focusable.length; i++) {
                var currEl      = $focusable[ i ]

                // always include current element 
                if (currEl != el && currEl.getAttribute('tabIndex') == -1 || isRadio && $(currEl).is(selector)) continue

                processed.push(currEl)
            }

            var body                = el.ownerDocument.body
            var currentTabIndex     = el.getAttribute('tabIndex')

            var getTabIndex         = function (dom) {
                if (dom == el && currentTabIndex == -1) return 0

                if (dom == body) return 0

                return dom.getAttribute('tabIndex') || 0
            }

            processed.sort(function (a, b) {
                var aIndex      = getTabIndex(a)
                var bIndex      = getTabIndex(b)

                return aIndex < bIndex ? -1 : (aIndex > bIndex ? 1 : (a == body ? 1 : (b == body ? -1 : 0)))
            });

            var currentIndex    = $(processed).index($el);

            if (currentIndex == -1) return null

            return processed[ (currentIndex + offset) % processed.length ]
        },


        emulateTab : function (el, offset) {
            var next        = this.findNextFocusable(el, offset || 1)

            if (next)
                this.focus(next)
            else
                el.blur()

            return next
        },


        /**
        * This method will simulate keyboard typing on either a provided DOM element, or if omitted on the currently focuced DOM element.
        * Simulation of certain special keys such as ENTER, ESC, LEFT etc is supported.
        * You can type these special keys by using the all uppercase name the key inside square brackets. See {@link Siesta.Test.Simulate.KeyCodes} for a list
        * of key names.
        *
        * For example:
        *

    t.type(el, 'Foo bar[ENTER]', function () {
        ...
    })

    // With extra options as the last argument
    t.type(el, 'Foo bar[ENTER]', callback, scope, { shiftKey : true, altKey : true });
        *
        * The following events will be fired, in order: `keydown`, `keypress`, `keyup`
        *
        * @param {Siesta.Test.ActionTarget} el The element to type into
        * @param {String} text The text to type, including any names of special keys in square brackets.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the type operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        * @param {Object} options (optional) any extra options used to configure the DOM key events (like holding shiftKey, ctrlKey, altKey etc).
        * @param {Boolean} clearExisting (optional) true to clear existing text in the target before typing
         */
        type : function (el, text, callback, scope, options, clearExisting, performTargetCheck) {
            // Skip target check if user is simply targeting whatever is focused
            if (!el) performTargetCheck = false;

            el              = el || this.activeElement();

            if (performTargetCheck !== false && callback) {
                this.waitForTargetAndSyncMousePosition(el, null, this.type, [el, text, callback, scope, options, clearExisting, false], false, false);
                return;
            }

            el              = this.normalizeElement(el);

            if (text == null) throw 'Must supply a string to type';

            if (!el) {
                // No point in continuing
                callback && callback.call(scope || this);
                return;
            }

            var me          = this

            if (el.readOnly || el.disabled) {
                me.processCallbackFromTest(callback, null, scope || me)

                return;
            }

            if (clearExisting) {
                el.value    = ''
            }

            // Extract normal chars, or special keys in brackets such as [TAB], [RIGHT] or [ENTER]			
            var keys        = (text + '').match(/(\[(?:\w|-)+\])|([\s\S])/g) || [];

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                interval        : this.actionDelay,
                callbackDelay   : this.afterActionDelay,

                observeTest     : this,

                processor       : function (data, index) {
                    // 1. In IE10, it seems activeElement cannot be trusted as it sometimes returns an empty object with no properties.
                    // Try to detect this case and simply use the original el 
                    // 2. If user clicks around in the harness during ongoing test, the activeElement will be reset to BODY
                    // If this happens, reuse the original el and hope all is well
                    var focusedEl   = me.activeElement(true, el, el)

                    me.keyPress(focusedEl, data.key, options)
                }
            })

            // Manually focus event to be typed into first
            queue.addStep({
                processor       : function () {
                    me.focus(el)
                }
            })

            // focus the element one more time for IE - this seems to fix the weird sporadic failures in 042_keyevent_simulation3.t.js
            // failures are caused by the field "blur" immediately after 1st focus
            // no Ext "focus/blur" methods seems to be called, so it can be a browser behavior
            $.browser.msie && queue.addStep({
                processor       : function () {
                    me.focus(el)
                }
            })

            jQuery.each(keys, function (index, key) {
                key             = key.length == 1 ? key : key.substring(1, key.length - 1)

                keys[ index ]   = key

                queue.addStep({ key : key })
            });

            if (keys.length) {
                var KeyCodes        = Siesta.Test.Simulate.KeyCodes().keys;
                var firstKeyCode    = KeyCodes[ keys[ 0 ].toUpperCase() ]

                if (this.isReadableKey(firstKeyCode) || firstKeyCode === KeyCodes.BACKSPACE || firstKeyCode === KeyCodes.DELETE) {
                    // Some browsers (IE/FF) do not overwrite selected text, do it manually
                    // but only if the key is readable (some letter etc)
                    // do not clear the selection in case of special symbol
                    var selText     = this.getSelectedText(el);

                    if (selText) {
                        el.value    = el.value.replace(selText, '');
                    }
                }
            }

            var async       = this.beginAsync();

            queue.run(function () {
                me.endAsync(async)

                me.processCallbackFromTest(callback, null, scope || me)
            })
        },

        /**
        * @param {Siesta.Test.ActionTarget} el
        * @param {String} key
        * @param {Object} options any extra options used to configure the DOM event
        *
        * This method will simluate the key press, translated to the specified DOM element.
        * The following events will be fired, in order: `keydown`, `keypress`, `textInput`(webkit only currently), `keyup`
        */
        keyPress: function (el, key, options, callback) {
            el                  = this.normalizeElement(el);

            var KeyCodes        = Siesta.Test.Simulate.KeyCodes().keys
            var keyCode         = KeyCodes[ key.toUpperCase() ] || 0;

            if (typeof options === 'function') {
                callback = options;
                options  = undefined;
            }
            options             = options || {};

            options.readableKey = key;

            // keypress should not be fired when CTRL or CMD are pressed
            var ctrlOrCmdPressed = options.metaKey && !options.ctrlKey;

            // Should not actually type anything when CTRL / CMD are pressed
            var isReadableKey   = this.isReadableKey(keyCode) && !ctrlOrCmdPressed

            var charCode        = isReadableKey ? key.charCodeAt(0) : 0

            var me              = this,
                isTextInput     = me.isTextInput(el),
                isEditableNode  = me.isEditableNode(el),
                acceptsTextInput = isTextInput || isEditableNode;

            var keyDownEvent    = me.simulateEvent(el, 'keydown', $.extend({ charCode : 0, keyCode : keyCode }, options), true);
            var keyDownPrevented    = this.isEventPrevented(keyDownEvent)
            var shouldMimicSelection = this.shouldMimicTextSelection(keyDownEvent);

            if (shouldMimicSelection) {
                this.selectText(el);
            } else {
                var prevented       = false;
                var supports        = Siesta.Harness.Browser.FeatureSupport().supports

                // Need to reevaluate focused element here, it may have changed in a 'keydown' listener
                el                  = me.activeElement(true, el, el);

                // keypress should not be fired when CTRL or CMD are pressed
                if (!ctrlOrCmdPressed) {
                    var event       = me.simulateEvent(el, 'keypress', $.extend({ charCode : charCode, keyCode : isReadableKey ? 0 : keyCode }, options), false);
                    prevented       = this.isEventPrevented(event)

                    if (!keyDownPrevented && !prevented && keyCode === KeyCodes.TAB) {
                        el              = this.emulateTab(el, options.shiftKey ? -1 : 1) || el;
                    }
                }

                if (!prevented && acceptsTextInput && keyCode != KeyCodes.TAB) {
                    var isPhantomJS = this.harness.isPhantomJS
                    var textValueProp = 'value' in el ? 'value' : 'innerHTML';

                    if (isReadableKey) {
                        // PhantomJS does not simulate the "textInput" event correctly if target element is inside an iframe
                        // (at least not as of 1.6), only the last character is shown.
                        if (!isPhantomJS) {
                            var innerHTML

                            // IE10 tries to be 'helpful' by inserting an empty space, clean it
                            // IE11 inserts <br> after call to the .focus() method of the element
                            if (isEditableNode && $.browser.msie) {
                                innerHTML               = el.innerHTML

                                if (innerHTML.indexOf('&nbsp;') === 0)
                                    el.innerHTML        = innerHTML.substring(6)
                                else
                                    if (innerHTML.indexOf('<br>') === 0)
                                        el.innerHTML    = innerHTML.substring(4);
                            }

                            // IE won't do execCommand with insertText
                            if (isEditableNode && !$.browser.msie) {
                                innerHTML           = el.innerHTML

                                if (innerHTML.charCodeAt(innerHTML.length - 1) === 8203) {
                                    el.innerHTML    = innerHTML.substring(0, innerHTML.length - 1);
                                }
                                el.ownerDocument.execCommand('insertText', false, options.readableKey);
                            } else {
                                 //TODO should check first if textInput event is supported
                                me.simulateEvent(el, $.browser.msie ? 'textinput' : 'textInput', { text: options.readableKey }, true);
                            }
                        }

                        this.mimicCharacterInsertion(el, key);

                        me.simulateEvent(el, 'input', options, true);
                    }

                    // Manually delete one char off the end if backspace simulation is not supported by the browser
                    if (keyCode === KeyCodes.BACKSPACE && !supports.canSimulateBackspace && el[ textValueProp ].length > 0) {
                        // IE won't do execCommand with insertText
                        if (isTextInput || $.browser.msie) {
                            el[ textValueProp ]    = el[ textValueProp ].substring(0, el[ textValueProp ].length - 1);
                        } else {
                            el.ownerDocument.execCommand('delete');
                        }
                    }

                    if (textValueProp === 'value' && keyCode === KeyCodes.ENTER && !supports.enterSubmitsForm) {
                        var form        = this.$(el).closest('form');
                        var hasSubmit   = form.find('[type=submit]').length > 0;
                        var hasOneInput = form.find('input').length === 1;

                        if (form.length && (hasSubmit || hasOneInput)) {
                            var submitPrevented = this.isEventPrevented(me.simulateEvent(form[0], 'submit', {}, true));

                            if (!submitPrevented) form[0].submit();
                        }
                    }
                }
            }

            this.mimicClickOnEnter(el, keyCode);

            me.simulateEvent(el, 'keyup', $.extend({ charCode : 0, keyCode : keyCode }, options), true);

            callback && callback.call(this);
        },


        isTextInput : function(node) {
            // somehow "node.nodeName" is empty sometimes in IE10
            var name    = node.nodeName && node.nodeName.toLowerCase(),
                type    = node.type && node.type.toLowerCase();

            return  name === 'textarea' ||
                    // Various INPUT types
                    (name === 'input' && (type === 'password'   ||
                                         type === 'number'      ||
                                         type === 'search'      ||
                                         type === 'text'        ||
                                         type === 'url'         ||
                                         type === 'tel'         ||
                                         type === 'month'       ||
                                         type === 'time'        ||
                                         type === 'date'        ||
                                         type === 'datetime'    ||
                                         type === 'week'        ||
                                         type === 'email'));
        },

        isEditableNode : function(node) {
            return node.ownerDocument.designMode.toLowerCase() === 'on' ||
                   node.contentEditable.toLowerCase() === 'true';
        },

        // private
        isReadableKey: function (keyCode) {
            var KC = Siesta.Test.Simulate.KeyCodes();

            return !KC.isNav(keyCode) && !KC.isSpecial(keyCode);
        },

        mimicCharacterInsertion : function(el, readableKey) {
            var textValueProp   = 'value' in el ? 'value' : 'innerHTML';
            var originalLength  = el[ textValueProp ].length;
            var maxLength       = el.getAttribute('maxlength')
            var isTextInput     = this.isTextInput(el);
            var supports        = Siesta.Harness.Browser.FeatureSupport().supports;

            if (maxLength != null) maxLength    = Number(maxLength)

            // If the entered char had no impact on the textfield - manually put it there
            if ((isTextInput || $.browser.msie) && (!supports.canSimulateKeyCharacters || this.harness.isPhantomJS) && originalLength === el[ textValueProp ].length && originalLength !== maxLength) {
                el[ textValueProp ] = el[ textValueProp ] + readableKey;
            }
        },

        shouldMimicTextSelection : function(keyDownEvent) {
            var KC    = Siesta.Test.Simulate.KeyCodes().keys;
            var isMac = navigator.platform.indexOf('Mac') > -1;

            // CTRL-A or CMD-A in text input should select all
            return ((!isMac && keyDownEvent.ctrlKey) || (keyDownEvent.metaKey && isMac) &&
                KC["A"] === keyDownEvent.keyCode && this.isTextInput(keyDownEvent.target));
        },

        mimicClickOnEnter : function(el, keyCode) {
            // somehow "node.nodeName" is empty sometimes in IE10
            var nodeName        = el.nodeName && el.nodeName.toLowerCase()
            var supports        = Siesta.Harness.Browser.FeatureSupport().supports
            var KeyCodes        = Siesta.Test.Simulate.KeyCodes().keys

            if ((nodeName == 'a' || nodeName == 'button') && keyCode === KeyCodes.ENTER && !supports.enterOnAnchorTriggersClick) {
                // this "click" should not update the current cursor position its merely for activating "click" listeners
                this.simulateEvent(el, 'click', { doNotUpdateCurrentPosition : true }, true);
            }
        }
    }
});


;
/**
 @class Siesta.Test.Simulate.Event

 This is a mixin providing events simulation functionality.

 */

Role('Siesta.Test.Simulate.Event', {

    requires : [
        'createTextEvent',
        'createMouseEvent',
        'createKeyboardEvent'
    ],

    has : {
        actionDelay      : 100,
        afterActionDelay : 100,

        /**
         * @cfg {String} simulateEventsWith
         *
         * This option is IE9-strict mode (and probably above) specific. It specifies, which events simulation function Siesta should use.
         * The choice is between 'dispatchEvent' (W3C standard) and 'fireEvent' (MS interface) - both are available in IE9 strict mode
         * and both activates different event listeners. See this blog post for detailed explanations:
         * <http://www.digitalenginesoftware.com/blog/archives/76-DOM-Event-Model-Compatibility-or-Why-fireEvent-Doesnt-Trigger-addEventListener.html>
         *
         * Valid values are "dispatchEvent" and "fireEvent".
         *
         * The framework specific adapters choose the most appropriate value automatically (unless explicitly configured).
         */
        simulateEventsWith : {
            is   : 'rw',
            init : 'dispatchEvent'
        }
    },

    methods : {

        processMouseEventName : function (eventName) {
            return eventName
        },


        /**
         * This method will simulate an event triggered by the passed element. If no coordinates are supplied in the options object, the center of the element
         * will be used.
         * @param {Siesta.Test.ActionTarget} el
         * @param {String} type The type of event (e.g. 'mouseover', 'click', 'keypress')
         * @param {Object} the options for the event. See http://developer.mozilla.org/en/DOM/event for reference.
         * @param {Boolean} suppressLog true to not include this simulated event in the assertion grid.
         */
        simulateEvent : function (el, type, options, suppressLog) {
            var global = this.global;
            options    = options || {};

            if (this.typeOf(el) == 'Array') {
                if (!('clientX' in options)) {
                    options.clientX = el[0];
                }

                if (!('clientY' in options)) {
                    options.clientY = el[1];
                }
            }

            el = this.normalizeElement(el);

            var touchEvent
            var processed = this.processMouseEventName(type)

            // simulate extra touch event 1st - for touch enabled browsers, like IE10, 11 
            if (processed != type) {
                touchEvent = this.createEvent(processed, options, el);

                touchEvent.synthetic = true;

                this.dispatchEvent(el, processed, touchEvent);
            }

            var evt = this.createEvent(type, options, el);


            if (evt) {
                this.mimicBrowserBehaviorBefore(evt, type, el);

                evt.synthetic = true;
                this.dispatchEvent(el, type, evt);

                // Let the outside world know that an event was simulated
                if (!suppressLog) {
                    this.fireEvent('eventsimulated', this, el, type, evt);
                }

                !this.isEventPrevented(evt) && this.mimicBrowserBehaviorAfter(evt, type, el);
            }

            // touch event is considered to be "main" for IE10, 11 cause ExtJS listens mostly those
            // and cancel flag will be returned in touch event..
            return touchEvent || evt;
        },

        createEvent : function (type, options, el) {
            var event

            if (/^textinput$/i.test(type)) {
                event = this.createTextEvent(type, options, el);
            } else if (/^mouse(over|out|down|up|move|enter|leave)|contextmenu|(dbl)?click$/.test(type) || /^(ms)?pointer/i.test(type)) {
                event = this.createMouseEvent(type, options, el);
            } else if (/^key(up|down|press)$/.test(type)) {
                event = this.createKeyboardEvent(type, options, el);
            } /*else if (/^touch/.test(type)) {
             return this.createTouchEvent(type, options, el);
             }*/
            else if (/^change$|^input$|^submit/.test(type)) {
                event = this.createGenericEvent(type, options, el);
            }
            else
                event = this.createHtmlEvent(type, options, el);

            // IE>=9 somehow reports that "defaultPrevented" property of the event object is `false`
            // even that "preventDefault()" has been called on the object
            // more over, immediately after call to "preventDefault()" the property is updated
            // but down in stack it is replaced with "false" again somehow
            // we setup our own, additional property, indicating that event has been prevented
            if (event && $.browser.msie && Number($.browser.version) >= 9) {
                var prev = event.preventDefault

                event.preventDefault = function () {
                    arguments.callee.$prevented = true;
                    this.returnValue = false

                    return prev && prev.apply(this, arguments)
                }
            }

            return event
        },


        createGenericEvent : function (type, options, el) {
            var doc = el.ownerDocument;

            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                var evt = doc.createEvent("Events");
                evt.initEvent(type, true, true);
                return evt;
            } else if (doc.createEventObject) {
                return doc.createEventObject();
            }
        },

        createHtmlEvent : function (type, options, el) {
            var doc = el.ownerDocument;

            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                var evt = doc.createEvent("HTMLEvents");
                evt.initEvent(type, false, false);
                return evt;
            } else if (doc.createEventObject) {
                return doc.createEventObject();
            }
        },

        dispatchEvent : function (el, type, evt) {

            // use W3C standard when available and allowed by "simulateEventsWith" option            
            if (el.dispatchEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                el.dispatchEvent(evt);
            } else if (el.fireEvent) {
                // IE 6,7,8 can't dispatch many events cleanly - throws exceptions
                try {
                    // this is the serios nominant to the best-IE-bug-ever prize and it's IE7 specific
                    // accessing the "scrollLeft" property on document or body triggers a synchronous(!) "resize" event on the window
                    // ExtJS uses a singleton for Ext.EventObj and its "target" property gets overwritten with "null"
                    // thus consequent event handlers fails
                    // doing an access to that property to cache it
                    var doc  = this.global.document.documentElement;
                    var body = this.global.document.body;

                    var xxx = doc && doc.scrollLeft || body && body.scrollLeft || 0;

                    el.fireEvent('on' + type, evt);
                } catch (e) {
                }
            } else
                throw "Can't dispatch event: " + type

            return evt;
        },

        mimicBrowserBehaviorBefore : function (event, type, target) {
        },

        mimicBrowserBehaviorAfter : function (event, type, target) {
            var tagName = target.tagName.toLowerCase();

            switch (type) {
                case 'mousedown':
                    if (this.isTextInput(target)) {
                        this.mimicClearTextSelection(target);
                    }
                    break;
                case 'click':
                    if ($.browser.msie &&
                        Number(/^(\d+)/.exec($.browser.version)[1]) < 11 &&
                        tagName === 'a' &&
                        target.getAttribute("href")) {
                        this.mimicHashUpdate(target);
                    } else if (tagName === 'option' && !target.getAttribute('disabled')) {
                        this.mimicOptionSelect(target);
                    }
                    break;
                case 'dblclick':
                    if (this.isTextInput(target)) {
                        this.mimicTextSelection(target);
                    }
                    break;
                case 'keydown':
                    var KeyCodes = Siesta.Test.Simulate.KeyCodes().keys

                    if (event.keyCode === KeyCodes.BACKSPACE) {
                        this.mimicHistoryChangeAfterBackspace(event, target);
                    }
                    break;
            }
        },

        // IE9+
        // Breaks IE9 with Ext JS 5.1.0, tested in .540_extjs_type.t.js?5.1.0
        mimicClearTextSelection : function (target) {
            var extVersion = this.global.Ext && this.global.Ext.versions;
            var isExtJS51  = extVersion && extVersion.extjs && extVersion.extjs.equals('5.1.0.107');

            if (!$.browser.msie || !isExtJS51 || ($.browser.version !== "9.0" && $.browser.version !== "8.0")) {
                this.selectText(target, target.value.length - 1, target.value.length);

                this.setCaretPosition(target, target.value.length);
            }
        },

        mimicTextSelection : function (target) {
            this.selectText(target);
        },

        // After a click action in old IE, change location hash manually
        mimicHashUpdate : function (el) {
            var href = el.getAttribute("href").match(/#(.*)/);

            if (href) {
                this.global.location.hash = href[1];
            }
        },

        mimicHistoryChangeAfterBackspace : function (event, target) {
            if ($.browser.safari) return;

            var doc      = target.ownerDocument;

            if (target.getAttribute('contenteditable') !== "true" && doc.designMode.toLowerCase() !== "on" && !this.isTextInput(target)) {
                var elWindow = target.ownerDocument.defaultView || target.ownerDocument.parentWindow;

                if (event.shiftKey) {
                    this.mimicNextHistory(elWindow);
                } else {
                    this.mimicPreviousHistory(elWindow);
                }
            }
        },

        mimicPreviousHistory : function (global) {
            global.history.back();
        },

        mimicNextHistory : function (global) {
            global.history.forward();
        },

        mimicOptionSelect : function (optionNode) {
            var select   = this.$(optionNode).closest('select')[0];
            var oldValue = select.value;

            select.value = optionNode.value;

            if (oldValue !== optionNode.value) {
                this.simulateEvent(select, "change");
            }
        }
    }
});
;
/**
@class Siesta.Test.Simulate.Touch

This is a mixin, providing the touch events simulation functionality.
*/
Role('Siesta.Test.Simulate.Touch', {
    
    requires        : [ 
        'normalizeElement' 
    ],    
    
    has: {
        touchEventNamesMap  : {
            lazy        : 'this.buildTouchEventNamesMap'
        },
        
        currentTouchId  : 1,
        
        activeTouches   : Joose.I.Object,
        
        notSupportedWarned  : false
    },
    
    
    methods: {
        
        checkTouchEventsSupport : function () {
            var supports        = Siesta.Harness.Browser.FeatureSupport().supports
            
            var root            = this.getRootTest()
            
            if (!supports.TouchEvents && !supports.PointerEvents && !supports.MSPointerEvents && !root.notSupportedWarned) {
                root.notSupportedWarned = true
                
                this.warn("Touch events are not supported by browser. For Chrome, you can enable them, by launching it with: --args --touch-events")
            }
        },
        
        /**
         * This method taps the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         * 
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        tap : function (target, callback, scope, options, offset) {
            this.checkTouchEventsSupport()
            
            var me      = this;
            var context = this.getNormalizedTopElementInfo(target, true, 'tap', offset);

            if (!context) {
                this.waitForTarget(target, function() {
                    this.tap(target, callback, scope, offset);
                }, this, null, offset);

                return;
            }
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : callback ? 30 : 0,
                
                observeTest     : this
            })
            
            var id
            
            queue.addStep({ 
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                } 
            })
            queue.addStep({ 
                processor : function () {
                    me.touchEnd(id, options)
                } 
            })

            var async   = me.beginAsync();
            
            queue.run(function () {
                me.endAsync(async);
                
                me.processCallbackFromTest(callback, null, scope || me)
            })
        },
        
        
        /**
         * This method double taps the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         * 
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        doubleTap : function (target, callback, scope, options, offset) {
            this.checkTouchEventsSupport()
            
            var me      = this;
            var context = this.getNormalizedTopElementInfo(target, true, 'doubleTap', offset);

            if (!context) {
                this.waitForTarget(target, function() {
                    this.doubleTap(target, callback, scope, offset);
                }, this, null, offset);

                return;
            }
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : callback ? 30 : 0,
                
                observeTest     : this
            })
            
            var id
            
            queue.addStep({ 
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                } 
            })
            queue.addStep({ 
                processor : function () {
                    me.touchEnd(id, options)
                } 
            })
            queue.addStep({ 
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                } 
            })
            queue.addStep({ 
                processor : function () {
                    me.touchEnd(id, options)
                } 
            })

            var async   = me.beginAsync();
            
            queue.run(function () {
                me.endAsync(async);
                
                me.processCallbackFromTest(callback, null, scope || me)
            })
        },
        
        
        getLongPressDelay : function () {
            return 1500
        },
        
        
        // backward-compat with SenchaTouch class, which used to have all lower-cased method
        longpress : function () {
            return this.longPress.apply(this, arguments)
        },
        
        
        /**
         * This performs a long press on the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         * 
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        longPress : function (target, callback, scope, options, offset) {
            this.checkTouchEventsSupport()
            
            var me      = this;
            var context = this.getNormalizedTopElementInfo(target, true, 'longPress', offset);

            if (!context) {
                this.waitForTarget(target, function() {
                    this.longPress(target, callback, scope, offset);
                }, this, null, offset);

                return;
            }
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : callback ? 30 : 0,
                
                observeTest     : this
            })
            
            var id
            
            queue.addStep({ 
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                } 
            })
            queue.addDelayStep(this.getLongPressDelay())
            queue.addStep({ 
                processor : function () {
                    me.touchEnd(id, options)
                } 
            })

            var async   = me.beginAsync();
            
            queue.run(function () {
                me.endAsync(async);
                
                me.processCallbackFromTest(callback, null, scope || me)
            })
        },
        
        
        /**
         * This method performs a pinch between the two specified points. It draws a line between the specified points and then moves 2 touches along that line,
         * so that the final distance between the touches becomes `scale * original distance`.
         * 
         * This method can be called either in the full form with 2 different targets:
         * 

    t.pinch("#grid > .col1", "#grid > .col2", 3, function () { ... })
    
         * or, in the short form, where the 2nd target argument is omitted:
         * 

    t.pinch("#grid > .col1", 3, function () { ... })
    
         * In the latter form, `target2` is considered to be the same as `target1`.
         * 
         * If `target1` and `target2` are the same, and no offsets are provided, offsets are set to the following values:
         * 
    
    offset1     = [ '25%', '50%' ]
    offset2     = [ '75%', '50%' ]

         * 
         * 
         * @param {Siesta.Test.ActionTarget} target1 First point for pinch
         * @param {Siesta.Test.ActionTarget} target2 Second point for pinch. Can be omitted, in this case both points will belong to `target1`
         * @param {Number} scale The multiplier for a final distance between the points
         * @param {Function} callback A function to call after the pinch has completed
         * @param {Object} scope A scope for the `callback`
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Array} offset1 An X,Y offset relative to the target1. Example: [20, 20] for 20px or ["50%", "100%-2"] 
         * for the point in the center horizontally and 2px from the bottom edge.
         * @param {Array} offset2 An X,Y offset relative to the target1. Example: [20, 20] for 20px or ["50%", "100%-2"] 
         * for the point in the center horizontally and 2px from the bottom edge.
         */
        pinch : function (target1, target2, scale, callback, scope, options, offset1, offset2) {
            this.checkTouchEventsSupport()
            
            var me          = this;
            
            if (this.typeOf(target2) == 'Number') {
                offset2     = offset1
                offset1     = options
                options     = scope
                scope       = callback
                callback    = scale
                scale       = target2
                target2     = target1
            }
            
            if (target2 == null) target2 = target1
            
            if (target1 == target2 && !offset1 && !offset2) {
                offset1     = [ '25%', '50%' ]
                offset2     = [ '75%', '50%' ]
            }
            
            var context1    = this.getNormalizedTopElementInfo(target1, true, 'pinch: target1', offset1);
            var context2    = this.getNormalizedTopElementInfo(target2, true, 'pinch: target2', offset2);

            if (!context1 || !context2) {
                var R  = Siesta.Resource('Siesta.Test.Browser');
                
                this.waitFor({
                    method          : function () { 
                        var el1     = me.normalizeElement(target1, true)
                        var el2     = me.normalizeElement(target2, true)
                        
                        return el1 && me.elementIsTop(el1, true, offset) && el2 && me.elementIsTop(el2, true, offset)
                    },
                    callback        : function () {
                        me.pinch(target1, target2, scope, callback, scope, options, offset1, offset2)
                    },
                    assertionName   : 'waitForTarget',
                    description     : ' ' + R.get('target') + ' "' + target1 + '" and "' + target2 + '" ' + R.get('toAppear')
                });                

                return
            }
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : callback ? 30 : 0,
                
                observeTest     : this
            })
            
            var id1, id2
            
            var dx          = context1.localXY[ 0 ] - context2.localXY[ 0 ]
            var dy          = context1.localXY[ 1 ] - context2.localXY[ 1 ]
            
            var distance    = Math.sqrt(dx * dx + dy * dy)
            
            if (distance < 1) distance = 1
            
            var scaled      = distance * scale
            var delta       = (scaled - distance) / 2
            
            var angle       = Math.atan(dy / dx)
            
            var x1          = Math.round(context1.localXY[ 0 ] - delta * Math.cos(angle))
            var y1          = Math.round(context1.localXY[ 1 ] - delta * Math.sin(angle))
            
            var x2          = Math.round(context2.localXY[ 0 ] + delta * Math.cos(angle))
            var y2          = Math.round(context2.localXY[ 1 ] + delta * Math.sin(angle))
            
            var options2    = Joose.O.extend({}, options)
            
            queue.addStep({ 
                processor : function () {
                    id1     = me.touchStart(null, null, options, context1)
                    id2     = me.touchStart(null, null, options2, context2)
                } 
            })
            queue.addAsyncStep({ 
                processor : function (data) {
                    var move1Done   = false
                    var move2Done   = false
                    
                    me.touchMove(id1, x1, y1, function () {
                        move1Done       = true
                        
                        if (move1Done && move2Done) data.next()
                    }, null, options)
                    
                    me.touchMove(id2, x2, y2, function () {
                        move2Done       = true
                        
                        if (move1Done && move2Done) data.next()
                    }, null, options2)
                } 
            })
            queue.addStep({ 
                processor : function () {
                    me.touchEnd(id1, options)
                    me.touchEnd(id2, options2)
                } 
            })

            var async   = me.beginAsync();
            
            queue.run(function () {
                me.endAsync(async);
                
                me.processCallbackFromTest(callback, null, scope || me)
            })
        },
        
        
        simulateTouchDrag : function (sourceXY, targetXY, callback, scope, options, dragOnly) {
            this.checkTouchEventsSupport()
            
            var me          = this
            options         = options || {};

            // For drag operations we should always use the top level document.elementFromPoint
            var source      = me.elementFromPoint(sourceXY[ 0 ], sourceXY[ 1 ], true);
            var target      = me.elementFromPoint(targetXY[ 0 ], targetXY[ 1 ], true);
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : me.dragDelay,
                callbackDelay   : me.afterActionDelay,
                
                observeTest     : this
            });
            
            var id
            
            queue.addStep({
                processor : function () {
                    id      = me.touchStart(sourceXY, null, options)
                } 
            })
            queue.addAsyncStep({ 
                processor : function (data) {
                    me.touchMove(id, targetXY[ 0 ], targetXY[ 1 ], data.next, null, options)
                } 
            })
            queue.addStep({ 
                processor : function () {
                    // if `dragOnly` flag is set, do not finalize the touch, instead, pass the touch id
                    // to the user in the callback (see below)
                    if (!dragOnly) me.touchEnd(id, options)
                } 
            })

            var async   = me.beginAsync();
            
            queue.run(function () {
                me.endAsync(async);
                
                // if `dragOnly` flag is set pass the touch id to the user as the argument of the callback
                me.processCallbackFromTest(callback, [ dragOnly ? id : null ], scope || me)
            })
        },
        
        
        /**
         * This method will simulate a drag and drop operation between either two points or two DOM elements.
         *   
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value for the drag starting point
         * @param {Siesta.Test.ActionTarget} target {@link Siesta.Test.ActionTarget} value for the drag end point
         * @param {Function} callback A function to call after the drag operation is completed.
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} sourceOffset (optional) An X,Y offset relative to the source. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @param {Array} targetOffset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        touchDragTo : function (source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset) {
            var me          = this
            var context1    = this.getNormalizedTopElementInfo(source, true, 'touchDragTo: source', sourceOffset);
            var context2    = this.getNormalizedTopElementInfo(target, true, 'touchDragTo: target', targetOffset);

            if (!context1 || !context2) {
                var R  = Siesta.Resource('Siesta.Test.Browser');
                
                this.waitFor({
                    method          : function () { 
                        var el1     = me.normalizeElement(source, true)
                        var el2     = me.normalizeElement(target, true)
                        
                        return el1 && me.elementIsTop(el1, true, sourceOffset) && el2 && me.elementIsTop(el2, true, targetOffset)
                    },
                    callback        : function () {
                        me.touchDragTo(source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset)
                    },
                    assertionName   : 'waitForTarget',
                    description     : ' ' + R.get('target') + ' "' + source + '" and "' + target + '" ' + R.get('toAppear')
                });                

                return
            }
            
            this.simulateTouchDrag(context1.localXY, context2.localXY, callback, scope, options, dragOnly)
        },
        
        
        /**
         * This method will simulate a drag and drop operation from a point (or DOM element) and move by a delta.
         *   
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value as the drag starting point
         * @param {Array} delta The amount to drag from the source coordinate, expressed as [ x, y ]. E.g. [ 50, 10 ] will drag 50px to the right and 10px down.
         * @param {Function} callback A function to call after the drag operation is completed.
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        touchDragBy : function (source, delta, callback, scope, options, dragOnly, offset) {
            var me      = this;
            var context = this.getNormalizedTopElementInfo(source, true, 'touchDragBy', offset);

            if (!context) {
                this.waitForTarget(source, function() {
                    this.touchDragBy(source, delta, callback, scope, options, dragOnly, offset)
                }, this, null, offset)

                return
            }
            
            var sourceXY        = context.globalXY;
            var targetXY        = [ sourceXY[ 0 ] + delta[ 0 ], sourceXY[ 1 ] + delta[ 1 ] ];
            
            this.simulateTouchDrag(sourceXY, targetXY, callback, scope, options, dragOnly)
        },
        
        
        /**
         * This method will simulate a swipe operation between either two points or on a single DOM element.
         *   
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {String} direction Either 'left', 'right', 'up' or 'down'
         * @param {Function} callback A function to call after the swing operation is completed
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options (optional) Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        swipe : function (target, direction, callback, scope, options) {
            this.checkTouchEventsSupport()
            
            target      = this.normalizeElement(target, true);

            if (!target) {
                this.waitForTarget(target, function() {
                    this.swipe(target, direction, callback, scope, options)
                }, this)

                return
            }

            var Ext     = this.Ext()
            var R       = Siesta.Resource('Siesta.Test.SenchaTouch')
    
            var box     = Ext.fly(target).getBox(),
                start,
                end,
                edgeOffsetRatio = 10;
            
            // Since this method accepts elements as target, we need to assure that we swipe at least about 150px
            // using Math.max below etc

            switch(direction) {
                case 'u':
                case 'up':
                    start       = [ box.x + box.width / 2, (box.y + box.height * 9 / edgeOffsetRatio)];
                    end         = [ box.x + box.width / 2, box.y + box.height / edgeOffsetRatio]; 
                    
                    end[ 1 ]    = Math.min(start[ 1 ] - 100, end[ 1 ]);
                break;

                case 'd':
                case 'down':
                    start       = [ box.x + box.width / 2, (box.y + box.height / edgeOffsetRatio)]; 
                    end         = [ box.x + box.width / 2, (box.y + box.height * 9 / edgeOffsetRatio)];

                    end[ 1 ]    = Math.max(start[ 1 ] + 100, end[ 1 ]);
                break;

                case 'r':
                case 'right':
                    start       = [box.x + (box.width / edgeOffsetRatio), (box.y + box.height / 2) ]; 
                    end         = [box.x + (box.width * 9 / edgeOffsetRatio), (box.y + box.height / 2) ];
                    
                    end[ 0 ]    = Math.max(start[ 0 ] + 100, end[ 0 ]);
                break;

                case 'l':
                case 'left':
                    start       = [box.x + (box.width * 9 / edgeOffsetRatio), (box.y + box.height / 2) ];
                    end         = [box.x + (box.width / edgeOffsetRatio), (box.y + box.height / 2) ]; 
                    
                    end[ 0 ]    = Math.min(start[ 0 ] - 100, end[ 0 ]);
                break;

                default: 
                    throw R.get('invalidSwipeDir') + ': ' + direction;
            }

            this.touchDragTo(start, end, callback, scope, options);
        },
        
        
        touchStart : function (target, offset, options, context) {
            if (!context) context = this.getNormalizedTopElementInfo(target, true, 'touchStart', offset)
            
            options         = Joose.O.extend({
                clientX     : context.localXY[ 0 ],
                clientY     : context.localXY[ 1 ]
            }, options || {})
            
            var event       = this.simulateTouchEventGeneric(context.el, 'start', options)
            
            return event.pointerId || event.changedTouches[ 0 ].identifier
        },
        
        
        touchEnd : function (touchId, options) {
            var touch       = this.activeTouches[ touchId ]
            
            if (!touch) throw "Can't find active touch: " + touchId
            
            options         = Joose.O.extend({
                clientX     : touch.clientX,
                clientY     : touch.clientY
            }, options || {})
            
            this.simulateTouchEventGeneric(touch.currentEl || touch.target, 'end', options, { touchId : touchId })
        },
        
        
        touchMove : function (touchId, toX, toY, callback, scope, options) {
            var touch       = this.activeTouches[ touchId ]
            
            if (!touch) throw "Can't find active touch: " + touchId
            
            var me          = this
            var overEls     = []
            
            this.movePointerTemplate({
                xy              : [ touch.clientX, touch.clientY ],
                xy2             : [ toX, toY ],
                callback        : callback,
                scope           : scope,
                options         : options || {},
                
                overEls         : overEls,
                interval        : this.dragDelay,
                callbackDelay   : me.afterActionDelay,
                pathBatchSize   : me.pathBatchSize,
                
                onVoidOverEls   : function () {
                    return overEls = []
                },
                
                onPointerEnter  : function (el, options, suppressLog) {
                },
                
                onPointerLeave  : function (el, options, suppressLog) {
                },
                
                onPointerOver   : function (el, options, suppressLog) {
                },
                
                onPointerOut    : function (el, options, suppressLog) {
                },
                
                onPointerMove   : function (el, options, suppressLog) {
                    touch.clientX       = options.clientX
                    touch.clientY       = options.clientY
                    
                    // TODO should take scrolling into account
                    touch.pageX         = options.clientX
                    touch.pageY         = options.clientY
                    
                    touch.currentEl     = el
                    
                    me.simulateTouchEventGeneric(el, 'move', options, { touchId : touchId })
                }
            })
        },
        

        // never used yet, should be called when touchMove goes out of the document
        touchCancel : function (touchId, options) {
            var touch       = this.activeTouches[ touchId ]
            
            if (!touch) throw "Can't find active touch: " + touchId
            
            this.simulateTouchEventGeneric(touch.currentEl || touch.target, 'cancel', options, { touchId : touchId })
        },
        
        
        simulatePointerEvent : function (target, type, options, simOptions) {
            var supports    = Siesta.Harness.Browser.FeatureSupport().supports
            
            options         = options || {}
            
            var doc         = this.global.document,
                event       = doc.createEvent(
                    supports.PointerEvents ? 'PointerEvent' : supports.MSPointerEvents ? 'MSPointerEvent' : 'MouseEvents'
                ),
                target      = this.normalizeElement(target)
                
            if (!target) return false
            
            var clientX, clientY
            
            if (/pointerdown$/i.test(type) && (!("clientX" in options) || !("clientY" in options))) {
                var center  = this.findCenter(target);

                options     = Joose.O.extend({
                    clientX     : center[ 0 ],
                    clientY     : center[ 1 ]
                }, options)
            } else
            
            event[ (supports.MSPointerEvents || supports.PointerEvents) ? 'initPointerEvent' : 'initMouseEvent' ](
                type, true, true, this.global, options.detail,
                options.screenX, options.screenY, options.clientX, options.clientY,
                options.ctrlKey || false, options.altKey || false, options.shiftKey || false, options.metaKey || false,
                options.button, options.relatedTarget || doc.documentElement,
                // the following extra args are used in the "initPointerEvent"
                // offsetX, offsetY
                null, null,
                // width, height
                null, null,
                // pressure, rotation
                null, null,
                // tiltX, tiltY
                null, null,
                // pointerId
                simOptions.touchId || this.currentTouchId++,
                // pointerType
                // NOTE: this has to be set to "mouse" (IE11) or 4 (IE10, 11) because otherwise
                // ExtJS5 blocks the event
                // need to investigate what happens in SenchaTouch
                4,//'mouse',
                // timestamp, isPrimary
                null, null
            );
            
            if (!(supports.MSPointerEvents || supports.PointerEvents)) {
                event.pointerId = simOptions.touchId || this.currentTouchId++
            }
            
            target.dispatchEvent(event)
        
            return event
        },
        
        
        simulateTouchEvent : function (target, type, options, simOptions) {
            options         = options || {}
            var global      = this.global
            var doc         = global.document
            
            var event       = new global.CustomEvent(type, {
                bubbles     : true,
                cancelable  : true
            })
                
            var target      = this.normalizeElement(target)
            
            var clientX, clientY 
            
            if (("clientX" in options) && ("clientY" in options)) {
                clientX     = options.clientX
                clientY     = options.clientY
            } else {
                var center  = this.findCenter(target);

                clientX     = center[ 0 ]
                clientY     = center[ 1 ]
            }
            
            var activeTouches   = this.activeTouches
            var touch           = simOptions.touch
            var touches         = []
            var targetTouches   = []
            
            for (var id in activeTouches) {
                var currentTouch    = activeTouches[ id ]
                
                touches.push(currentTouch)
                if (currentTouch.target == target) targetTouches.push(currentTouch)
            }
            
            Joose.O.extend(event, {
                target          : target,
                
                changedTouches  : this.createTouchList([ touch ]),
                
                touches         : this.createTouchList(touches),
                targetTouches   : this.createTouchList(targetTouches),
                
                altKey          : options.altKey,
                metaKey         : options.metaKey,
                ctrlKey         : options.ctrlKey,
                shiftKey        : options.shiftKey
            });
        
            target.dispatchEvent(event)
            
            return event
        },
        
        
        createTouchList : function  (touchList) {
            var doc         = this.global.document
            
            // a branch for browsers supporting "createTouch/createTouchList"
            if (doc.createTouch) {
                var touches = [];
        
                for (var i = 0; i < touchList.length; i++) {
                    var touchCfg    = touchList[ i ];
                    
                    touches.push(doc.createTouch(
                        doc.defaultView || doc.parentWindow,
                        touchCfg.target,
                        touchCfg.identifier || this.currentTouchId++,
                        touchCfg.pageX,
                        touchCfg.pageY,
                        touchCfg.screenX || touchCfg.pageX,
                        touchCfg.screenY || touchCfg.pageY,
                        touchCfg.clientX,
                        touchCfg.clientY
                    ))
                }
            
                return doc.createTouchList.apply(doc, touches);
            } else
                return touchList
        },
        
    
        createTouch: function (target, clientX, clientY) {
            return {
                identifier  : this.currentTouchId++,
                target      : target,
                
                clientX     : clientX,
                clientY     : clientY,
                
                screenX     : 0,
                screenY     : 0,
             
                // TODO should take scrolling into account
                pageX       : clientX,
                pageY       : clientY
            }
        },
    
    
        buildTouchEventNamesMap : function () {
            var supports        = Siesta.Harness.Browser.FeatureSupport().supports
            
            return supports.PointerEvents ?
                {
                    start   : 'pointerdown',
                    move    : 'pointermove',
                    end     : 'pointerup',
                    cancel  : 'pointercancel'
                }
                : supports.MSPointerEvents ?
                {
                    start   : 'MSPointerDown',
                    move    : 'MSPointerMove',
                    end     : 'MSPointerUp',
                    cancel  : 'MSPointerCancel'
                }
                : /*supports.TouchEvents ?*/
                {
                    start   : 'touchstart',
                    move    : 'touchmove',
                    end     : 'touchend',
                    cancel  : 'touchcancel'
                }
//                :
//                // todo: fire mouseevents?
//                (function () { throw "Touch events not supported" })()
        },
        
        
        simulateTouchEventGeneric : function (target, type, options, simOptions) {
            simOptions      = simOptions || {}
            
            var target      = this.normalizeElement(target)
            
            var clientX, clientY 
            
            if (("clientX" in options) && ("clientY" in options)) {
                clientX     = options.clientX
                clientY     = options.clientY
            } else {
                var center  = this.findCenter(target);

                clientX     = center[ 0 ]
                clientY     = center[ 1 ]
            }
            
            var activeTouches   = this.activeTouches
            var touch
            
            if (type === 'end' || type === 'cancel') {
                touch       = activeTouches[ simOptions.touchId ]
                
                target      = touch.currentEl || touch.target
                
                delete activeTouches[ simOptions.touchId ]
            } else if (type == 'start') {
                touch       = this.createTouch(target, clientX, clientY)
                
                activeTouches[ touch.identifier ] = touch
                
            } else if (type == 'move') {
                touch           = activeTouches[ simOptions.touchId ]
                
                // "*move" events should be fired only from the "movePointerTemplate" method
                // which provides the "clientX/clientY" properties
                touch.clientX   = options.clientX
                touch.clientY   = options.clientY
            }
            
            if (!touch) throw "Can't find active touch" + (simOptions.touchId ? ': ' + simOptions.touchId : '')
            
            if (!simOptions.touchId) simOptions.touchId = touch.identifier
            
            simOptions.touch    = touch
            
            var eventType       = this.getTouchEventNamesMap()[ type ]
            var supports        = Siesta.Harness.Browser.FeatureSupport().supports
            
            if (supports.PointerEvents || supports.MSPointerEvents) {
                return this.simulatePointerEvent(target, eventType, options, simOptions)
            } else /*if (supports.TouchEvents)*/ {
                return this.simulateTouchEvent(target, eventType, options, simOptions);
            }
//            } else {
//                // TODO fallback to mouse events?
//                throw "Can't simulate any type of touch events"
//            }
        }
    }
});


//////////////////////////  Code copied from ExtJS:

// parts from 
// SDK/packages/sencha-core/test/resources/helpers.js

// parts from 
// SDK/ext/examples/desktop/.sencha/test/jasmine.js;
/**

@class Siesta.Test.ExtJSCore

A base mixin for testing Ext JS and Sencha Touch applications.

Contains testing functionality that is common for both frameworks.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

*/
Role('Siesta.Test.ExtJSCore', {
    
    has : {
        waitForExtReady         : true,
        waitForAppReady         : false,
        
        waitForExtComponentQueryReady   : true,
        
        loaderPath              : null,
        requires                : null,
        
        simulateEventsWith      : {
            is      : 'rw',
            lazy    : function () {
                var isIE9           = navigator.userAgent.match(/MSIE 9.0;/)
                var Ext             = this.getExt()

                // no Ext or Ext3 should use standard "dispatchEvent" method
                if (!Ext || !Ext.getVersion) return 'dispatchEvent'
                
                var extVersion      = Ext.getVersion('extjs')
                
                // the "Ext.getVersion('extjs')" is just "true" in Ext3? (when testing SA)
                var isBelowExt421   = Boolean((extVersion && extVersion.isLessThan && extVersion.isLessThan('4.2.1.883')))
                
                var div             = document.createElement('div')
                
                return div.attachEvent && (isIE9 || isBelowExt421) ? 'fireEvent' : 'dispatchEvent'
            }
        },
        
        eventMap                : {
            is              : 'rw',
            lazy            : function () {
                var Ext             = this.getExt()
                
                if (!Ext || !Ext.dom || !Ext.dom.Element || !Ext.dom.Element.prototype.eventMap) return null
                
                // need to create copy! to not store the value from another context on a test instance
                return Joose.O.copy(Ext.dom.Element.prototype.eventMap)
            }
        },
        
        isExtOnReadyDone        : false,
        onReadyWaitingStarted   : false,
        isAppReadyDone          : false,
        
        requiringWaitingStarted : false,
        isRequiringDone         : false,
        
        modelsDefinedInPreload  : Joose.I.Object
    },

    override : {
        
        onTestStart : function () {
            var me                  = this
            var sharedSandboxState  = this.sharedSandboxState
            
            if (!this.reusingSandbox && sharedSandboxState) {
                if (!sharedSandboxState.modelsDefinedInPreload) sharedSandboxState.modelsDefinedInPreload = {}
                
                this.forEachModelInAllSchemas(function (entity, entityName, className, schema) {
                    sharedSandboxState.modelsDefinedInPreload[ className ] = true
                })
            }
        },
        
        
        // only called for the re-used contexts
        cleanupContextBeforeStartDom : function () {
            var Ext         = this.getExt()
            
            if (!Ext) return this.SUPER()
            
            var me          = this
            
            // if component query is present - try to unregister all components
            if (Ext.ComponentQuery) {
                var keep        = {}
                var msgBox      = Ext.MessageBox
                
                if (msgBox) {
                    keep[ msgBox.id ] = true
                }
                
                // retrieve the top-level components
                var comps       = Ext.ComponentQuery.query('{ownerCt == null}')
                
                // sort, so that containers goes first
                // the logic is, that containers have "more logic" and may affect components
                // use case - grid editing is active and the editor field is destroyed before the grid - 
                // that throws exception in gantt code
                
                comps.sort(function (a, b) {
                    a   = (a instanceof Ext.Container) ? 0 : 1
                    b   = (b instanceof Ext.Container) ? 0 : 1
                    
                    return a - b
                })
                
                Joose.A.each(comps, function (comp) {
                    if (!keep[ comp.id ] && !comp.isDestroyed) comp.destroy()
                })
            }
            
            // if there's a class manager - unregister "unexpected" classes
            if (Ext.ClassManager && Ext.undefine) {
                var index       = {}
                
                Joose.O.each(Ext.ClassManager.classes, function (cls, name) {
                    var global      = name.split('.')[ 0 ]
                    
                    if (!me.isGlobalExpected(global, index)) Ext.undefine(name)
                })
            }
            
            // if there's a store manager - also unregister stores (all stores except internal ext js store(s))
            if (Ext.data && Ext.data.StoreManager) {
                var toRemove = [];

                Ext.data.StoreManager.each(function(store) {
                    if (store.storeId !== "ext-empty-store") toRemove.push(store);
                });

                Ext.data.StoreManager.unregister.apply(Ext.data.StoreManager, toRemove);
            }
            
            var sharedSandboxState          = this.sharedSandboxState
            var modelsDefinedInPreload      = sharedSandboxState && sharedSandboxState.modelsDefinedInPreload
            
            me.forEachModelInAllSchemas(function (entity, entityName, className, schema) {
                if (!modelsDefinedInPreload[ className ]) {
                    Ext.undefine(className)
                    
                    // TODO also need to remove the associations
                    delete schema.entityClasses[ className ]
                    delete schema.entities[ entityName ]
                }
            })
        },
        
        
        processMouseEventName : function (eventName) {
            var eventMap        = this.getEventMap()
            
            return eventMap && eventMap[ eventName ] || eventName; 
        },
        
        
        processSubTestConfig : function () {
            var res                 = this.SUPERARG(arguments)
            
            // sub tests should not wait for Ext.onReady or for application launch
            res.waitForAppReady     = false
            res.waitForExtReady     = false 
            
            return res
        },
        
        
        isReady : function() {
            var result      = this.SUPERARG(arguments);

            if (!result.ready) return result;
            
            var me          = this
            var Ext         = this.getExt();
            var R           = Siesta.Resource('Siesta.Test.ExtJSCore');

            var requires    = this.requires
            
            if (requires && !this.requiringWaitingStarted && Ext && Ext.require) {
                this.requiringWaitingStarted    = true
                
                Ext.require(requires, function () {
                    me.isRequiringDone      = true
                })
            }
            
            if (this.waitForExtReady && !this.onReadyWaitingStarted && Ext && Ext.onReady) {
                this.onReadyWaitingStarted  = true
                
                Ext.onReady(function () {
                    me.isExtOnReadyDone     = true
                })
            }
            
            if (this.waitForExtComponentQueryReady && Ext && Ext.getVersion && !Ext.ComponentQuery) return {
                ready       : false,
                reason      : R.get('waitedForComponentQuery')
            }
            
            if (requires && !this.isRequiringDone) return {
                ready       : false,
                reason      : R.get('waitedForRequires')
            }

            if (this.waitForExtReady && !this.isExtOnReadyDone) return {
                ready       : false,
                reason      : R.get('waitedForExt')
            }
            
            if (this.waitForAppReady && !this.isAppReadyDone) return {
                ready       : false,
                reason      : R.get('waitedForApp')
            }
            
            if (Ext && Ext.ComponentQuery) {
                // add :root pseudo CQ selector to be able to identify 'root' level components that don't have
                // parent containers. value is 1-based
                Ext.ComponentQuery.pseudos.root = function(items, value) {
                    var i = 0, l = items.length, c, result = [];
                    var findAllRoots = value === undefined

                    if (!findAllRoots) {
                        value = Number(value) - 1;
                    }

                    // Gather root level components
                    for (; i < l; i++) {
                        c = items[i].up();
                        var hasParentContainer = c && c.contains && c.contains(items[i]);

                        if (!hasParentContainer) {
                            result.push(items[i]);
                        }
                    }

                    if (!findAllRoots) {
                        result = result[value] ? [result[value]] : [];
                    }

                    return result;
                };
            }
            
            return {
                ready       : true
            }
        },

        // Overridden to deal with the different event firing mechanisms in Ext JS 3 vs 4
        // This code is required because in IE events are simulated using fireEvent instead of dispatchEvent and it seems fireEvent will
        // will not update a checkbox 'checked' state properly so we're forcing the toggle to solve this situation. 
        // This issue is only relevant in IE + Ext. 
        //
        // Test case: 507_form_checkbox.t.js
        simulateMouseClick: function (clickInfo, callback, scope, options) {
            var el      = clickInfo.el
            var Ext     = this.getExt()
            
            var isExt5  = Ext && Ext.getVersion && Ext.getVersion('extjs') && Ext.getVersion('extjs').major == 5
            
            // Force check toggle for input checkboxes
            if (
                (this.getSimulateEventsWith() === 'fireEvent' || isExt5) 
                    && 
                (el.type === 'checkbox' || el.type === 'radio') && !el.disabled && !el.readOnly
            ) {
                var oldState = el.checked;
                
                if (callback) {
                    this.SUPER(clickInfo, function () {
                        if (el.checked === oldState) {
                            el.checked = !oldState;
                        }
                        callback.call(scope || this);
                    });
                } else {
                    this.SUPERARG(arguments);

                    if (el.checked === oldState) {
                        el.checked = !oldState;
                    }
                }
            } else {
                this.SUPERARG(arguments);
            }
        }
    },

    methods : {
        
        initialize : function() {
            // Since this test is preloading Ext JS, we should let Siesta know what to 'expect'
            this.expectGlobals('Ext', 'id');
            this.SUPER();
        },
        
        
        forEachModelInAllSchemas : function (func) {
            var Ext     = this.getExt()
            
            if (Ext && Ext.data && Ext.data.schema && Ext.data.schema.Schema && Ext.undefine) {
                Joose.O.each(Ext.data.schema.Schema.instances, function (schema, name) {
                    
                    schema.eachEntity(function (entityName) {
                        var entity  = schema.getEntity(entityName)
                        
                        func(entity, entityName, entity.$className, schema)
                    })
                })
            }
        },

        
        start : function (alreadyFailedWithException) {
            var me      = this;
            var Ext     = this.getExt();
            
            if (!Ext) {
                // proceed to parent implementation disabling our "can start" checkers 
                this.waitForAppReady    = false
                this.waitForExtReady    = false
                this.requires           = null
                
                this.SUPERARG(arguments)
                
                return
            }

            // install a "loader path hook" 
            this.harness.generateLoaderPathHook()(this.global.StartTest, Ext, this.loaderPath)
            
            // the actual waiting for Ext.onReady will happen inside of `isReady` method
            // this is because in microloaded touch apps, Ext.onReady may appear with some arbitrary delay

            
            // this flag will explain to Ext, that DOM ready event has already happened
            // Ext fails to set this flag if it was loaded dynamically, already after DOM ready
            // the test will start only after DOM ready anyway, so we just set this flag  
            Ext.isReady         = true

            var canWaitForApp   = Ext.ClassManager && Boolean(Ext.ClassManager.get('Ext.app.Application'))
            
            if (!canWaitForApp) this.waitForAppReady = false
                
            if (this.waitForAppReady && canWaitForApp)
                Ext.util.Observable.observe(Ext.app.Application, {
                    launch      : function () {
                        me.isAppReadyDone   = true
                    },
                    
                    single      : true,
                    delay       : 100
                })
            
            this.SUPERARG(arguments)
        },

        /**
         * This method returns the `Ext` object from the scope of the test. When creating your own assertions for Ext JS code, you need
         * to make sure you are using this method to get the `Ext` instance. Otherwise, you'll be using the same "top-level" `Ext`
         * instance, used by the harness for its UI. 
         * 
         * For example:
         * 
         *      elementHasProvidedCssClass : function (el, cls, desc) {
         *          var Ext     = this.getExt();
         *          
         *          if (Ext.fly(el).hasCls(cls)) {
         *              this.pass(desc);
         *          } else {
         *              this.fail(desc);
         *          }
         *      }
         *   
         * @return {Object} The `Ext` object from the scope of test
         */
        getExt : function () {
            return this.global.Ext
        },
        
        
        /**
         * The alias for {@link #getExt}
         * @method
         */
        Ext : function () {
            return this.global.Ext
        },
        
        
        isExtJSComponent : function (obj) {
            var Ext     = this.getExt()
            
            return Boolean(Ext && Ext.Component && obj instanceof Ext.Component)
        },
        
        // Accepts Ext.Component or ComponentQuery
        normalizeComponent : function(component, allowEmpty, options) {
            options         = options || {}
            var Ext         = this.Ext()
            
            var matchingMultiple    = false

            if (this.typeOf(component) === 'String') {
                // strip out leading >>  which is used as indicator of the ComponentQuery in ActionTarget string
                component   = this.trimString(component.replace(/^(\s*>>)?/, ''))
                
                var result  = Ext.ComponentQuery.query(component);
                var R       = Siesta.Resource('Siesta.Test.ExtJSCore');

                if (!allowEmpty && result.length < 1)   this.warn(R.get('noComponentMatch').replace('{component}', component));
                
                if (options.ignoreNonVisible) {
                    var onlyVisible = []
                    
                    // Sencha Touch components have no "isVisible()" method
                    Joose.A.each(result, function (cmp) { 
                        if (cmp.isVisible ? cmp.isVisible() : !cmp.isHidden()) onlyVisible.push(cmp) 
                    });
                    
                    result          = onlyVisible
                }
                
                if (result.length > 1)   {
                    matchingMultiple    = true
                    
                    var text        = R.get('multipleComponentMatch').replace('{component}', component);

                    if (this.harness.failOnMultipleComponentMatches) {
                        this.fail(text);
                    } else {
                        this.warn(text);
                    }
                }
                
                component = result[ 0 ];
            }
            
            return options.detailed ? { comp : component, matchingMultiple : matchingMultiple } : component
        },

        /**
         * @private
         * @param {Ext.Component} comp the Ext.Component
         * @param {Boolean} locateInputEl For form fields, try to find the inner input element by default.
         *                  If you want to target the containing Component element, pass false instead.
         * @return {*}
         */
        compToEl : function (comp, locateInputEl) {
            var Ext = this.Ext();

            if (!comp) return null

            locateInputEl = locateInputEl !== false;

            // Handle editors, deal with the field directly
            if (Ext.Editor && comp instanceof Ext.Editor && comp.field) {
                comp = comp.field;
            }

            // Ext JS
            if (Ext && Ext.form && Ext.form.Field && locateInputEl) {
                // Deal with bizarre markup in Ext 5.1.2+
                if (Ext.form.Checkbox && comp instanceof Ext.form.Checkbox ||
                    Ext.form.Radio && comp instanceof Ext.form.Radio) {
                    var displayEl = comp.displayEl;

                    if (displayEl && comp.boxLabel) {
                        return displayEl;
                    }
                    return comp.el.down('.x-form-field') || comp.inputEl;
                }

                if (comp instanceof Ext.form.Field && comp.inputEl) {
                    var field = comp.el.down('.x-form-field');

                    return (field && field.dom) || comp.inputEl.dom || comp.inputEl;
                }

                if (Ext.form.HtmlEditor && comp instanceof Ext.form.HtmlEditor) {
                    //     Ext JS 3       Ext JS 4
                    return comp.iframe || comp.inputEl;
                }
            }

            // Sencha Touch: Form fields can have a child input component
            if (Ext && Ext.field && Ext.field.Field && comp instanceof Ext.field.Field && locateInputEl) {
                comp = comp.getComponent();
            }

            //                      Ext JS   vs                    Sencha Touch
            return comp.getEl ? comp.getEl() : locateInputEl && comp.input || comp.el || comp.element;
        },

        // Accept Ext.Element and Ext.Component
        // If the 'shallow' flag is true we should not 'reevaluate' the target element - stop at the component element.
        normalizeElement : function(el, allowMissing, shallow, detailed, options) {
            if (!el)         return null

            if (el.nodeName) return el;

            var matchingMultiple = false
            var query   
            var Ext     = this.getExt();
            var origEl  = el;
            var scopeAdjusted;

            //var offset                      = options && options.offset
            var stopAtComponentLevel        = options && options.stopAtComponentLevel
            var ignoreNonVisible            = options && options.hasOwnProperty('ignoreNonVisible') ? options.ignoreNonVisible : true

            if (typeof el === 'string') {
                var mainParts  = el.split('->');

                if (mainParts.length === 2) {
                    scopeAdjusted = this.adjustScope(el);

                    el = this.trimString(mainParts[ 1 ]);

                    // Frame might not yet exist, or be ready
                    if (!scopeAdjusted ||
                        ((el.match(/^\s*>>/) || el.match(/=>/)) && !this.Ext())) {
                        this.resetScope();
                        return null;
                    }
                }

                if (el.match(/=>/)) {
                    // Composite query
                    query               = this.compositeQuery(el, null, allowMissing, ignoreNonVisible)
                    el                  = query[ 0 ]
                    matchingMultiple    = query.length > 1
                } else if (el.match(/^\s*>>/)) {
                    var compRes         = this.normalizeComponent(el, allowMissing, { ignoreNonVisible : ignoreNonVisible, detailed : true })
                    
                    el                  = compRes.comp
                    matchingMultiple    = compRes.matchingMultiple
                } else {
                    // string in unknown format, guessing it's a DOM query
                    var retVal          = this.SUPER(el, allowMissing, shallow, detailed);

                    if (scopeAdjusted) this.resetScope();

                    return retVal;
                }

                if (!allowMissing && !el) {
                    var R               = Siesta.Resource('Siesta.Test.ExtJSCore');
                    var warning         = R.get('noComponentFound') + ': ' + origEl;

                    this.warn(warning);
                    if (scopeAdjusted) this.resetScope();
                    throw warning;
                }
            }
            
            var rawResult       = false 

            if (this.isExtJSComponent(el))
                if (stopAtComponentLevel)
                    rawResult   = true
                else {
                    el              = this.compToEl(el);

                                                                // TODO this is commented for the case when targeting a component which has another element on top it (which is not its child)
                    //if (!shallow && this.isElementVisible(el) /* && this.elementIsTop(el, true) */) {
                    //    var point  = this.getTargetCoordinate(el, false, offset);
                    //
                    //    el         = this.elementFromPoint(point[0], point[1], false, el.dom);
                    //}
                }

            // ExtJS Element
            if (el && el.dom)
                if (stopAtComponentLevel)
                    rawResult   = true
                else
                    el          = el.dom
            
            // will also handle the case of conversion of array with coordinates to el 
            var res             = rawResult ? el : this.SUPER(el, allowMissing, shallow);

            if (scopeAdjusted) this.resetScope();

            return detailed ? { el : res, matchingMultiple : matchingMultiple } : res
        },
        
        
        // this method generally has the same semantic as the "normalizeElement", it's being used in
        // Siesta.Test.Action.Role.HasTarget to determine what to pass to the next step
        //
        // on the browser level the only possibility is DOM element
        // but on ExtJS level user can also use ComponentQuery and next step need to receive the 
        // component instance
        normalizeActionTarget : function (el, allowMissing) {
            return this.normalizeElement(el, allowMissing, false, false, { stopAtComponentLevel : true });
        },

         /**
         * This method allow assertions to fail silently for tests executed in versions of Ext JS up to a certain release. When you try to run this test on a newer
         * version of Ext JS and it fails, it will fail properly and force you to re-investigate. If it passes in the newer version, you should remove the 
         * use of this method.
         * 
         * See also {@link Siesta.Test#todo}
         *   
         * @param {String} frameworkVersion The Ext JS framework version, e.g. '4.0.7'
         * @param {Function} fn The method covering the broken functionality
         * @param {String} reason The reason or explanation of the bug
        */
        knownBugIn : function(frameworkVersion, fn, reason) {
            var Ext     = this.getExt();
            var version = Ext.versions.extjs || Ext.versions.touch;
            var R       = Siesta.Resource('Siesta.Test.ExtJSCore');

            if (this.harness.failKnownBugIn || version.isGreaterThan(frameworkVersion)) {
                fn.call(this.global, this);
            } else {
                this.todo(R.get('knownBugIn') + ' ' + frameworkVersion + ': ' + (reason || ''), fn);
            }
        },
        
        
         /**
         * This method will load the specified classes with `Ext.require()` and call the provided callback. Additionally it will check that all classes have been loaded.
         * 
         * This method accepts either variable number of arguments:
         *
         *      t.requireOk('Some.Class1', 'Some.Class2', function () { ... })
         * or array of class names:
         * 
         *      t.requireOk([ 'Some.Class1', 'Some.Class2' ], function () { ... })
         * 
         * @param {String} className1 The name of the class to `require`
         * @param {String} className2 The name of the class to `require`
         * @param {String} classNameN The name of the class to `require`
         * @param {Function} fn The callback. Will be called even if the loading of some classes have failed.
        */
        requireOk : function () {
            var me                  = this
            var global              = this.global
            var Ext                 = this.getExt()
            var args                = Array.prototype.concat.apply([], arguments)
            var R                   = Siesta.Resource('Siesta.Test.ExtJSCore');

            var callback
            
            if (this.typeOf(args[ args.length - 1 ]) == 'Function') callback = args.pop()
            
            
            // what to do when loading completed or timed-out
            var continuation    = function () {
                me.endAsync(async)
                
                Joose.A.each(args, function (className) {
                    var clsManager  = Ext.ClassManager
                    var cls         = clsManager.get(className)
                    
                    /**
                     * Checks if the class being required is an override, which is not available
                     * via Ext.ClassManager.get(). Only available in ExtJS 5+.
                     *
                     * See: https://www.assembla.com/spaces/bryntum/tickets/2201
                     */
                    var isOverride  = clsManager.overrideMap && clsManager.overrideMap[ className ]
                    
                    //   override               normal class                         singleton
                    if (isOverride || cls && (me.typeOf(cls) == 'Function' || me.typeOf(cls.self) == 'Function'))
                        me.pass(R.get('Class') + ": " + className + " " + R.get('wasLoaded'))
                    else
                        me.fail(R.get('Class') + ": " + className + " " + R.get('wasNotLoaded'))
                })
                
                me.processCallbackFromTest(callback)
            }
            
            var timeout         = this.defaultTimeout,
                async           = this.beginAsync(timeout + 100)
            
            var hasTimedOut             = false
            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout
            
            var timeoutId       = originalSetTimeout(function () {
                hasTimedOut     = true
                continuation()
            }, timeout)
            
            Ext.Loader.setConfig({ enabled : true });

            Ext.require(args, function () {
                originalClearTimeout(timeoutId)
                
                if (!hasTimedOut) continuation() 
            })
        },
        
        /**
         * This method is a simple wrapper around the {@link #chainClick} - it performs a component query for provided `selector` starting from the `root` container
         * and then clicks on all found components, in order:
         * 

    // click all buttons in the `panel`
    t.clickComponentQuery('button', panel, function () {})
    
         * 
         * The 2nd argument for this method can be omitted and method can be called with 2 arguments only. In this case a global component query will be performed:
         *

    // click all buttons in the application
    t.clickComponentQuery('button', function () {})
    
         * 
         * @param {String} selector The selector to perform a component query with
         * @param {Ext.Container} root The optional root container to start a query from.
         * @param {Function} callback The callback to call, after clicking all the found components
         */
        clickComponentQuery : function (selector, root, callback) {
            
            if (arguments.length == 2 && this.typeOf(arguments[ 1 ]) == 'Function') {
                callback    = root
                root        = this.Ext().ComponentQuery
            }
            
            if (arguments.length == 1) {
                root        = this.Ext().ComponentQuery
            }
            
            var result      = root.query(selector)
            
            this.chainClick(result, function () { callback && callback.call(this, result) })
        },
        
        
        /**
         * An alias for {@link #clickComponentQuery}.
         * 
         * @param {String} selector The selector to perform a component query with
         * @param {Ext.Container} root The optional root container to start a query from.
         * @param {Function} callback The callback to call, after clicking all the found components
         */
        clickCQ : function () {
            this.clickComponentQuery.apply(this, arguments)
        },

        /**
         * This method performs a combination of `Ext.ComponentQuery` and DOM query, allowing to easily find the DOM elements, 
         * matching a css selector, inside of some Ext.Component.
         * 
         * Both queries should be combined with the `=>` separator: 
         *      
         *      gridpanel[title=Accounts] => .x-grid-row
         *       
         * On the left side of such "composite" query should be a component query, on the right - DOM query (CSS selector)
         * 
         * In case when component query returns more than one component, this method iterate through all of them and will try to
         * resolve the 2nd part of the query. The results from the 1st component with matching DOM nodes is returned. 
         * 
         * E.g. the composite query `gridpanel[title=Accounts] => .x-grid-row` will give you the grid row elements inside a grid panel
         * with `title` config matching "Accounts". 
         * 
         * @param {String} selector The CompositeQuery selector
         * @param {Ext.Component} root The optional root component to start the component query from. If omitted, a global component query will be performed.
         * @param {Boolean} allowEmpty False to throw the exception from this method if no matching DOM element is found. Default is `true`.
         * 
         * @return {HTMLElement[]} The array of DOM elements 
         */
        compositeQuery : function (selector, root, allowEmpty, onlyVisibleComponents) {
            allowEmpty          = allowEmpty !== false
            
            var Ext             = this.Ext();
            var R               = Siesta.Resource('Siesta.Test.ExtJSCore')
            var i
            
            // Try to find magic => selector for nested ComponentQuery and CSS selector
            var mainParts       = selector.split('=>');

            root                = root || Ext && Ext.ComponentQuery;

            // Root might not exist, Ext could be loaded in bootstrap mode without CQ
            if (!root) return []

            if (mainParts.length < 2) throw R.get('invalidCompositeQuery') + ': ' + selector
            
            var compQuery       = mainParts[ 0 ]
            var domQuery        = mainParts[ 1 ]

            var components

            if (compQuery.match(/\.\w+\(/)) {
                var match
                var re          = /(.+?)\.(\w+)\(\)/g
                
                // complex case like: xtype1 xtype2.getPicker() xtype3 xtype4.someMethod()
                while (root && (match = re.exec(compQuery)) != null) {
                    // TODO assuming query is specific, targeting just one target
                    root        = root.query(match[ 1 ])[ 0 ]
                    
                    if (root && match[ 2 ]) root = root[ match[ 2 ] ]()
                }
                
                if (!root && !allowEmpty) throw R.get('invalidCompositeQuery') + ': ' + selector
                
                components     = [ root ]
            } else {
                components     = root.query(compQuery)
            }

            if (!components.length)
                if (allowEmpty) 
                    return []
                else
                    throw R.get('ComponentQuery') + ' ' + compQuery + ' ' + R.get('matchedNoCmp');
            
            for (i = 0; i < components.length; i++) {
                var cmp             = components[i];

                if (
                    cmp.rendered && (            // Widgets don't implement isVisible/isHidden
                        !onlyVisibleComponents || cmp.isWidget || (cmp.isVisible ? cmp.isVisible() : !cmp.isHidden())
                    )
                ) {
                    var result  = this.compToEl(cmp, false);
                    result      = Array.prototype.slice.call($(domQuery, result.dom));

                    if (result.length > 0) {
                        return result;
                    }
                }
            }

            if (allowEmpty) {
                return [];
            }
            throw R.get('CompositeQuery') + ' ' + selector + ' ' + R.get('matchedNoCmp');
        },
        
        /**
         * An alias for Ext.ComponentQuery.query
         * 
         * @param {String} selector The selector to perform a component query with
         */
        cq : function (selector) {
            return this.Ext().ComponentQuery.query(selector);
        },

        /**
         * An shorthand method to get the first result of any Ext.ComponentQuery.query
         * 
         * @param {String} selector The selector to perform a component query with
         */
        cq1 : function (selector) {
            return this.Ext().ComponentQuery.query(selector)[0];
        },

        /**
         * Waits until the passed action target is detected and no ongoing animations are found. This can be a string such as a component query, CSS query or a composite query.
         *
         * @param {String/Siesta.Test.ActionTarget} target The target presence to wait for
         * @param {Function} callback The callback to call after the target has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTarget : function(target, callback, scope, timeout, offset) {
            var SUPER   = this.SUPER

            this.waitForAnimations(function () {
                SUPER.call(this, target, callback, scope, timeout, offset)
            }, this, timeout);
        },

        /**
         * This assertion passes if the singleton MessageBox instance is currently visible.
         * The assertion is relevant if you use one of the following methods Ext.Msg.alert, Ext.Msg.confirm, Ext.Msg.prompt.
         *
         * @param {String} [description] The description for the assertion
         */
        messageBoxIsVisible : function(desc) {
            return this.notOk(this.Ext().Msg.isHidden(), desc || Siesta.Resource('Siesta.Test.ExtJSCore', 'messageBoxVisible'));
        },

        /**
         * This assertion passes if the singleton MessageBox instance is currently hidden.
         * The assertion is relevant if you use one of the following methods Ext.Msg.alert, Ext.Msg.confirm, Ext.Msg.prompt.
         *
         * @param {String} [description] The description for the assertion
         */
        messageBoxIsHidden : function(desc) {
            return this.ok(this.Ext().Msg.isHidden(), desc || Siesta.Resource('Siesta.Test.ExtJSCore', 'messageBoxHidden'));
        },

        /**
         * This assertion passes if the passed component query matches at least one component.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        cqExists : function(query, description) {
            this.ok(this.cq1(query), description);
        },

        /**
         * This assertion passes if the passed component query matches no components.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        cqNotExists : function(query, description) {
            this.notOk(this.cq1(query), description);
        },

        /**
         * This assertion passes if the passed component query matches at least one component.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        componentQueryExists : function() {
            this.cqExists.apply(this, arguments);
        },

        /**
         * Sets a value to an Ext Component. A faster way to set a value than manually calling "type" into
         * a text field for example. A value is set by calling either the `setRawValue` or `setValue` method
         * of the component.
         *
         * @param {Ext.Component/String} component A component instance or a component query to resolve
         * @param {Mixed} value
         */
        setValue : function (component, value, callback, scope) {
            component = this.normalizeComponent(component);

            (component.setRawValue || component.setValue).call(component, value);

            callback && this.processCallbackFromTest(callback, null, scope)
        },


        /**
         * Waits until no ongoing animations can be detected.
         *
         * @param {Function} callback The callback to call after the component becomes visible
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForAnimations: function (callback, scope, timeout) {
            var R   = Siesta.Resource('Siesta.Test.ExtJS');
            var me  = this;

            return this.waitFor({
                method          : function () { return !me.areAnimationsRunning(); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForAnimations',
                description     : ' ' + R.get('animationsToFinalize')
            });
        }
    }
})
;
/**
@class Siesta.Test.ExtJS.Ajax

This is a mixin, with helper methods for mocking Ajax functionality in Ext JS. This mixin is consumed by {@link Siesta.Test.ExtJS}. 
This is only supported when testing Ext JS 4.
*/
Role('Siesta.Test.ExtJS.Ajax', {
    has : {
        responses   : Joose.I.Array,
        urlMatchers : Joose.I.Array
    },

    methods: {

        /**
         * This assertion passes if there is at least one ongoing ajax call.
         * 
         * @param {Object} object (optional) The options object passed to Ext.Ajax.request
         * @param {String} [description] The description for the assertion
         */
        isAjaxLoading: function (obj, description) {
            var Ext = this.Ext();
            this.ok(Ext.Ajax.isLoading(obj), description || Siesta.Resource('Siesta.Test.ExtJS.Ajax', 'ajaxIsLoading'));
        },

        /**
         * This method calls the supplied URL using Ext.Ajax.request and then calls the provided callback. The callback will be called with the 
         * same parameters as the normal Ext.Ajax.request callback is called with ("options", "success" and "response"). To get the response text,
         * use response.responseText.
         * 
         * @param {String/Object} url The url or the options to pass to Ext.Ajax.request
         * @param {Function} callback The callback to call after the ajax request is completed
         * @param {Object} scope The scope for the callback
         */
        ajaxRequestAndThen: function (url, callback, scope) {
            var Ext     = this.Ext();
            var options = url;

            if (typeof(url) === 'string') {
                options = {
                    url         : url,
                    callback    : callback,
                    scope       : scope
                };
            }

            Ext.Ajax.request(options);
        },

        /**
         * Waits until the passed Ext.Ajax request object has completed, or until the latest performed Ajax request is done if the first argument is omitted.
         * 
         * @param {Object} object (optional) The options object passed to Ext.Ajax.request
         * @param {Function} callback The callback to call after the ajax request is completed
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value. 
         */
        waitForAjaxRequest: function (obj, callback, scope, timeout) {
            var Ext = this.Ext();
            var msg;

            if (typeof obj === 'function') {
                msg         = ' ' + Siesta.Resource('Siesta.Test.ExtJS.Ajax', 'allAjaxRequestsToComplete');
                timeout     = scope;
                scope       = callback;
                callback    = obj;
                obj         = undefined;
            } else {
                msg = ' ' + Siesta.Resource('Siesta.Test.ExtJS.Ajax', 'ajaxRequest') + ' "' + obj.options.url + '" ' + Siesta.Resource('Siesta.Test.ExtJS.Ajax', 'toComplete');
            }

            return this.waitFor({
                method          : function() { 
                    if (obj) {
                        return !Ext.Ajax.isLoading(obj) && obj;
                    }
                    return !Ext.Ajax.isLoading();
                }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForAjaxRequest',
                description     : msg
            });
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Store

This is a mixin, with helper methods for testing functionality relating to Ext.data.Store class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Store', {
    
    methods : {
        
        /**
         * Waits until all the passed stores have been loaded (fires the "load" event) and calls the provided callback.
         * 
         * This method accepts either variable number of arguments:
         *
         *      t.waitForStoresToLoad(store1, store2, function () { ... })
         * or array of stores:
         * 
         *      t.waitForStoresToLoad([ store1, store2 ], function () { ... })
         * 
         * @param {Ext.data.AbstractStore} store1 The store to load.
         * @param {Ext.data.AbstractStore} store2 The store to load.
         * @param {Ext.data.AbstractStore} storeN The store to load.
         * @param {Function} callback A function to call when the condition has been met.
         */        
        waitForStoresToLoad: function () {
            var Ext         = this.getExt();
            var args        = Array.prototype.concat.apply([], arguments)
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test.ExtJS.Store');

            // Ext 3
            var baseStoreCls = Ext.data.AbstractStore || Ext.data.Store;
            var callback
            var storesNum;
            
            // First locate the callback
            Joose.A.each(args, function (arg, index) {
                if (me.typeOf(arg) == 'Function') {
                    callback = arg;
                    storesNum = index;
                    return false;
                }
            });

            var loaded      = 0;
            
            var result      = me.waitFor({
                method      : function() { return loaded == storesNum; },
                callback    : callback,
                name        : 'waitForStoresToLoad',
                description : storesNum + ' ' + R.get('storesToLoad')
            });

            Joose.A.each(args, function (store) {               
                             // Ext 3       // Ext 4 && ST
                var proxy = (store.proxy || store.getProxy && store.getProxy());
                
                if (!(store instanceof baseStoreCls)) {
                    return false;
                }

                if (!proxy) {
                    storesNum--;
                    return;
                }

                store.on('load', function () {
                    loaded++;
                    proxy.un('exception', exceptionFailure);
                }, null, { single : true });

                var exceptionFailure = function (proxy, response, operation) {
                    var url     = proxy.api && proxy.api.read || proxy.url
                    
                    me.fail(R.get('failedToLoadStore'), R.get('URL') + ": " + url);
                };

                proxy.on('exception', exceptionFailure);
            });
            
            return result
        },

        /**
         * This method is a wrapper around {@link #waitForStoresToLoad} method - it waits for the provided stores to fire the "load" event.
         * In addition to {@link #waitForStoresToLoad} this method also calls the `load` method of each passed store.
         * 
         * This method accepts either variable number of arguments:
         *
         *      t.loadStoresAndThen(store1, store2, function () { ... })
         * or array of stores:
         * 
         *      t.loadStoresAndThen([ store1, store2 ], function () { ... })
         * 
         * @param {Ext.data.AbstractStore} store1 The store to load.
         * @param {Ext.data.AbstractStore} store2 The store to load.
         * @param {Ext.data.AbstractStore} storeN The store to load.
         * @param {Function} callback A function to call when the condition has been met.
         */  
        loadStoresAndThen: function () {
            var Ext = this.getExt();
            this.waitForStoresToLoad.apply(this, arguments);
            
            var args                =  Array.prototype.concat.apply([], arguments)
            
            if (this.typeOf(args[ args.length - 1 ]) == 'Function') args.pop()

            Joose.A.each(args, function (store) {
                var proxy = (store.proxy || store.getProxy && store.getProxy());
                if (proxy && store.load) {
                    store.load();
                }
            });
        },

        /**
         * Passes if the passed store has no data.
         * 
         * @param {Ext.data.AbstractStore} store
         * @param {String} [description] The description of the assertion
         */
        isStoreEmpty : function(store, description) {
            this.is(store.getCount(), 0, description);
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Observable

This is a mixin, with helper methods for testing functionality relating to Ext.util.Observable class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Observable', {
    
    methods : {
        
        addListenerToObservable : function (observable, event, listener, isSingle) {
            var Ext     = this.Ext()
            
            if (Ext) {
                observable  = this.normalizeActionTarget(observable, false)

                // The way events are fired is slightly different for Ext vs raw DOM tests
                if (observable.nodeName && observable.tagName) {
                    var targetWin = (observable.ownerDocument.parentWindow || observable.ownerDocument.defaultView);

                    if (targetWin.Ext) {
                        observable = targetWin.Ext.get(observable);
                    }
                }

                if (observable.on && observable.un)
                    observable.on(event, listener, null, { single : isSingle })
                else
                    this.SUPERARG(arguments)
            } else
                this.SUPERARG(arguments)
        },
        
        
        removeListenerFromObservable : function (observable, event, listener) {
            var Ext     = this.Ext()
            
            if (Ext) {
                // DOM element might already be removed from the DOM
                observable  = this.normalizeActionTarget(observable, true)

                if (!observable) return;

                // The way events are fired is slightly different for Ext vs raw DOM tests
                if (observable && observable.nodeName && observable.tagName) {
                    var targetWin = (observable.ownerDocument.parentWindow || observable.ownerDocument.defaultView);

                    if (targetWin.Ext) {
                        observable = targetWin.Ext.get(observable);
                    }
                }

                if (observable.on && observable.un)
                    observable.un(event, listener)
                else
                    this.SUPERARG(arguments)
            } else
                this.SUPERARG(arguments)
        },

        /**
         * This assertion passes if the observable does not fire the specified event(s) after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         * 
         * @method wontFire
         */
        

        /**
         * This assertion passes if the observable fires the specified event exactly once after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         * 
         * @method firesOnce
         */

        /**
         * This assertion passes if the observable fires the specified event at least `n` times after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} event The name of event
         * @param {Number} n The minimum number of events to be fired
         * @param {String} [desc] The description of the assertion.
         * 
         * @method firesAtLeastNTimes
         */
        
        
        /**
         * This method will wait for the first `event`, fired by the provided Ext JS `observable` and will then call the provided callback.
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} event The name of the event to wait for
         * @param {Function} callback The callback to call 
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        
        /**
         * This method passes if the provided `observable` has a listener for the `eventName`
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} eventName The name of the event
         * @param {String} [description] The description of the assertion.
         */
        hasListener : function (observable, eventName, description) {
            var R           = Siesta.Resource('Siesta.Test.ExtJS.Observable');
            
            observable      = this.normalizeActionTarget(observable);

            if (!observable || !observable.hasListener) {
                this.fail(description, {
                    assertionName       : 'hasListener',
                    annotation          : R.get('hasListenerInvalid')
                })
                
                return
            }
            
            if (observable.hasListener(eventName))
                this.pass(description, {
                    descTpl             : R.get('hasListenerPass'),
                    eventName           : eventName
                })
            else
                this.fail(description, {
                    assertionName       : 'hasListener',
                    annotation          : R.get('hasListenerFail') + ': ' + eventName
                })
        }


        /**
         * This assertion will verify that the observable fires the specified event and supplies the correct parameters to the listener function.
         * A checker method should be supplied that verifies the arguments passed to the listener function, and then returns true or false depending on the result.
         * If the event was never fired, this assertion fails. If the event is fired multiple times, all events will be checked, but 
         * only one pass/fail message will be reported.
         * 
         * For example:
         * 

    t.isFiredWithSignature(store, 'add', function (store, records, index) {
        return (store instanceof Ext.data.Store) && (records instanceof Array) && t.typeOf(index) == 'Number'
    })
 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} event The name of event
         * @param {Function} checkerFn A method that should verify each argument, and return true or false depending on the result.
         * @param {String} [desc] The description of the assertion.
         */
    }
});
;
/**
@class Siesta.Test.ExtJS.Component

This is a mixin, with helper methods for testing functionality relating to Ext.Component. This mixin is being consumed by {@link Siesta.Test.ExtJS}. 

*/
Role('Siesta.Test.ExtJS.Component', {

    requires: ['waitFor'],

    methods: {

        /**
         * Waits until the main element of the passed component is the 'top' element in the DOM. The callback will receive the passed component instance.
         * 
         * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery string. In the latter case, 
         * this method will also wait until the component query find some component (meaning the component does not have to
         * be already created when waiting starts) 
         * @param {Function} callback The callback to call after the component becomes visible
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForComponentVisible: function (component, callback, scope, timeout) {
            var R       = Siesta.Resource('Siesta.Test.ExtJS.Component');
            var me      = this;

            if (this.typeOf(component) != 'String' && !this.isExtJSComponent(component)) {
                throw R.get('badInputText') + ': ' + component;
            }

            return this.waitFor({
                method          : function () { 
                    var comp    = me.normalizeComponent(component, true)
                    
                    if (!comp) return false
                    
                    var el      = me.compToEl(comp); 
                    
                    return el && me.elementIsTop(el, true) && comp; 
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentVisible',
                description     : ' ' + R.get('component') + ' "' + (me.typeOf(component) == 'String' ? component : component.id) + '" ' + R.get('toBeVisible')
            });
        },


        /**
         * Waits until the main element of the passed component is not visible. The callback will receive the passed component instance.
         * 
         * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery string. In the latter case, 
         * this method will also wait until the component query find some component (meaning the component does not have to
         * be already created when waiting starts) 
         * @param {Function} callback The callback to call after the component becomes not visible
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForComponentNotVisible: function (component, callback, scope, timeout) {
            var R       = Siesta.Resource('Siesta.Test.ExtJS.Component');
            var me      = this;

            if (this.typeOf(component) != 'String' && !this.isExtJSComponent(component)) {
                throw R.get('badInputText') + ': ' + component;
            }

            return this.waitFor({
                method          : function () {
                    var comp    = me.normalizeComponent(component, true)
                    
                    if (!comp) return false
                    
                    var el      = me.compToEl(comp);

                    return (comp.isHidden() || (el && !me.isElementVisible(el))) && comp;
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentNotVisible',
                description     : ' ' + R.get('component') + ' "' + (me.typeOf(component) == 'String' ? component : component.id) + '" ' + R.get('toNotBeVisible')
            });
        },


        /**
        * Waits until Ext.ComponentQuery detects some results from the passed query parameter. The callback will receive the result of the query.
        * 
        * The "root" argument of this method can be omitted.
        * 
        * @param {String} selector The component query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForComponentQuery: function (selector, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout = scope
                scope = callback
                callback = root
                root = this.getExt() && this.getExt().ComponentQuery
            }

            return this.waitFor({
                method      : function () {
                    var result = (root && root.query(selector) || this.getExt() && this.getExt().ComponentQuery.query(selector));
                    return result && result.length > 0 ? result : false;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForComponentQuery',
                description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Component', 'componentQuery') + ' "' + selector + '"'
            });
        },

        /**
        * Waits until {@link Siesta.Test.ExtJSCore#compositeQuery} detects some results from the passed query parameter. The callback will receive the result of the query.
        * 
        * The "root" argument of this method can be omitted.
        * 
        * @param {String} query The composite query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback 
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForCompositeQuery: function (query, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            var me = this;

            return me.waitFor({
                method      : function () {
                    var result = me.compositeQuery(query, root, true);
                    
                    return result.length > 0 ? result : false;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                
                assertionName   : 'waitForCompositeQuery',
                description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Component', 'compositeQuery') + ' "' + query + '"'
            });
        },
        
        
        /**
        * Waits until {@link Siesta.Test.ExtJSCore#compositeQuery} does not detects any results from the passed query parameter.
        * 
        * The "root" argument of this method can be omitted.
        * 
        * @param {String} query The composite query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback 
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForCompositeQueryNotFound: function (query, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            var me = this;

            return me.waitFor({
                method      : function () {
                    var result = me.compositeQuery(query, root, true);
                    
                    return result.length > 0 ? false : true;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                
                assertionName   : 'waitForCompositeQueryNotFound',
                description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Component', 'compositeQuery') + ' "' + query + '" ' + Siesta.Resource('Siesta.Test.ExtJS.Component', 'toReturnEmptyArray')
            });
        },
        


        /**
        * Shorthand alias for {@link #waitForComponentQuery}
        * 
        * @param {String} query The component query phrase
        * @param {Ext.Container} root The container to start a component query from
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForCQ: function () {
            return this.waitForComponentQuery.apply(this, arguments);
        },


        /**
        * Alias for {@link #waitForComponentQueryNotFound}
        * 
        * @param {String} query
        * @param {Function} callback
        * @param {Object} scope
        * @param {Number} timeout
        */
        waitForCQNotFound: function () {
            return this.waitForComponentQueryNotFound.apply(this, arguments);
        },


        /**
        * Waits until Ext.ComponentQuery from the passed query parameter is no longer found, and then calls the callback supplied.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} query The component query selector
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForComponentQueryNotFound: function (query, root, callback, scope, timeout) {
            var R = Siesta.Resource('Siesta.Test.ExtJS.Component');

            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            return this.waitFor({
                method      : function () {
                    var result = root.query(query);
                    return result.length === 0 && result;
                },
                callback    : callback,
                scope       : scope, 
                timeout     : timeout,
                assertionName   : 'waitForComponentQueryNotFound',
                description     : R.get('componentQuery') + ': ' + query + ' ' + R.get('toReturnEmpty')
            });
        },


        /**
        * Alias for {@link #waitForComponentQueryVisible}
        * 
        * @param {String} query
        * @param {Function} callback
        * @param {Object} scope
        * @param {Number} timeout
        */
        waitForCQVisible: function () {
            return this.waitForComponentQueryVisible.apply(this, arguments);
        },

        /**
         * Alias for {@link #waitForComponentQueryNotVisible}
         *
         * @param {String} query
         * @param {Function} callback
         * @param {Object} scope
         * @param {Number} timeout
         */
        waitForCQNotVisible: function () {
            return this.waitForComponentQueryNotVisible.apply(this, arguments);
        },

        /**
        * Waits until all results of the Ext.ComponentQuery are detected and visible.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} query The component query selector
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForComponentQueryVisible: function (query, root, callback, scope, timeout) {
            var me  = this,
                R   = Siesta.Resource('Siesta.Test.ExtJS.Component'),
                Ext = me.getExt();

            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = Ext.ComponentQuery
            }

            return this.waitFor({
                method      : function () {
                    var result = root.query(query),
                        allVisible = true;

                    if (result.length > 0) {
                        Joose.A.each(result, function (c) {
                            if (!c.rendered || !me.isElementVisible(c)) {
                                allVisible = false;
                                return false;
                            }
                        });
                        return allVisible && result;
                    } else {
                        return false;
                    }
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForComponentQueryVisible',
                description     : ' ' + R.get('componentQuery') + ': ' + query + ' ' + R.get('toReturnAVisibleComponent')
            });
        },

        /**
         * Waits until the result of the Ext.ComponentQuery is either empty, or the found component(s) is hidden.
         *
         * The "root" argument of this method can be omitted.
         *
         * @param {String} query The component query selector
         * @param {Ext.Container} root The container to start a component query from. Optional
         * @param {Function} callback The callback to call after the xtype has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForComponentQueryNotVisible: function (query, root, callback, scope, timeout) {
            var me  = this,
                R   = Siesta.Resource('Siesta.Test.ExtJS.Component'),
                Ext = me.getExt();

            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = Ext.ComponentQuery
            }

            return this.waitFor({
                method          : function () {
                    var result = root.query(query),
                        allHidden = true;

                    if (result.length > 0) {
                        Joose.A.each(result, function (c) {
                            if (c.rendered && !c.isHidden()) {
                                allHidden = false;
                                return false;
                            }
                        });
                        return allHidden && result;
                    } else {
                        return true;
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentQueryVisible',
                description     : ' ' + R.get('componentQuery') + ': ' + query + ' ' + R.get('toReturnHiddenCmp')
            });
        },

        /**
        * Waits until the a component with the specified xtype can be detected by a simple ComponentQuery.
        * 
        * The "root" argument of this method can be omitted.
        * 
        * @param {String} xtype The component xtype to look for.
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForXType: function (xtype, root, callback, scope, timeout) {
            return this.waitForComponentQuery(xtype, root, callback, scope, timeout);
        },

        /**
        * Waits until the a component with the specified xtype can be detected by a simple ComponentQuery.
        * 
        * @param {String} component The class name to wait for.
        * @param {Boolean} rendered true to also wait for the component to be rendered
        * @param {Function} callback The callback to call after the component has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForComponent: function (component, rendered, callback, scope, timeout) {
            var Ext         = this.getExt();
            var xtype
            
            if (Ext.isString(component)) {
                xtype = Ext.ClassManager.get(component).xtype;
            } else {
                xtype = component.xtype;
            }

            if (rendered) {
                xtype = xtype + '[rendered]';
            }

            return this.waitForXType(xtype, callback, scope, timeout);
        },

        /**
        * This assertion passes when the passed width and height matches the result of component.getSize()
        * 
        * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery 
        * @param {Int} width
        * @param {Int} height
        * @param {String} [description] The description of the assertion
        */
        hasSize: function (component, width, height, description) {
            component = this.normalizeComponent(component);
            this.isDeeply(component.getSize(), { width: width, height: height }, description);
        },

        /**
        * This assertion passes when the passed x and y matches the result of component.getPosition()
        * 
        * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery 
        * @param {Int} x
        * @param {Int} y
        * @param {String} [description] The description of the assertion
        */
        hasPosition: function (component, x, y, description) {
            component = this.normalizeComponent(component);
            this.isDeeply(component.getPosition(), [x, y], description);
        },
        
        
        /**
         * This assertion accepts variable number of Ext.Component instances (can be also provided as component query string).
         * Then it calls their "destroy" method and verifies that:
         * - there were no exceptions during destroy
         * - that each component was actually destoyed (since destroy can be canceled in the "beforedestroy" event listener)  
         * 
         * @param {Ext.Component/Array[Ext.Component]/String} components A single instance of Ext.Component, an array of such or a string with component query 
         * @param {String} [description] The description of the assertion
         */
        destroysOk : function (components, description) {
            var Ext     = this.Ext();
            var R       = Siesta.Resource('Siesta.Test.ExtJS.Component');

            if (this.typeOf(components) != 'Array') {
                if (this.typeOf(components) == 'String') 
                    components  = this.Ext().ComponentQuery.query(components);
                else
                    components  = [ components ]
            }
            
            if (!components.length) {
                this.fail(description, {
                    assertionName       : 'destroysOk',
                    annotation          : R.get('invalidDestroysOkInput')
                })
                
                return
            }
            
            var currentComp
            
            var e       = this.getExceptionCatcher()(function () {
                Joose.A.each(components, function (component) {
                    currentComp = component
                    
                    component.destroy() 
                })
            })
            
            if (e !== undefined) {
                this.fail(description, {
                    assertionName       : 'destroysOk',
                    got                 : e,
                    gotDesc             : R.get('exception'),
                    annotation          : R.get('exceptionAnnotation') + ' ' + currentComp.id
                })
                
                return
            }
            
            var me      = this
            
            var allDestroyed = Joose.A.each(components, function (component) {
                //          ExtJS                             ST
                if (!(component.isDestroyed || component.destroy == Ext.emptyFn)) {
                    me.fail(description, {
                        assertionName       : 'destroysOk',
                        annotation          : R.get('Component') + ' [' + component.id + '] ' + R.get('destroyFailed')
                    })
                    
                    return false
                } 
            })
            
            if (allDestroyed === false) return
            
            this.pass(description, {
                descTpl     : R.get('destroyPassed')
            })
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Grid

This is a mixin, with helper methods for testing functionality relating to ExtJS grids. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Grid', {
    
    requires        : [ 'waitFor', 'pass', 'fail', 'typeOf' ],
    
    
    methods : {
        /**
         * Waits for the rows of a gridpanel or tree panel (or view) to render and then calls the supplied callback. Please note, that if the store of the grid has no records,
         * the condition for this waiter will never be fullfilled.
         * 
         * @param {Ext.view.Table/Ext.panel.Table/String} view The view or a ComponentQuery matching a view
         * @param {Function} callback A function to call when the condition has been met.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForRowsVisible : function(view, callback, scope, timeout) {
            if (typeof view === 'function') {
                timeout     = scope;
                scope       = callback;
                callback    = view;
                view       = this.Ext() && this.cq1('tableview') || 'tableview';
            }

            var cmp = this.Ext() && this.normalizeComponent(view, true);
            var me = this;

            if (!cmp && typeof view === 'string') {
                // Make sure CQ returns a result first
                return this.waitForCQ(view, function(result) { this.waitForRowsVisible(result[0], callback, scope, timeout); }, this);
            } else {
                var checkerFn;

                // Handle case of locking grid (Ext JS 4+ only)
                if(cmp.normalGrid) {
                    var selector = cmp.normalGrid.getView().itemSelector;
                    checkerFn = function() {
                        if (!cmp.rendered || !cmp.normalGrid.rendered || !cmp.lockedGrid.rendered) return;
                         
                        var lockedResult = this.$(selector, cmp.lockedGrid.el.dom); 
                        var normalResult = this.$(selector, cmp.normalGrid.el.dom); 
                        
                        if (lockedResult.length > 0 && normalResult.length > 0) {
                            return {
                                lockedRows : lockedResult,
                                normalRows : normalResult
                            };
                        }
                    }
                } else {
                    var view = (cmp.getView && cmp.getView()) || cmp;
                    var selector = view.itemSelector || view.rowSelector; // Handling Ext 4 + Ext 3 cases

                    checkerFn = function() {
                        if (!cmp.rendered) return;
                         
                        var result = this.$(selector, cmp.el.dom); 
                        
                        if (result.length > 0) {
                            return result;
                        }
                    }
                }


                return this.waitFor({
                    method          : checkerFn, 
                    callback        : function() {
                        // Grid might be refreshing itself multiple times during initialization which can
                        // break tests easily
                        var as = me.beginAsync();

                        me.global.setTimeout(function(){
                            me.endAsync(as);
                            callback.call(scope || me);
                        }, 100);
                    },
                    timeout         : timeout,
                    assertionName   : 'waitForRowsVisible',
                    description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Grid').get('waitForRowsVisible') + ' "' + cmp.id + '"'
                });
            }
        },

        /**
         * Utility method which returns the first grid row element.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @return {Ext.Element} The element of the first row in the grid.
         */
        getFirstRow : function(grid) {
            grid = this.normalizeComponent(grid);

            return this.getRow(grid, 0);
        },

        /**
         * Utility method which returns the first grid cell element.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * 
         * @return {Ext.Element} The element of the first cell in the grid.
         */
        getFirstCell : function(panel) {
            panel = this.normalizeComponent(panel);

            return this.getCell(panel, 0, 0);
        },

        /**
         * Utility method which returns a grid row element.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} index The row index
         *
         * @return {Ext.Element} The element corresponding to the grid row.
         */
        getRow : function(grid, index) {
            grid        = this.normalizeComponent(grid);

            var domNode = grid && this.$(grid.getView().itemSelector, grid.el.dom)[ index ];

            return domNode && this.Ext().get(domNode);
        },

        /**
         * Utility method which returns the cell at the supplied row and col position.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         * @param {Int} column The column index
         * 
         * @return {Ext.Element} The element of the grid cell at specified position.
         */
        getCell : function(grid, row, col) {
            grid            = this.normalizeComponent(grid);

            var rowEl       = grid && this.getRow(grid, row);
            var cellNode    = rowEl && this.$(grid.view.cellSelector, rowEl.dom)[col];

            return cellNode && this.Ext().get(cellNode);
        },

        /**
         * Utility method which returns the last cell for the supplied row.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         * 
         * @return {Ext.Element} The element of the grid cell at specified position.
         */
        getLastCellInRow : function(grid, row) {
            grid = this.normalizeComponent(grid);

            return this.getCell(grid, row, grid.headerCt.getColumnCount() - 1);
        },

        /**
         * This assertion passes if the passed string is found in the passed grid's cell element.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         * @param {Int} column The column index
         * @param {String/RegExp} string The string to find or RegExp to match
         * @param {String} [description] The description for the assertion
         */
        matchGridCellContent : function(grid, rowIndex, colIndex, string, description) {
            grid = this.normalizeComponent(grid);
            
            var view = grid.getView(),
                Ext = this.Ext(),
                cell = this.getCell(grid, rowIndex, colIndex).child('.' + Ext.baseCSSPrefix + 'grid-cell-inner');

            var isRegExp    = this.typeOf(string) == 'RegExp';
            var content     = cell.dom.innerHTML;
                
            if (isRegExp ? string.test(content) : content.indexOf(string) != -1) {
                this.pass(description, {
                    descTpl     : isRegExp ? 'Cell content {content} matches regexp {string}' : 'Cell content {content} has a string {string}',
                    content     : content,
                    string      : string
                });
            } else {
                this.fail(description, {
                    assertionName   : 'matchGridCellContent',
                    
                    got         : cell.dom.innerHTML,
                    gotDesc     : 'Cell content',
                    
                    need        : string,
                    needDesc    : 'String matching',
                    
                    annotation  : 'Row index: ' + rowIndex + ', column index: ' + colIndex
                });
            }
        },
        
        
        /**
         * This method performs either a click or double click on the specified grid cell 
         * (depending from the [clicksToEdit](http://docs.sencha.com/extjs/4.2.2/#!/api/Ext.grid.plugin.Editing-cfg-clicksToEdit)
         * config of its editing plugin), then waits until the `input` selector appears under the cursor and calls the provided callback.
         * The callback will receive the DOM `&lt;input&gt; element as the 1st argument. 
         * 
         * In some browsers the editor is shown with delay, so its highly recommended to use this method when editing cells.
         * Typical usage will be:
         * 

    t.chain(
        function (next) {
            t.clickToEdit(grid, 0, 1, next)
        },
        function (next, inputEl) {
            t.type(inputEl, "my text", next)
        }
    )

         * 
         * 
         * @param {Ext.grid.Panel/String} grid The grid panel or a ComponentQuery matching a panel
         * @param {Int} rowIndex The row index
         * @param {Int} colIndex The column index
         * @param {Function} callback The callback to call once the `input` selector appears under the cursor
         * @param {String} selector Custom selector to wait for, instead of `input`.
         */
        clickToEditCell : function (grid, rowIndex, colIndex, callback, selector) {
            var Ext             = this.getExt()
            
            grid                = this.normalizeComponent(grid);
            
            var editingPlugin   = grid && grid.editingPlugin
            
            if (!editingPlugin || !(editingPlugin instanceof Ext.grid.plugin.CellEditing)) {
                this.fail("No grid, or grid has no editing plugin, or its not a Ext.grid.plugin.CellEditing plugin")
                
                callback && callback(null)
                
                return
            }
            
            var me      = this
            
            this[ editingPlugin.clicksToEdit == 2 ? 'doubleClick' : 'click' ](this.getCell(grid, rowIndex, colIndex), function () {
                // manually force editing if it didn't get started by the click
                if (!editingPlugin.getActiveEditor()) editingPlugin.startEditByPosition({ row : rowIndex, column : colIndex })

                me.waitForSelectorAtCursor(selector || '.x-editor,input', callback)
            })
        },

        getTrimmedCellContent : function(grid, row, column) {
            var cell = this.getCell(grid, row, column);

            return $.trim(this.$(cell.dom).text());
        },

        /**
         * Assertion method which passes if the grid cell is empty.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} rowIndex The row index
         * @param {Int} colIndex The column index
         * @param {String} message The assertion message
         *
         * @return {Ext.Element} The element of the grid cell at specified position.
         */
        assertCellIsEmpty : function(grid, row, column, message) {
            this.is(this.getTrimmedCellContent(grid, row, column), '', message);
        },

        /**
         * Wait-for method which waits until the chosen grid cell is empty.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} rowIndex The row index
         * @param {Int} colIndex The column index
         * @param {Object} scope The 'this' object for the callback
         * @param {Int} timeout The timeout in ms
         * @param {Function} callback The callback called when the condition is fulfilled
         *
         * @return {Ext.Element} The element of the grid cell at specified position.
         */
        waitForCellEmpty : function(grid, row, column, scope, timeout, callback) {
            if (typeof scope === 'function') {
                callback    = scope;
            } else if (typeof timeout === 'function') {
                callback    = timeout;
            }

            this.waitFor({
                method          : function() {
                    return this.getTrimmedCellContent(grid, row, column).length === 0;
                },
                callback        : function() {
                    callback.call(scope || this);
                },
                timeout         : timeout,
                assertionName   : 'waitForCellEmpty',
                description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Grid').get('waitForCellEmpty')
            });
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.DataView

This is a mixin, with helper methods for testing functionality relating to ExtJS dataviews. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.DataView', {
    
    requires        : [ 'waitFor', 'getExt' ],
    
    
    methods : {
        /**
         * Waits for the items of a dataview to render and then calls the supplied callback.
         * @param {Ext.view.View/String} view An Ext.view.View instance or a ComponentQuery 
         * @param {Function} callback A function to call when the condition has been met.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForViewRendered : function(view, callback, scope, timeout) {
            view            = this.normalizeComponent(view);

            var hasItems    = view.store.getCount() > 0
            var R           = Siesta.Resource('Siesta.Test.ExtJS.DataView');

            return this.waitFor({
                method      : function() { return hasItems ? !!view.getNode(0) : view.rendered }, 
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForViewRendered',
                description     : ' ' + R.get('view') + ' ' + view.id + ' ' + R.get('toRender')
            });
        },

        /**
         * Utility method which returns the first view element.
         * 
         * @param {Ext.view.View/String} view An Ext.view.View instance or a ComponentQuery 
         * @return {Ext.Element} The first element of the view
         */
        getFirstItem : function(view) {
            var Ext = this.getExt();

            view = this.normalizeComponent(view);

            return Ext.get(view.getNode(0));
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Element

This is a mixin, with helper methods for testing functionality relating to ExtJS/DOM elements. This mixin is consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Element', {
    
    methods : {
        /**
         * Passes if the passed element has the expected region.
         * 
         * @param {Ext.Element} el The element
         * @param {Ext.util.Region} region The region to compare to.
         * @param {String} [description] The description of the assertion
         */
        hasRegion : function(el, region, description) {
            var elRegion = el.getRegion();
            var R        = Siesta.Resource('Siesta.Test.ExtJS.Element');

            this.is(elRegion["top"], region["top"], description + ' ' + R.get('top') + ')');
            this.is(elRegion["right"], region["right"], description + ' ' + R.get('right') + ')');
            this.is(elRegion["bottom"], region["bottom"], description + ' ' + R.get('bottom') + ')');
            this.is(elRegion["left"], region["left"], description + ' ' + R.get('left') + ')');
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.FormField

This is a mixin, with helper methods for testing functionality relating to Ext.form.Field class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.FormField', {
    
    methods : {
        /**
         * Passes if the passed Field has the expected value.
         * 
         * @param {Ext.form.field.Field/String} field A form field or a ComponentQuery
         * @param {Mixed} value The value to compare to.
         * @param {String} [description] The description of the assertion
         */
        fieldHasValue : function(field, value, description) {
            field = this.normalizeComponent(field);
            this.is(field.getValue(), value, description);
        },

        /**
         * Passes if the passed Field has no value ("" or null).
         * 
         * @param {Ext.form.field.Field/String} field A form field or a ComponentQuery
         * @param {String} [description] The description of the assertion
         */
        isFieldEmpty : function(field, description) {
            field = this.normalizeComponent(field);
            var val = field.getValue();
            this.ok(val === null || val === "", description);
        }
    }
});
;
/**

 @class Siesta.Test.TextSelection

 This is a mixin providing text selection functionality.

 */
Role('Siesta.Test.TextSelection', {

    methods : {
        /**
         * Utility method which returns the selected text in the passed element or in the document
         * @param {Siesta.Test.ActionTarget} el The element
         * @return {String} The selected text
         */
        getSelectedText : function (el) {
            el = this.normalizeElement(el);

            if ('selectionStart' in el) {
                try {
                    return el.value.substring(el.selectionStart, el.selectionEnd);
                } catch (e) {
                    // the "email" and "number" input fields (possibly some other too) does not allow to access 
                    // the "selectionStart/End" properties and throws exceptions
                }
            }

            var win = this.global,
                doc = win.document;

            if (win.getSelection) {
                return win.getSelection().toString();
            } else if (doc.getSelection) {
                return doc.getSelection();
            } else if (doc.selection) {
                return doc.selection.createRange().text;
            }
        },

        /**
         * Utility method which selects text in the passed element (should be an &lt;input&gt; element).
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Int} start (optional) The selection start index
         * @param {Int} end (optional) The selection end index
         */
        selectText : function (el, start, end) {
            el = this.normalizeElement(el);

            var v       = el.value || el.innerHTML,
                doFocus = true;

            if (v.length > 0) {
                start = start === undefined ? 0 : start;
                end   = end === undefined ? v.length : end;

                if (el.setSelectionRange) {
                    el.setSelectionRange(start, end);
                } else if (el.createTextRange) {
                    var R = el.createTextRange();

                    R.moveStart('character', start);
                    R.moveEnd('character', end - v.length);

                    R.select();
                }

                doFocus = $.browser.mozilla || $.browser.opera;
            }

            if (doFocus) {
                this.focus(el);
            }
        },

        setCaretPosition : function (el, caretPos) {

            if (el.createTextRange) {
                var range = el.createTextRange();
                range.move('character', caretPos);
                range.select();
            }
            else {
                if (el.setSelectionRange) {
                    el.focus();
                    el.setSelectionRange(caretPos, caretPos);
                }
                else {
                    el.focus();
                }
            }
        }
    }
})
;
/**
@class Siesta.Test.Element

This is a mixin, with helper methods for testing functionality relating to DOM elements. This mixin is consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Element', {

    requires    : [
        'typeOf',
        'chain',
        'normalizeElement'
    ],
    
    has : {
        allowMonkeyToClickOnAnchors     : false,
        
        allowedCharacters               : function () {
            return {
                // does not include TAB by purpose, because our "TAB" simulation is not perfect
                // Also exclude BACKSPACE since it navigates the page
                special     : 'ENTER/ESCAPE/PAGE-UP/PAGE-DOWN/END/HOME/UP/RIGHT/DOWN/LEFT/INSERT/DELETE',
                // does not inlcude * because Ext fails on typing it
                punctuation : '.,/()[]{}\\"\'`~!?@#$%^&_=+-',
                normal      : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
            }
        }
    },

    methods : {

        /**
         * Utility method which returns the center of a passed element. The coordinates are by default relative to the
         * containing document of the element (so for example if the element is inside of the nested iframe, coordinates
         * will be "local" to that iframe element). To get coordinates relative to the test iframe ("global" coordinates),
         * pass `local` as `false`.
         *
         * @param {Siesta.Test.ActionTarget} el The element to find the center of.
         * @param {Boolean} [local] Pass `true` means coordinates are relative to the containing document. This is the default value.
         * Pass `false` to make sure the coordinates are global to the test window.
         *
         * @return {Array} The array first element of which is the `x` coordinate and 2nd - `y`
         */
        findCenter : function (target, local) {
            return this.getTargetCoordinate(target, local);
        },


        normalizeOffset : function (offset, $el) {
            var parts;

            if (this.typeOf(offset) == 'Function') offset = offset.call(this)

            offset              = offset && offset.slice() || [ '50%', '50%' ];

            if (typeof (offset[ 0 ]) === 'string') {
                parts           = offset[ 0 ].split('%');
                offset[ 0 ]     = parseInt(offset[ 0 ].match(/\d+/)[ 0 ], 10) * ($el.outerWidth() - 1) / 100;

                if (parts[ 1 ]) {
                    offset[ 0 ] += parseInt(parts[ 1 ]);
                }

                offset[ 0 ]     = Math.round(offset[ 0 ])
            }

            if (typeof (offset[ 1 ]) === 'string') {
                parts           = offset[ 1 ].split('%');
                offset[ 1 ]     = parseInt(offset[ 1 ].match(/\d+/)[ 0 ], 10) * ($el.outerHeight() - 1) / 100;

                if (parts[ 1 ]) {
                    offset[ 1 ] += parseInt(parts[ 1 ]);
                }

                offset[ 1 ]     = Math.round(offset[ 1 ])
            }

            return offset
        },


        getTargetCoordinate : function (target, local, offset) {
            var normalizedEl    = this.normalizeElement(target),
                $normalizedEl   = this.$(normalizedEl),
                bodyOffset      = $normalizedEl.offset(),
                elDoc           = normalizedEl.ownerDocument,
                $doc            = this.$(elDoc),
                xy              = [ bodyOffset.left - $doc.scrollLeft(), bodyOffset.top - $doc.scrollTop() ];

            offset              = this.normalizeOffset(offset, $normalizedEl)

            xy[ 0 ]             += offset[ 0 ];
            xy[ 1 ]             += offset[ 1 ];

            if (local === false) {
                var elWindow    = elDoc.defaultView || elDoc.parentWindow;

                // Potentially we're interacting with an element inside a nested frame, which means the coordinates are local to that frame
                if (elWindow !== this.global) {
                    var offsetsToTop    = this.$(elWindow.frameElement).offset();

                    xy[ 0 ]     += offsetsToTop.left;
                    xy[ 1 ]     += offsetsToTop.top;
                }
            }

            return xy;
        },

        /**
         * Returns true if the element is visible, checking jQuery :visible selector + style visibility value.
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @return {Boolean}
         */
        isElementVisible : function(el) {
            el          = this.normalizeElement(el);

            // Workaround for OPTION elements which don't behave like normal DOM elements. jQuery always consider them invisible.
            // Decide based on visibility of the parent SELECT node
            if (el && el.nodeName.toLowerCase() === 'option') {
                el = this.$(el).closest('select')[0];
            }

            if (el) {
                try {
                    // Jquery :visible doesn't handle SVG/VML, so manual check
                    // accessing to `this.global.SVGElement` throws exceptions for popups in IE 9
                    if (window.SVGElement && el instanceof this.global.SVGElement) 
                        return el.style.display !== 'none' && el.style.visibility !== 'hidden'
                } catch (e) {
                }

                // Jquery :visible doesn't take visibility into account
                return this.$(el).is(':visible') && (!el.style || el.style.visibility !== 'hidden')
            }

            return false
        },

        /**
         * Passes if the innerHTML of the passed element contains the text passed
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match
         * @param {String} [description] The description for the assertion
         */
        contentLike : function(el, text, description) {
            el = this.normalizeElement(el);

            this.like(el.innerHTML, text, description);
        },

        /**
         * Passes if the innerHTML of the passed element does not contain the text passed
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match
         * @param {String} [description] The description for the assertion
         */
        contentNotLike : function(el, text, description) {
            el = this.normalizeElement(el);

            this.unlike(el.innerHTML, text, description);
        },

        /**
         * Waits until the innerHTML of the passed element contains the text passed
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForContentLike : function(el, text, callback, scope, timeout) {
            var R = Siesta.Resource('Siesta.Test.Element');

            el = this.normalizeElement(el);

            return this.waitFor({
                method          : function() { return el.innerHTML.match(text); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForContentLike',
                description     : ' ' + R.get('elementContent') + ' "' + text + '" ' + R.get('toAppear')
            });
        },

        /**
         * Waits until the innerHTML of the passed element does not contain the text passed
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForContentNotLike : function(el, text, callback, scope, timeout) {
            var R = Siesta.Resource('Siesta.Test.Element');

            el = this.normalizeElement(el);

            return this.waitFor({
                method          : function() { return !el.innerHTML.match(text); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForContentNotLike',
                description     : ' ' + R.get('elementContent') + ' "' + text + '" ' + R.get('toDisappear')
            });
        },
        
        
        getRandomTypeString : function (length) {
            var allowedCharacters   = this.allowedCharacters
            
            var special     = allowedCharacters.special.split('/')
            var punctuation = allowedCharacters.punctuation
            var normal      = allowedCharacters.normal
            
            var total       = special.length + punctuation.length + normal.length
            
            var str         = ''
            
            for (var i = 0; i < length; i++) {
                var index       = this.randomBetween(0, total - 1)
                
                if (index < normal.length) 
                    str     += normal.substr(index, 1)
                else {
                    index   -= normal.length
                    
                    if (index < punctuation.length) 
                        str     += punctuation.substr(index, 1)
                    else {
                        index   -= punctuation.length
                        
                        str     += '[' + special[ index ] + ']'
                    }
                }
            }
            
            return str
        },

        /**
         * Performs clicks, double clicks, right clicks and drags at random coordinates within the passed target.
         * While doing all these random actions it also tracks the number of exceptions thrown and reports a failure
         * if there was any. Otherwise it reports a passed assertion.
         *
         * Use this assertion to "stress-test" your component, making sure it will work correctly in various unexpected
         * interaction scenarious.
         *
         * Note that as a special case, when this method is provided with the document's &lt;body&gt; element,
         * it will test the whole browser viewport.
         *
         * @param {Siesta.Test.ActionTarget} el The element to upon which to unleash the "monkey".
         * @param {Int} nbrInteractions The number of random interactions to perform.
         * @param {String} [description] The description for the assertion
         * @param {Function} callback The callback to call after all actions are completed
         * @param {Object} scope The scope for the callback
         */
        monkeyTest : function(el, nbrInteractions, description, callback, scope) {
            el              = this.normalizeElement(el, false, true);

            this.suppressPassedWaitForAssertion = true;

            if (typeof nbrInteractions === 'function') {
                callback    = nbrInteractions;
                scope       = description;
                description = '';
            } else if (typeof description === 'function') {
                callback    = description;
                description = '';
            }

            nbrInteractions = typeof nbrInteractions === 'number' ? nbrInteractions : 30;

            var global      = this.global
            var isBody      = el == global.document.body

            var me          = this,
                offset      = me.$(el).offset(),
                right       = offset.left + me.$(isBody ? global : el).width(),
                bottom      = offset.top + me.$(isBody ? global : el).height();

            var actionLog   = []
            var R           = Siesta.Resource('Siesta.Test.Element');

            var queue       = new Siesta.Util.Queue({
                deferer         : me.originalSetTimeout,
                deferClearer    : me.originalClearTimeout,

                interval        : 50,

                observeTest     : this,

                processor   : function (data) {
                    if (me.nbrExceptions || me.failed) {
                        me.warn(R.get('monkeyActionLog') + ":" + JSON2.stringify(actionLog))
                        // do not continue if the test has detected an exception thrown
                        queue.abort()
                    } else {
                        var async       = me.beginAsync(null, function (test) {
                            test.fail(R.get('monkeyException'))
                            me.warn(R.get('monkeyActionLog') + ":" + JSON.stringify(actionLog))

                            return true
                        });

                        var next        = data.next

                        data.next       = function () {
                            me.endAsync(async)

                            next()
                        }

                        data.action(data)
                    }
                }
            });

            var dummy       = []
            dummy.length    = nbrInteractions
            
            var ignoreActionOnAnchor      = function (data, i) {
                var target      = me.normalizeElement(data.dragFrom || data.xy)
                
                // do not click on <a> elements, unless those
                // w/o `href' or with #hash-style hrefs
                if (
                    target &&
                    (target.tagName.toLowerCase() == 'a' || $(target).closest('a').length > 0)
//                    &&
//                    target.href && target.getAttribute('target') == '_blank'
                ) {
                    actionLog[ data.logIndex ]  = null
                    if (data.isDouble) actionLog[ data.logIndex - 1 ]  = null
                    
                    data.next()
                    
                    return true
                } else
                    return false
            }
            
            Joose.A.each(dummy, function (value, i) {
                var xy = [ me.randomBetween(offset.left, right), me.randomBetween(offset.top, bottom) ];

                switch (me.randomBetween(0, 4)) {
                    case 0:
                        actionLog.push({
                            'click' : xy
                        })

                        // Inject waitForSelector : 'body' to make sure we always have a body
                        queue.addAsyncStep({
                            action          : function (data) {
                                me.waitForSelector('body', data.next);
                            }
                        });

                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreActionOnAnchor(data)) me.click(data.xy, data.next)
                            },
                            xy              : xy,
                            logIndex        : actionLog.length - 1
                        });
                    break;

                    case 1:
                        actionLog.push({
                            'doubleclick'   : xy
                        })

                        // Inject waitForSelector : 'body' to make sure we always have a body
                        queue.addAsyncStep({
                            action          : function (data) {
                                me.waitForSelector('body', data.next);
                            }
                        });

                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreActionOnAnchor(data)) me.doubleClick(data.xy, data.next)
                            },
                            xy              : xy,
                            logIndex        : actionLog.length - 1
                        });
                    break;

                    case 2:
                        // Make sure right-clicking can be done on this platform (just do 'click' on mobile devices)
                        if ("oncontextmenu" in window) {
                            actionLog.push({
                                'rightclick'    : xy
                            })
                        } else {
                            actionLog.push({
                                'click'    : xy
                            })
                        }

                        // Inject waitForSelector : 'body' to make sure we always have a body
                        queue.addAsyncStep({
                            action          : function (data) {
                                me.waitForSelector('body', data.next);
                            }
                        });

                        queue.addAsyncStep({
                            action          : function (data) {
                                if ("oncontextmenu" in window) {
                                    me.rightClick(data.xy, data.next)
                                } else {
                                    if (!ignoreActionOnAnchor(data)) me.click(data.xy, data.next)
                                }
                            },
                            xy              : xy
                        });
                    break;

                    case 3:
                        var dragTo      = [ me.randomBetween(offset.left, right), me.randomBetween(offset.top, bottom) ]

                        actionLog.push({
                            action  : 'drag',
                            target  : xy,
                            to      : dragTo
                        })

                        // Inject waitForSelector : 'body' to make sure we always have a body
                        queue.addAsyncStep({
                            action          : function (data) {
                                me.waitForSelector('body', data.next);
                            }
                        });

                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreActionOnAnchor(data)) {
                                    me.drag(data.dragFrom, data.dragTo, null, data.next)
                                }
                            },
                            dragFrom        : xy,
                            dragTo          : dragTo
                        });
                    break;

                    case 4:
                        var text = me.getRandomTypeString(15)

                        actionLog.push({
                            'click' : xy
                        })
                        actionLog.push({
                            'type'  : text
                        })

                        // Inject waitForSelector : 'body' to make sure we always have a body
                        queue.addAsyncStep({
                            action          : function (data) {
                                me.waitForSelector('body', data.next);
                            }
                        });
                        
                        // First click somewhere then type
                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreActionOnAnchor(data)) {
                                    me.click(data.xy, function () {
                                        me.waitForSelector('body', function () {
                                            me.type(null, text, data.next)
                                        });
                                    })
                                }
                            },
                            xy              : xy,
                            logIndex        : actionLog.length - 1,
                            isDouble        : true
                        });
                        break;
                }
            })

            var checkerActivated    = false

            var assertionChecker    = function () {
                checkerActivated    = true

                if (me.nbrExceptions) me.warn(R.get('monkeyActionLog') + ":" + JSON.stringify(actionLog))

                me.is(me.nbrExceptions, 0, description || R.get('monkeyNoExceptions'));
            }

            this.on('beforetestfinalizeearly', assertionChecker)

            queue.run(function () {
                if (!checkerActivated) {
                    me.un('beforetestfinalizeearly', assertionChecker)

                    assertionChecker()
                }

                this.suppressPassedWaitForAssertion = false;

                me.processCallbackFromTest(callback, [actionLog], scope || me)
            });
        },

        /**
         * Passes if the element has the supplied CSS classname
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} cls The class name to check for
         * @param {String} [description] The description for the assertion
         */
        hasCls : function (el, cls, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            if (this.$(el).hasClass(cls)) {
                this.pass(description, {
                    descTpl     : R.get('elementHasClass') + ' {cls}',
                    cls         : cls
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasCls',

                    got             : el.className,
                    gotDesc         : R.get('elementClasses'),
                    need            : cls,
                    needDesc        : R.get('needClass')
                })
            }
        },


        /**
         * Passes if the element does not have the supplied CSS classname
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} cls The class name to check for
         * @param {String} [description] The description for the assertion
         */
        hasNotCls : function (el, cls, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            if (!this.$(el).hasClass(cls)) {
                this.pass(description, {
                    descTpl         : R.get('elementHasNoClass') + ' {cls}',
                    cls             : cls
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasNotCls',
                    got             : el.className,
                    gotDesc         : R.get('elementClasses'),
                    annotation      : R.get('elementHasClass') + ' [' + cls + ']'
                })
            }
        },

        /**
         * Passes if the element has the supplied style value
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} property The style property to check for
         * @param {String} value The style value to check for
         * @param {String} [description] The description for the assertion
         */
        hasStyle : function (el, property, value, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            if (this.$(el).css(property) === value) {
                this.pass(description, {
                    descTpl         : R.get('hasStyleDescTpl'),
                    value           : value,
                    property        : property
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasStyle',
                    got             : this.$(el).css(property),
                    gotDesc         : R.get('elementStyles'),
                    need            : value,
                    needDesc        :  R.get('needStyle')
                });
            }
        },


        /**
         * Passes if the element does not have the supplied style value
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} property The style property to check for
         * @param {String} value The style value to check for
         * @param {String} [description] The description for the assertion
         */
        hasNotStyle : function (el, property, value, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            if (this.$(el).css(property) !== value) {
                this.pass(description, {
                    descTpl         : R.get('hasNotStyleDescTpl'),
                    value           : value,
                    property        : property
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasNotStyle',
                    got             : el.style.toString(),
                    gotDesc         : R.get('elementStyles'),
                    annotation      : R.get('hasTheStyle') + ' [' + property + ']'
                });
            }
        },

        /**
         * Waits for a certain CSS selector to be found at the passed XY coordinate, and calls the callback when found.
         * The callback will receive the element from the passed XY coordinates.
         *
         * @param {Array} xy The x and y coordinates to query
         * @param {String} selector The CSS selector to check for
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelectorAt : function(xy, selector, callback, scope, timeout) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!selector) throw R.get('noCssSelector');

            var me      = this

            return this.waitFor({
                method          : function() {
                    var el = me.elementFromPoint(xy[0], xy[1], true);

                    if (el && me.$(el).is(selector)) return el;
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForSelectorAt',
                description     : ' ' + R.get('selector') + ' "' + selector + '" ' + R.get('toAppearAt') + ': [' + xy.toString() + ']'
            });
        },

        /**
         * Waits for a certain CSS selector to be found at current cursor position, and calls the callback when found.
         * The callback will receive the element found.
         *
         * @param {String} selector The CSS selector to check for
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelectorAtCursor : function(selector, callback, scope, timeout) {
            return this.waitForSelectorAt(this.currentPosition, selector, callback, scope, timeout);
        },

        /**
         * Waits for a certain CSS selector to be found in the DOM, and then calls the callback supplied.
         * The callback will receive the results of jQuery selector.
         *
         * @param {String} selector The CSS selector to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelector : function(selector, root, callback, scope, timeout) {
            var R           = Siesta.Resource('Siesta.Test.Element');
            var me          = this;

            if (!selector) throw R.get('noCssSelector');

            if (jQuery.isFunction(root)) {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            }

            if (root) root  = this.normalizeElement(root);

            return this.waitFor({
                method          : function() {
                    var result = me.$(selector, root);
                    if (result.length > 0) return result;
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForSelector',
                description     : ' ' + R.get('selector') + ' "' + selector + '" ' + R.get('toAppear')
            });
        },


        /**
         * Waits till all the CSS selectors from the provided array to be found in the DOM, and then calls the callback supplied.
         *
         * @param {Array[String]} selectors The array of CSS selectors to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelectors : function(selectors, root, callback, scope, timeout) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (selectors.length < 1) throw R.get('waitForSelectorsBadInput');

            if (jQuery.isFunction(root)) {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            }

            if (root) root  = this.normalizeElement(root);

            var me          = this

            return this.waitFor({
                method          :  function () {
                    var allPresent  = true

                    Joose.A.each(selectors, function (selector) {
                        if (me.$(selector, root).length === 0) {
                            allPresent = false
                            // stop iteration
                            return false
                        }
                    })

                    return allPresent
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForSelectors',
                description     : ' ' + R.get('selectors') + ' "' + selectors + '" ' + R.get('toAppear')
            });
        },



        /**
         * Waits for a certain CSS selector to not be found in the DOM, and then calls the callback supplied.
         *
         * @param {String} selector The CSS selector to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelectorNotFound : function(selector, root, callback, scope, timeout) {
            var R           = Siesta.Resource('Siesta.Test.Element');
            var me          = this;

            if (!selector) throw 'A CSS selector must be supplied';

            if (jQuery.isFunction(root)) {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            }

            if (root) root  = this.normalizeElement(root);

            return this.waitFor({
                method          : function() { return me.$(selector, root).length === 0; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForSelectorNotFound',
                description     : ' ' + R.get('selector') + ' "' + selector + '" ' + R.get('toDisappear')
            });
        },


        /**
         * Waits until the passed element becomes "visible" in the DOM and calls the provided callback.
         * Please note, that "visible" means element will just have a DOM node, and still may be hidden by another visible element.
         *
         * The callback will receive the passed element as the 1st argument.
         *
         * See also {@link #waitForElementTop} method.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementVisible : function(el, callback, scope, timeout) {
            var R       = Siesta.Resource('Siesta.Test.Element');

            return this.waitFor({
                method          : function() {
                    var normalized = this.normalizeElement(el, true);

                    if (normalized && this.isElementVisible(normalized)) return normalized;
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementVisible',
                description     : ' ' + R.get('element') + ' "' + el.toString() + '" ' + R.get('toAppear')
            });
        },

        /**
         * Waits until the passed element is becomes not "visible" in the DOM and call the provided callback.
         * Please note, that "visible" means element will just have a DOM node, and still may be hidden by another visible element.
         *
         * The callback will receive the passed element as the 1st argument.
         *
         * See also {@link #waitForElementNotTop} method.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementNotVisible : function(el, callback, scope, timeout) {
            el          = this.normalizeElement(el);

            var R       = Siesta.Resource('Siesta.Test.Element');
            var me      = this;

            return this.waitFor({
                method          : function() { return !me.isElementVisible(el) && el; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementNotVisible',
                description     :  ' ' + R.get('element') + ' "' + el.toString() +  '" ' + R.get('toDisappear')
            });
        },


        /**
         * Waits until the passed element is the 'top' element in the DOM and call the provided callback.
         *
         * The callback will receive the passed element as the 1st argument.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementTop : function(el, callback, scope, timeout) {
            var R       = Siesta.Resource('Siesta.Test.Element');

            return this.waitFor({
                method          : function() {
                    var normalized = this.normalizeElement(el, true);

                    if (normalized && this.elementIsTop(normalized, true)) {
                        return normalized;
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementTop',
                description     : ' ' + R.get('element') + ' "' + el.toString() + '" ' + R.get('toBeTopEl')
            });
        },

        /**
         * Waits until the passed element is not the 'top' element in the DOM and calls the provided callback with the element found.
         *
         * The callback will receive the actual top element.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementNotTop : function(el, callback, scope, timeout) {
            el          = this.normalizeElement(el);

            var R       = Siesta.Resource('Siesta.Test.Element');
            var me      = this

            return this.waitFor({
                method          : function() {
                    if (!me.elementIsTop(el, true)) {
                        var center = me.findCenter(el);
                        return me.elementFromPoint(center[0], center[1], true);
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementNotTop',
                description     : ' ' + R.get('element') + ' "' + el.toString() + '" ' + R.get('toNotBeTopEl')
            });
        },

        /**
         * Passes if the element is visible.
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsVisible : function(el, description) {
            el = this.normalizeElement(el, false, false, false, { ignoreNonVisible : false });
            this.ok(this.isElementVisible(el), description);
        },

        /**
         * Passes if the element is not visible.
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsNotVisible : function(el, description) {
            el = this.normalizeElement(el, false, false, false, { ignoreNonVisible : false });
            this.notOk(this.isElementVisible(el), description);
        },

        /**
         * Utility method which checks if the passed method is the 'top' element at its position. By default, "top" element means,
         * that center point of the element is not covered with any other elements. You can also check any other point reachability
         * using the "offset" argument.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {Array} offset An array of 2 elements, defining "x" and "y" offset from the left-top corner of the element
         *
         * @return {Boolean} true if the element is the top element.
         */
        elementIsTop : function (el, allowChildren, offset) {
            el              = this.normalizeElement(el);

            // Workaround for OPTION elements which don't behave like normal DOM elements. jQuery always consider them invisible.
            // Decide based on visibility of the parent SELECT node
            if (el && el.nodeName.toLowerCase() === 'option') {
                el = this.$(el).closest('select')[0];
            }

            var elDoc       = el.ownerDocument

            var localPoint  = this.getTargetCoordinate(el, true, offset)
            var foundEl     = elDoc.elementFromPoint(localPoint[ 0 ], localPoint[ 1 ]);

            return foundEl && (foundEl === el || (allowChildren && this.$(foundEl).closest(el).length > 0));
        },

        // Helper method to find out if an offset is targeting a point outside its target
        // Assumes the el passed is visible
        isOffsetInsideElementBox : function (el, offset) {
            if (!offset) return true;

            var $el = this.$(this.normalizeElement(el));
            var w   = $el.outerWidth();
            var h   = $el.outerHeight();

            offset = this.normalizeOffset(offset, $el);

            return offset[0] >= 0 && offset[0] < w &&
                   offset[1] >= 0 && offset[1] < h;
        },

        /**
         * Passes if the element is found at the supplied xy coordinates.
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Array} xy The xy coordinate to query.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        elementIsAt : function(el, xy, allowChildren, description) {
            el              = this.normalizeElement(el);

            var foundEl     = this.elementFromPoint(xy[0], xy[1], true);
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!foundEl) {
                this.fail(description, {
                    assertionName       : 'elementIsAt',
                    got                 : { x: xy[0], y : xy[1] },
                    gotDesc             : R.get('Position'),
                    annotation          : R.get('noElementAtPosition')
                });
            } else if (allowChildren) {
                if (foundEl === el || this.$(foundEl).closest(el).length > 0) {
                    this.pass(description, {
                        descTpl         : R.get('elementIsAtDescTpl'),
                        x               : xy[ 0 ],
                        y               : xy[ 1 ]
                    });
                } else {
                    this.fail(description, {
                        assertionName   : 'elementIsAt',
                        got             : foundEl,
                        gotDesc         : R.get('topElement'),
                        need            : el,
                        needDesc        : R.get('allowChildrenDesc'),
                        annotation      : R.get('allowChildrenAnnotation')
                    });
                }
            } else {
                if (foundEl === el) {
                    this.pass(description, {
                        descTpl         : R.get('elementIsAtPassTpl'),
                        x               : xy[ 0 ],
                        y               : xy[ 1 ]
                    });
                } else {
                    this.fail(description, {
                        assertionName   : 'elementIsAt',
                        got             : foundEl,
                        gotDesc         : R.get('topElement'),
                        need            : el,
                        needDesc        : 'Should be',
                        annotation      : R.get('noChildrenFailAnnotation')
                    });
                }
            }
        },

        /**
         * Passes if the element is the top element (using its center xy coordinates). "Top" element means,
         * that element is not covered with any other elements.
         *
         * This assertion can be used for example to test, that some element, that appears only when mouse hovers some other element is accessible by user
         * with mouse (which is not always true because of various z-index issues).
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         * @param {Boolean} strict true to check all four corners of the element. False to only check at element center.
         */
        elementIsTopElement : function(el, allowChildren, description, strict) {
            el = this.normalizeElement(el);

            if (strict) {
                var o           = this.$(el).offset();
                var R           = Siesta.Resource('Siesta.Test.Element');
                var region      = {
                    top     : o.top,
                    right   : o.left + this.$(el).outerWidth(),
                    bottom  : o.top + this.$(el).outerHeight(),
                    left    : o.left
                };

                this.elementIsAt(el, [region.left+1, region.top+1], allowChildren, description + ' ' + R.get('topLeft'));
                this.elementIsAt(el, [region.left+1, region.bottom-1], allowChildren, description + ' ' + R.get('bottomLeft'));
                this.elementIsAt(el, [region.right-1, region.top+1], allowChildren, description + ' ' + R.get('topRight'));
                this.elementIsAt(el, [region.right-1, region.bottom-1], allowChildren, description + ' ' + R.get('bottomRight'));
            } else {
                this.elementIsAt(el, this.findCenter(el), allowChildren, description);
            }
        },

        /**
         * Passes if the element is not the top element (using its center xy coordinates).
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        elementIsNotTopElement : function(el, allowChildren, description) {
            el              = this.normalizeElement(el);
            var center      = this.findCenter(el);

            var foundEl     = this.elementFromPoint(center[ 0 ], center[ 1 ], true);

            if (!foundEl) {
                var R           = Siesta.Resource('Siesta.Test.Element');

                this.pass(description, {
                    descTpl         : R.get('elementIsNotTopElementPassTpl')
                });

                return
            }

            if (allowChildren) {
                this.ok(foundEl !== el && this.$(foundEl).closest(el).length === 0, description);
            } else {
                this.isnt(foundEl, el, description);
            }
        },

        /**
         * Passes if the element is found at the supplied xy coordinates.
         *
         * @param {String} selector The selector to query for
         * @param {Array} xy The xy coordinate to query.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        selectorIsAt : function(selector, xy, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!selector) throw R.get('noCssSelector');

            var foundEl = this.$(this.elementFromPoint(xy[0], xy[1], true));

            if (foundEl.has(selector).length > 0 || foundEl.closest(selector).length > 0) {
                this.pass(description, {
                    descTpl         : R.get('selectorIsAtPassTpl'),
                    selector        : selector,
                    xy              : xy
                });
            } else {
                this.fail(description, {
                    got             : foundEl[0].outerHTML ? foundEl[0].outerHTML : foundEl[0].innerHTML,
                    need            : R.get('elementMatching') + ' ' + selector,
                    assertionName   : 'selectorIsAt',
                    annotation      : R.get('selectorIsAtFailAnnotation') + ' [' + xy + ']'
                });
            }
        },

        /**
         * Passes if the selector is found in the DOM
         *
         * @param {String} selector The selector to query for
         * @param {String} [description] The description for the assertion
         */
        selectorExists : function(selector, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!selector) throw R.get('noCssSelector');

            if (this.$(selector).length <= 0) {
                this.fail(description, R.get('selectorExistsFailTpl') + ' : ' + selector);
            } else {
                this.pass(description, {
                    descTpl         : R.get('selectorExistsPassTpl'),
                    selector        : selector
                });
            }
        },

        /**
         * Passes if the selector is not found in the DOM
         *
         * @param {String} selector The selector to query for
         * @param {String} [description] The description for the assertion
         */
        selectorNotExists : function(selector, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');
            var els         = this.$(selector);

            if (els.length > 0) {
                this.fail(description, {
                    descTpl     : R.get('selectorNotExistsFailTpl') + ': ' + selector,
                    annotation  : $.map(els, function(el, i) { return (i+1) + ". " + el.className; }).join('\r\n')
                });
            } else {
                this.pass(description, {
                    descTpl         : R.get('selectorNotExistsPassTpl'),
                    selector        : selector
                });
            }
        },

        /**
         * Waits until the passed scroll property of the element has changed.
         *
         * The callback will receive the new `scroll` value.
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} side 'left' or 'top'
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForScrollChange : function(el, side, callback, scope, timeout) {
            el                  = this.normalizeElement(el);
            var scrollProp      = 'scroll' + Joose.S.uppercaseFirst(side);
            var original        = el[scrollProp];
            var R               = Siesta.Resource('Siesta.Test.Element');

            return this.waitFor({
                method          : function() { if (el[scrollProp] !== original) return el[scrollProp]; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForScrollChange',
                description     : ' ' + scrollProp + ' ' + R.get('toChangeForElement') + ' ' + el.toString()
            });
        },

        /**
         * Waits until the `scrollLeft` property of the element has changed.
         *
         * The callback will receive the new `scrollLeft` value.
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForScrollLeftChange : function(el, callback, scope, timeout) {
            return this.waitForScrollChange(this.normalizeElement(el), 'left', callback, scope, timeout);
        },

        /**
         * Waits until the scrollTop property of the element has changed
         *
         * The callback will receive the new `scrollTop` value.
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForScrollTopChange : function(el, callback, scope, timeout) {
            return this.waitForScrollChange(this.normalizeElement(el), 'top', callback, scope, timeout);
        },


        /**
         * This method changes the "scrollTop" property of the dom element, then waits for the "scroll" event from it and calls the provided callback.
         *
         * For example:
         *

    // scroll the domEl to the 100px offset, wait for "scroll" event, call the callback
    t.scrollVerticallyTo(domEl, 100, function () { ... })

         * Optionally it can also wait some additional time before calling the callback:
         *
    // scroll the domEl to the 100px offset, wait for "scroll" event, wait 1000ms more, call the callback
    t.scrollVerticallyTo(domEl, 100, 1000, function () { ... })

         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Number} newTop The value for the "scrollTop" property
         * @param {Number} [delay] Additional delay, this argument can be omitted
         * @param {Function} callback A function to call after "scroll" event has been fired and additional delay completed (if any)
         *
         * @return {Number} The new value of the "scrollTop" property of the dom element
         */
        scrollVerticallyTo : function (el, newTop, delay, callback) {
            el                          = this.normalizeElement(el);

            if (this.typeOf(delay) != 'Number') {
                callback                = delay
                delay                   = null
            }

            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout;

            var waiter                  = this.waitForEvent(el, 'scroll', function () {
                if (delay > 0) {
                    var async               = me.beginAsync(delay + 100)

                    originalSetTimeout(function () {
                        me.endAsync(async)

                        me.processCallbackFromTest(callback)
                    }, delay)
                } else
                    me.processCallbackFromTest(callback)
            })

            var prevScrollTop   = el.scrollTop

            el.scrollTop        = newTop

            // no event will be fired in this case probably - force the waiting operation to complete
            if (el.scrollTop == prevScrollTop) {
                waiter.force()
            }

            // re-read the scrollTop value and return it (newTop can be too big for example and will be truncated)
            return el.scrollTop
        },


        /**
         * This method changes the "scrollLeft" property of the dom element, then waits for the "scroll" event from it and calls the provided callback.
         *
         * For example:
         *

    // scroll the domEl to the 100px offset, wait for "scroll" event, call the callback
    t.scrollHorizontallyTo(domEl, 100, function () { ... })

         * Optionally it can also wait some additional time before calling the callback:
         *
    // scroll the domEl to the 100px offset, wait for "scroll" event, wait 1000ms more, call the callback
    t.scrollHorizontallyTo(domEl, 100, 1000, function () { ... })

         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Number} newLeft The value for the "scrollLeft" property
         * @param {Number} [delay] Additional delay, this argument can be omitted
         * @param {Function} callback A function to call after "scroll" event has been fired and additional delay completed (if any)
         *
         * @return {Number} The new value of the "scrollLeft" property of the dom element
         */
        scrollHorizontallyTo : function (el, newLeft, delay, callback) {
            el                          = this.normalizeElement(el);

            if (this.typeOf(delay) != 'Number') {
                callback                = delay
                delay                   = null
            }

            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout;

            var waiter                  = this.waitForEvent(el, 'scroll', function () {
                if (delay > 0) {
                    var async               = me.beginAsync(delay + 100)

                    originalSetTimeout(function () {
                        me.endAsync(async)

                        me.processCallbackFromTest(callback)
                    }, delay)
                } else
                    me.processCallbackFromTest(callback)
            })

            var prevScrollLeft  = el.scrollLeft

            el.scrollLeft       = newLeft

            // no event will be fired in this case probably - force the waiting operation to complete
            if (el.scrollLeft == prevScrollLeft) {
                waiter.force()
            }

            // re-read the scrollLeft value and return it (newLeft can be too big for example and will be truncated)
            return el.scrollLeft
        },



        /**
         * This method accepts an array of the DOM elements and performs a mouse click on them, in order. After that, it calls the provided callback:
         *

       t.chainClick([ el1, el2 ], function () {
            ...
       })

         * the elements can be also provided inline, w/o wrapping array:

       t.chainClick(el1, el2, function () {
            ...
       })


         *
         * @param {Array[Siesta.Test.ActionTarget]} elements The array of elements to click
         * @param {Function} callback The function to call after clicking all elements
         */
        chainClick : function () {
            var args        = Array.prototype.concat.apply([], arguments)
            var callback

            if (this.typeOf(args[ args.length - 1 ]) == 'Function') callback = args.pop()

            // poor-man Array.flatten, with only 1 level of nesting support
            args            = Array.prototype.concat.apply([], args)

            var steps       = []

            Joose.A.each(args, function (arg) {
                steps.push({
                    action      : 'click',
                    target      : arg
                })
            })

            var me          = this

            if (callback) steps.push(function () {
                me.processCallbackFromTest(callback)
            })

            this.chain.apply(this, steps)
        },


        /**
         * This method is a wrapper around the {@link #chainClick}, it performs a click on the every element found with the DOM query.
         *
         * You can specify the optional `root` element to start the query from:
         *
         *      t.clickSelector('.my-grid .x-grid-row', someEl, function () {})
         *
         * or omit it (query will start from the document):
         *
         *      t.clickSelector('.my-grid .x-grid-row', function () {})
         *
         * The provided callback will receive an array with DOM elements - result of query.
         *
         *
         * @param {String} selector The selector/xpath query
         * @param {Siesta.Test.ActionTarget} [root=document] The root of the query, defaults to the `document`. You can omit this parameter.
         * @param {Function} [callback]
         * @param {Object} [scope]
         */
        clickSelector : function (selector, root, callback, scope) {
            if (arguments.length > 1 && this.typeOf(arguments[ 1 ]) == 'Function') {
                scope       = callback;
                callback    = root;
                root        = null;
            }

            if (root) root = this.normalizeElement(root);

            // convert the result from jQuery dom query to a usual array 
            var result      = Joose.A.map(this.$(selector, root), function (el) { return el });

            this.chainClick(result, function () { callback && callback.call(scope || this, result) })
        },


        /**
         * This assertion passes when the DOM query with specified selector returns the expected number of elements
         *
         * You can specify the optional `root` element to start the query from:
         *
         *      t.selectorCountIs('.x-grid-row', grid, 5, "Grid has 5 rows")
         *
         * or omit it (query will start from the document):
         *
         *      t.selectorCountIs('.x-grid-row', 0, "No grid rows on the page")
         *
         * @param {String} selector DOM query selector
         * @param {Siesta.Test.ActionTarget} [root] An optional root element to start the query from, if omited query will start from the document
         * @param {Number} count The expected number of elements in the query result
         * @param {String} [description] The description for the assertion
         */
        selectorCountIs : function (selector, root, count, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!selector) throw R.get('noCssSelector');

            if (this.typeOf(root) == 'Number') {
                description     = count
                count           = root
                root            = null
            } else
                root            = this.normalizeElement(root)

            var inDOMCount  = this.$(selector, root).length

            if (inDOMCount != count) {
                this.fail(description, {
                    assertionName   : 'selectorCountIs',
                    descTpl         : R.get('selectorCountIsFailTpl'),
                    selector        : selector,
                    got             : inDOMCount,
                    need            : count
                });
            } else {
                this.pass(description, {
                    descTpl         : R.get('selectorCountIsPassTpl'),
                    count           : count,
                    selector        : selector
                });
            }
        },


        /**
         * Passes if the passed element is inside of the visible viewport
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        isInView : function (el, description) {
            if (this.elementIsInView(el)) {
                var R           = Siesta.Resource('Siesta.Test.Element');

                this.pass(description, {
                    descTpl         : R.get('isInViewPassTpl')
                })
            }
            else
                this.fail(description, {
                    assertionName   : 'isInView'
                })
        },

        /**
         * Returns true if the passed element is inside of the visible viewport
         *
         * @param {Siesta.Test.ActionTarget} el The element
         */
        elementIsInView : function(el) {
            el              = this.normalizeElement(el);

            var inView      = false;
            var offset      = this.$(el).offset();

            if (offset) {
                var docViewTop      = $(this.global).scrollTop();
                var docViewBottom   = docViewTop + $(this.global).height();

                var elemTop         = offset.top;
                var elemBottom      = elemTop + $(el).height();

                inView              = elemBottom >= docViewTop && elemTop <= docViewBottom;
            }

            return inView;
        },

        /**
         * Waits until element is inside in the visible viewport and then calls the supplied callback
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitUntilInView : function (el, callback, scope, timeout) {
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test.Element');

            this.waitFor({
                method          : function() {
                    var normalized  = this.normalizeElement(el, true);

                    if(normalized && me.elementIsInView(normalized)) {
                        return normalized;
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitUntilInView',
                description     : el.toString + ' ' + R.get('toAppearInTheViewport')
            });
        },


        findScrolledParent : function(el) {
            var body   = el.ownerDocument.body;
            var parent = this.$(el);

                while (parent = parent.parent(), parent.length && parent[ 0 ] != body) {
                if (parent[0].scrollTop > 0 || parent[0].scrollLeft > 0) {
                    return parent[0];
                }
            }
        },

        focus : function (el, tryPreventScrollChange) {
            var prevIndex   = el.getAttribute('tabIndex')
            var scrolledParent;

            if (this.activeElement() === el) return;

            try {
                if (prevIndex == null) el.setAttribute('tabIndex', -1)

                if (tryPreventScrollChange) {
                    var oldScrollLeft, oldScrollTop;

                    // In Chrome, when calling focus() manually on an element - it's scrolled into view in its parent hierarchy
                    // Try to detect this and restore (This is far from optimal since application might have a listener triggering a desired
                    // scroll of this element. But not triggering focus() on mousedown seems like a worse situation
                    scrolledParent = this.findScrolledParent(el);

                    if (scrolledParent) {
                        oldScrollLeft = scrolledParent.scrollLeft;
                        oldScrollTop  = scrolledParent.scrollTop;
                    }
                }

                el.focus()

                if (scrolledParent && tryPreventScrollChange) {
                    if (oldScrollLeft !== scrolledParent.scrollLeft)  {
                        scrolledParent.scrollLeft = oldScrollLeft;
                    }

                    if (oldScrollTop !== scrolledParent.scrollTop)  {
                        scrolledParent.scrollTop = oldScrollTop;
                    }
                }
            } catch (e) {
            } finally {
                if (prevIndex == null)
                    el.removeAttribute('tabIndex')
                else
                    el.setAttribute('tabIndex', prevIndex)
            }
        },


        /**
         * Passes if the passed element has no content (whitespace will be trimmed)
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsEmpty : function (el, description) {

            el              = this.normalizeElement(el);

            if (el && this.isElementEmpty(el)) {
                var R           = Siesta.Resource('Siesta.Test.Element');

                this.pass(description, {
                    descTpl         : R.get('elementIsEmptyPassTpl')
                })
            }
            else
                this.fail(description, {
                    got             : el.innerHTML,
                    need            : '',
                    assertionName   : 'elementIsEmpty'
                })
        },

        /**
         * Passes if the passed element has some non-whitespace content
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsNotEmpty : function (el, description) {
            el              = this.normalizeElement(el);

            if (el && !this.isElementEmpty(el)) {
                var R           = Siesta.Resource('Siesta.Test.Element');

                this.pass(description, {
                    descTpl         : R.get('elementIsNotEmptyPassTpl')
                })
            }
            else
                this.fail(description, {
                    assertionName   : 'elementIsNotEmpty'
                })
        },

        /**
         * Waits until the innerHTML of the passed element is empty (whitespace will be trimmed)
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementEmpty : function(el, callback, scope, timeout) {
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            return this.waitFor({
                method          : function() { return me.isElementEmpty(el); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementEmpty',
                description     : ' ' + R.get('elementToBeEmpty')
            });
        },

        /**
         * Waits until the innerHTML of the passed element contains some non-whitespace text.
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementNotEmpty : function(el, callback, scope, timeout) {
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            return this.waitFor({
                method          : function() { return !me.isElementEmpty(el); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementNotEmpty',
                description     : ' ' + R.get('elementToNotBeEmpty')
            });
        },

        isElementEmpty : function (el) {
            return !el.innerHTML.replace(/^\s+|\s+$/g, '');
        },

        /**
         * Passes if the target element has an attribute with the provided value.
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} attribute The attribute
         * @param {String} value The value
         * @param {String} [description] The description for the assertion
         */
        hasAttributeValue : function(el, attribute, value, description) {
            el              = this.normalizeElement(el);

            var foundValue = el.getAttribute(attribute);

            this.is(foundValue, value, description);
        },

        /**
         * Passes if the passed element has the expected value as its "value" property (use with SELECT, INPUT type elements).
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Mixed} value The value to compare to.
         * @param {String} [description] The description of the assertion
         */
        hasValue : function(el, value, description) {
            el              = this.normalizeElement(el);

            var foundValue = el.value;

            this.is(foundValue, value, description);
        },


        isElementFocusable : function(el) {
            var disabled = el.getAttribute('disabled') === "true";
            var nodeName = el.nodeName.toLowerCase();
            // Other tags are covered in isTextInput
            var focusable = { a : 1, area : 1, button : 1, object : 1, select : 1 };

            return !disabled &&
                (
                this.isTextInput(el) ||
                (el.nodeName.toLowerCase() === 'input' && el.type === 'file') ||
                nodeName in focusable ||
                (el.getAttribute('tabIndex') != null && (!$.browser.msie || String(el.getAttribute('unselectable')).toLowerCase() != 'on'))
                );
        }
    }
});
;
/**
@class Siesta.Test.Browser
@extends Siesta.Test
@mixin Siesta.Test.Simulate.Event
@mixin Siesta.Test.TextSelection 
@mixin Siesta.Test.Simulate.Mouse
@mixin Siesta.Test.Simulate.Keyboard


A base class for testing a generic browser functionality. It has various DOM-related assertions, and is not optimized for any framework.

*/
Class('Siesta.Test.Browser', {
    
    isa         : Siesta.Test,
        
    does        : [
        Siesta.Util.Role.CanParseBrowser,
        Siesta.Test.Simulate.Event,
        Siesta.Test.Simulate.Mouse,
        Siesta.Test.Simulate.Touch,
        Siesta.Test.Simulate.Keyboard,
        Siesta.Test.Element,
        Siesta.Test.TextSelection
    ],

    has : {
        // this will be a shared array instance between all subtests
        // it should not be overwritten, instead modify individual elements:
        // NO: this.currentPosition = [ 1, 2 ]
        // YES: this.currentPosition[ 0 ] = 1
        // YES: this.currentPosition[ 1 ] = 2
        currentPosition         : {
           init : function () { return [ 0, 0 ]; }
        },
        
        forceDOMVisible         : false,
        isDOMForced             : false,
        
        browserInfo             : {
            lazy    : function () {
                return this.parseBrowser(window.navigator.userAgent)
            }
        },

        nextConfirmValue        : null,
        nextPromptReturnValue   : null,
        
        realAlert               : null,
        realConfirm             : null,
        realPrompt              : null,
        realPrint               : null,
        realOpen                : null,
        
        previousConfirm         : null,
        previousPrompt          : null,
        
//        blurListener            : null,
        restartOnBlur           : false,
        
        popups                  : Joose.I.Array
    },

    after : {
        cleanup : function () {
            this._global    = null
            
            this.realAlert  = this.realConfirm = this.realPrompt = this.realPrint = this.realOpen = null
            
            this.previousPrompt = this.previousConfirm = null
            
            this.blurListener   = null
            
            Joose.A.each(this.popups, function (handle) {
                if (!handle.popup.closed) handle.popup.close()
            })
            
            this.popups.length  = 0
            this.popups         = null
        }
    },

    methods : {
        
        onBeforeTestFinalize : function () {
            var global          = this.global

            // If expectAlertMessage(which overwrites the alert method) was called but no alert() call happened - fail the test
            if (global.alert.__EXPECTED_ALERT__) {
                this.fail(Siesta.Resource('Siesta.Test.Browser','alertMethodNotCalled'))
            }
            
            this.SUPERARG(arguments)
        },
        

        launch : function () {
            var emptyFn     = function () {};

            var me          = this
            var win         = this.global
            
            // top test
            if (!me.parent) {
                me.realAlert        = win.alert
                me.realConfirm      = win.confirm
                me.realPrompt       = win.prompt
                me.realPrint        = win.print
                me.realOpen         = win.open
                
                if (!me.harness.browserWindowHasFocus() && !$.browser.safari) me.onWindowBlur()
                
                // trying to focus the window (hopefully fixes the tab key issues)
                win.focus && win.focus()
                
//                win.addEventListener && win.addEventListener('blur', me.blurListener = function () {
//                    if ($.browser.mozilla && win.document.getElementsByTagName('iframe').length > 0)
//                        // this "waitFor" can be interrupted, but only by forceful test finalization, which
//                        // happens when test throws exception for example, so it fails anyway
//                        me.waitFor({
//                            method              : 0,
//                            suppressAssertion   : true,
//                            callback            : function () { me.onWindowBlur() }
//                        })
//                    else
//                        me.onWindowBlur()
//                })
            }
            
            // WARN: behavior when several sub-tests are running at the same time is not well-defined
            me.previousConfirm      = win.confirm
            me.previousPrompt       = win.prompt

            win.alert               = win.print = emptyFn;

            win.confirm = function () {
                var retVal                  = typeof me.nextConfirmValue === 'boolean' ? me.nextConfirmValue : true;

                me.nextConfirmValue         = null;

                return retVal;
            };

            win.prompt = function () {
                var retVal                  = me.nextPromptReturnValue || '';

                me.nextPromptReturnValue    = null;

                return retVal;
            };
            
            win.open = function (url) {
                var popup   = me.realOpen.apply(win, arguments)
                
                if (!popup) 
                    me.fail(Siesta.Resource('Siesta.Test.Browser','popupsDisabled', { url : url }))
                else {
                    me.popups.push({ url : url, popup : popup })
                }
                
                return popup
            }

            this.SUPERARG(arguments)
        },
        
        
        onTestFinalize : function () {
            var win         = this.global

            if (!this.parent) {
                win.confirm = this.previousConfirm;
                win.prompt  = this.previousPrompt;
                
                win.print   = this.realPrint
                win.alert   = this.realAlert
                win.open    = this.realOpen
            } else {
                win.confirm = this.realConfirm;
                win.prompt  = this.realPrompt;
                
                win.alert   = win.print = function () {}
            }
            
//            this.blurListener && win.removeEventListener('blur', this.blurListener)
//            
//            this.blurListener   = null
            
            this.SUPERARG(arguments)
        },
        
        
        onWindowBlur : function (arg1, arg2) {
//            var doc             = this.global.document
//            
//            // ignore the case when focus is moved inside of the child iframe
//            // IGNORE
//            if (!doc.hasFocus && doc.hasFocus()) return
//            
//            var slice           = Array.prototype.slice
//            
//            //                  convert from HTMLCollection to Array
//            var iframes         = slice.apply(doc.getElementsByTagName('iframe'))
//            
//            while (iframes.length) {
//                try {
//                    var innerDoc    = iframes[ 0 ].contentWindow.document
//                    
//                    if (innerDoc.hasFocus()) return
//                    
//                    iframes.push.apply(iframes, slice.apply(innerDoc.getElementsByTagName('iframe')))
//                } catch (e) {
//                }
//                
//                iframes.shift()
//            }
//            // EOF IGNORE
            
            if (this.restartOnBlur) 
                this.fireEvent('focuslost')
            else
                this.warn(Siesta.Resource('Siesta.Test.Browser').get('focusLostWarning', { url : this.url }))
        },

        
        $ : function () {
            var local$ = $.rebindWindowContext(this.global);
            return local$.apply(this.global, arguments);
        },


        isEventPrevented : function (event) {
            // our custom property - takes highest priority
            if (event.preventDefault && this.typeOf(event.preventDefault.$prevented) == 'Boolean') return event.preventDefault.$prevented

            // W3C standards property
            if (this.typeOf(event.defaultPrevented) == 'Boolean') return event.defaultPrevented
            
            return event.returnValue === false
        },
        
        
        // only called for the re-used contexts
        cleanupContextBeforeStart : function () {
            this.cleanupContextBeforeStartDom()
            
            this.SUPER()
        },
        
        
        cleanupContextBeforeStartDom : function () {
            var doc                 = this.global.document
            
            doc.body.innerHTML      = ''
        },
        
        
        getElementPageRect : function (el, $el) {
            $el             = $el || this.$(el)
            
            var offset      = $el.offset()
            
            return new Siesta.Util.Rect({
                left        : offset.left,
                top         : offset.top,
                width       : $el.outerWidth(),
                height      : $el.outerHeight()
            })
        },
        
        
        elementHasScroller : function (el, $el) {
            $el             = $el || this.$(el)
                
            var hasX        = el.scrollWidth != el.clientWidth && $el.css('overflow-x') != 'visible'
            var hasY        = el.scrollHeight != el.clientHeight && $el.css('overflow-y') != 'visible'
            
            return hasX || hasY ? { x : hasX, y : hasY } : false
        },
        
        
        hasForcedIframe : function () {
            return Boolean(
                (this.isDOMForced || this.forceDOMVisible) && (this.scopeProvider instanceof Scope.Provider.IFrame) && this.scopeProvider.iframe
            )
        },
        
        
        elementIsScrolledOut : function (el, offset) {
            var $el                 = this.$(el)
            
            var scrollableParents   = []
            var parent              = $el
            
            var body                = this.global.document.body
            
            while (parent = parent.parent(), parent.length && parent[ 0 ] != body) {
                var hasScroller     = this.elementHasScroller(parent[ 0 ], parent)
                
                if (hasScroller) scrollableParents.unshift({ hasScroller : hasScroller, $el : parent }) 
            }
            
            var $body               = this.$(body)
            var bodyOffset          = $body.offset()
            
            var currentRect         = new Siesta.Util.Rect({
                left        : bodyOffset.left + $body.scrollLeft(),
                top         : bodyOffset.top + $body.scrollTop(),

                // using height / width of the *screen* for BODY tag since it may have 0 height in some cases
                width       : this.$(this.global).width(),
                height      : this.$(this.global).height()
            })

            for (var i = 0; i < scrollableParents.length; i++) {
                var hasScroller     = scrollableParents[ i ].hasScroller
                var $parent         = scrollableParents[ i ].$el
                
                if (hasScroller && hasScroller.x)
                    currentRect     = currentRect.cropLeftRight(this.getElementPageRect($parent[ 0 ], $parent))
                    
                if (currentRect.isEmpty()) return true
                    
                if (hasScroller && hasScroller.y)
                    currentRect     = currentRect.cropTopBottom(this.getElementPageRect($parent[ 0 ], $parent))
                    
                if (currentRect.isEmpty()) return true
            }
            
            var elPageRect          = this.getElementPageRect($el[ 0 ], $el)
            var finalRect           = currentRect.intersect(elPageRect)
            
            if (finalRect.isEmpty()) return true
            
            offset                  = this.normalizeOffset(offset, $el)
            
            return !finalRect.contains(elPageRect.left + offset[ 0 ], elPageRect.top + offset[ 1 ])
        },
        
        
        // returns "true" if scrolling has actually occured
        scrollTargetIntoView : function (target, offset) {
            if (this.typeOf(target) != 'Array') {
                target          = this.normalizeElement(target, true, null, false);
                var isInside    = this.isOffsetInsideElementBox(target, offset);

                if (
                    target && this.isElementVisible(target) &&
                    // If element isn't visible, try to bring it into view
                    isInside && this.elementIsScrolledOut(target, offset)
                ) {
                    // Required to handle the case where the body is scrolled
                    target.scrollIntoView();

                    this.$(target).scrollintoview({ duration : 0 });

                    // If element is still out of view, try manually scrolling first scrollable parent found
                    if (this.elementIsScrolledOut(target, offset)) {
                        // Now we need to look up for first scrollable parent and make sure
                        // it's scrolled matching the target offset
                        var scrollableParent = $(target).closest(':scrollable')[0];

                        if (scrollableParent && offset) {

                            if (offset[0] > 0) {
                                scrollableParent.scrollLeft = Math.max(0, offset[0] - 1);
                            }

                            if (offset[1] > 0) {
                                scrollableParent.scrollTop = Math.max(0, offset[1] - 1);
                            }
                        }
                    }

                    return true
                }
            }
        },

        
        processSubTestConfig : function () {
            var res             = this.SUPERARG(arguments)
            var me              = this
            
            Joose.A.each([ 
                'currentPosition', 
                'actionDelay', 'afterActionDelay', 
                'dragDelay', 'moveCursorBetweenPoints', 'mouseMovePrecision', 'pathBatchSize', 'overEls',
                'realAlert', 'realConfirm', 'realPrompt', 'realPrint', 'realOpen', 'popups'
            ], function (name) {
                res[ name ]     = me[ name ]
            })
            
            res.simulateEventsWith  = me.getSimulateEventsWith()
            
            return res
        },
        
        
        // Normalizes the element to an HTML element. Every 'framework layer' will need to provide its own implementation
        // This implementation accepts either a CSS selector or an Array with xy coordinates.
        normalizeElement : function (el, allowMissing, shallow, detailed) {
            // Quick exit if already an element
            if (el && el.nodeName) return el;

            var matchingMultiple = false

            if (this.typeOf(el) === 'String') {
                // DOM query
                var origEl  = el;

                var wasAdjusted = this.adjustScope(el);

                var query   = this.$(el.indexOf('->') >= 0 ? el.split('->')[1] : el);

                if (wasAdjusted) this.resetScope();

                el          = query[ 0 ];
                matchingMultiple = query.length > 1
                
                if (!allowMissing && !el) {
                    var warning = Siesta.Resource('Siesta.Test.Browser','noDomElementFound') + ': ' + origEl

                    this.warn(warning);
                    throw warning;
                }
            }
            
            if (this.typeOf(el) == 'Array') el = this.elementFromPoint(el[ 0 ], el[ 1 ]);
            
            return detailed ? { el : el, matchingMultiple : matchingMultiple } : el;
        },
        
        
        // this method generally has the same semantic as the "normalizeElement", its being used in 
        // Siesta.Test.Action.Role.HasTarget to determine what to pass to next step
        //
        // on the browser level the only possibility is DOM element
        // but on ExtJS level user can also use ComponentQuery and next step need to receive the 
        // component instance
        normalizeActionTarget : function (el, allowMissing) {
            return this.normalizeElement(el, allowMissing);
        },

        
        
        // private
        getPathBetweenPoints: function (from, to) {
            if (
                typeof from[0] !== 'number' ||
                typeof from[1] !== 'number' ||
                typeof to[0] !== 'number'   ||
                typeof to[1] !== 'number'   ||
                isNaN(from[0])              ||
                isNaN(from[1])              ||
                isNaN(to[0])                ||
                isNaN(to[1]))
            {
                throw 'Incorrect arguments passed to getPathBetweenPoints';
            }

            var stops = [],
                x0 = Math.floor(from[0]),
                x1 = Math.floor(to[0]),
                y0 = Math.floor(from[1]),
                y1 = Math.floor(to[1]),
                dx = Math.abs(x1 - x0),
                dy = Math.abs(y1 - y0),
                sx, sy, err, e2;

            if (x0 < x1) {
                sx = 1;
            } else {
                sx = -1;
            }

            if (y0 < y1) {
                sy = 1;
            } else {
                sy = -1;
            }
            err = dx - dy;
            
            while (x0 !== x1 || y0 !== y1) {
                e2 = 2 * err;
                if (e2 > -dy) {
                    err = err - dy;
                    x0 = x0 + sx;
                }

                if (e2 < dx) {
                    err = err + dx;
                    y0 = y0 + sy;
                }
                stops.push([x0, y0]);
            }

            var last = stops[stops.length-1];

            if (stops.length > 0 && (last[0] !== to[0] || last[1] !== to[1])) {
                // the points of the path can be modified in the move mouse method - thus pushing a copy
                // of the original target
                stops.push(to.slice());
            }
            return stops;
        },

        
        randomBetween : function (min, max) {
            return Math.floor(min + (Math.random() * (max - min + 1)));
        },

        
        // private, deprecated
        valueIsArray : function(a) {
            return this.typeOf(a) == 'Array'
        },
        
        
        /**
         * This method will return the top-most DOM element at the specified coordinates from the test page. If
         * the resulting element is an iframe and `shallow` argument is not passed as `true`
         * it'll query the iframe for its element from the local point inside it.
         * 
         * @param {Number} x The X coordinate
         * @param {Number} y The Y coordinate
         * @param {Boolean} [shallow] Pass `true` to _not_ check the nested iframe if element at original coordinates is an iframe.
         * 
         * @return {HTMLElement} The top-most element at the specified position on the test page
         */
        elementFromPoint : function (x, y, shallow, fallbackEl, fullInfo) {
            var document    = this.global.document;
            var el          = document.elementFromPoint(x, y)
            
            // trying 2nd time if 1st attempt failed and returned null
            // this weird thing seems to be required sometimes for IE8 and may be for IE10
            if (!el) el     = document.elementFromPoint(x, y)
            
            // final fallback to the provided element or to the <body> element
            el              = el || fallbackEl || document.body;
            
            var localX      = x
            var localY      = y

            // If we found IFRAME and its not a `shallow` request, try to dig deeper
            if (el.nodeName.toUpperCase() == 'IFRAME' && !shallow) { 
                // if found iframe is loaded from different domain
                // just accessing its "el.contentWindow.document" property will throw exception
                try {
                    var iframeDoc       = el.contentWindow.document;
                    var offsetsToTop    = this.$(el).offset();
                    
                    localX              = x - offsetsToTop.left
                    localY              = y - offsetsToTop.top
        
                    var resolvedEl      = iframeDoc.elementFromPoint(localX, localY)
        
                    // again weird 2nd attempt for IE
                    if (!resolvedEl) resolvedEl = iframeDoc.elementFromPoint(localX, localY)
                    
                    resolvedEl          = resolvedEl || iframeDoc.body;
        
                    // Chrome reports 'HTML' in nested document.elementFromPoint calls which makes no sense
                    if (resolvedEl.nodeName.toUpperCase() === 'HTML') resolvedEl = iframeDoc.body;
        
                    el                  = resolvedEl;
                } catch (e) {
                    // digging deeper failed, restore the local coordinates
                    localX              = x
                    localY              = y
                }
            }
            
            return fullInfo ? {
                el          : el,
                localXY     : [ localX, localY ],
                globalXY    : [ x, y ]
            } : el
        },
        
        
        activeElement : function (notAllowBody, fallbackEl, elOrDoc) {
            var doc         = elOrDoc ? elOrDoc.ownerDocument || elOrDoc : this.global.document
            
            var focusedEl   = doc.activeElement;

            // 1. In IE10,11 it seems activeElement cannot be trusted as it sometimes returns an empty object with no properties.
            // Try to detect this case and use the fallback el 
            // 2. Sometimes receiving <body> from this method does not make sense either - use fallback el as well
            if (!focusedEl || !focusedEl.nodeName || !focusedEl.tagName || (focusedEl === doc.body && notAllowBody)) {
                focusedEl   = fallbackEl;
            }
            
            // For iframes, we need to grab the activeElement of the frame (if in the same domain)
            if ($(focusedEl).is('iframe')) {
                try {
                    if (focusedEl.contentDocument && focusedEl.contentDocument.body) {
                        focusedEl = this.activeElement(notAllowBody, fallbackEl, focusedEl.contentDocument)
                    }
                }
                catch(e) {}

            }
            
            return focusedEl || doc.body
        },

        
        /**
         * This method uses native `document.elementFromPoint()` and returns the DOM element under the current logical cursor 
         * position in the test. Note, that this method may work not 100% reliable in IE due to its bugs. In cases
         * when "document.elementFromPoint" can't find any element this method returns the &lt;body&gt; element.
         * 
         * @return {HTMLElement}
         */
        getElementAtCursor : function() {
            var xy          = this.currentPosition;
            
            return this.elementFromPoint(xy[0], xy[1]);
        },

        /**
         * This method will wait for the first browser `event`, fired by the provided `observable` and will then call the provided callback.
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String} event The name of the event to wait for
         * @param {Function} callback The callback to call 
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForEvent : function (observable, event, callback, scope, timeout) {
            var eventFired      = false
            var R               = Siesta.Resource('Siesta.Test.Browser');

            this.addListenerToObservable(observable, event, function () { eventFired = true })
            
            return this.waitFor({
                method          : function() { return eventFired; }, 
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForEvent',
                description     : ' ' + R.get('waitForEvent') + ' "' + event + '" ' + R.get('event')
            });
        },

        
        addListenerToObservable : function (observable, event, listener, isSingle) {
            this.$(observable).bind(event, listener)
        },
        
        
        removeListenerFromObservable : function (observable, event, listener) {
            this.$(observable).unbind(event, listener)
        },
        
        
        /**
         * This assertion verifies the number of certain events fired by provided observable instance during provided period.
         * 
         * For example:
         *

    t.firesOk({
        observable      : store,
        events          : {
            update      : 1,
            add         : 2,
            datachanged : '> 1'
        },
        during          : function () {
            store.getAt(0).set('Foo', 'Bar');
            
            store.add({ FooBar : 'BazQuix' })
            store.add({ Foo : 'Baz' })
        },
        desc            : 'Correct events fired'
    })
    
    // or
    
    t.firesOk({
        observable      : store,
        events          : {
            update      : 1,
            add         : 2,
            datachanged : '>= 1'
        },
        during          : 1
    })
    
    store.getAt(0).set('Foo', 'Bar');
    
    store.add({ FooBar : 'BazQuix' })
    store.add({ Foo : 'Baz' })
    
         *
         * Normally this method accepts a single object with various options (as shown above), but also can be called in 2 additional shortcuts forms:
         * 

    // 1st form for multiple events
    t.firesOk(observable, { event1 : 1, event2 : '>1' }, description)
    
    // 2nd form for single event
    t.firesOk(observable, eventName, 1, description)
    t.firesOk(observable, eventName, '>1', description)

         * 
         * In both forms, `during` is assumed to be undefined and `description` is optional.
         * 
         * @param {Object} options An obect with the following properties:
         * @param {Ext.util.Observable/Ext.Element/HTMLElement} options.observable The observable instance that will fire events
         * @param {Object} options.events The object, properties of which corresponds to event names and values - to expected 
         * number of this event triggering. If value of some property is a number then exact that number of events is expected. If value
         * of some property is a string starting with one of the comparison operators like "\<", "\<=" etc and followed by the number
         * then Siesta will perform that comparison with the number of actualy fired events.
         * @param {Number/Function} [options.during] If provided as a number denotes the number of milliseconds during which
         * this assertion will "record" the events from observable, if provided as function - then this assertion will "record"
         * only events fired during execution of this function. If not provided at all - assertions are recorded until the end of
         * current test (or sub-test)  
         * @param {Function} [options.callback] A callback to call after this assertion has been checked. Only used if `during` value is provided. 
         * @param {String} [options.desc] A description for this assertion
         */
        firesOk: function (options, events, n, timeOut, func, desc, callback) {
            //                    |        backward compat arguments        | 
            var me              = this;
            var sourceLine      = me.getSourceLine();
            var R               = Siesta.Resource('Siesta.Test.Browser');
            var nbrArgs         = arguments.length
            var observable, during
            
            if (nbrArgs == 1) {
                observable      = options.observable
                events          = options.events
                during          = options.during
                desc            = options.desc || options.description
                callback        = options.callback
                
                timeOut         = this.typeOf(during) == 'Number' ? during : null
                func            = this.typeOf(during) == 'Function' ? during : null
                
            } else if (nbrArgs >= 5) {
                // old signature, backward compat
                observable      = options
                
                if (this.typeOf(events) == 'String') {
                    var obj         = {}
                    obj[ events ]   = n
                    
                    events          = obj
                }
            } else if (nbrArgs <= 3 && this.typeOf(events) == 'Object') {
                // shortcut form 1
                observable      = options
                desc            = n
            } else if (nbrArgs <= 4 && this.typeOf(events) == 'String') {
                // shortcut form 2
                observable      = options
                
                var obj         = {}
                obj[ events ]   = n
                events          = obj
                
                desc            = timeOut
                timeOut         = null
            } else
                throw new Error(R.get('unrecognizedSignature'))
            
            // start recording
            var counters    = {};
            var countFuncs  = {};

            Joose.O.each(events, function (expected, eventName) {
                counters[ eventName ]   = 0
                
                var countFunc   = countFuncs[ eventName ] = function () {
                    counters[ eventName ]++
                }
                
                me.addListenerToObservable(observable, eventName, countFunc);    
            })
            
            
            // stop recording and verify the results
            var stopRecording   = function () {
                Joose.O.each(events, function (expected, eventName) {
                    me.removeListenerFromObservable(observable, eventName, countFuncs[ eventName ]);
                    
                    var actualNumber    = counters[ eventName ]
    
                    if (me.verifyExpectedNumber(actualNumber, expected))
                        me.pass(desc, {
                            descTpl         : R.get('observableFired') + ' ' + actualNumber + ' `' + eventName + '` ' + R.get('events')
                        });
                    else
                        me.fail(desc, {
                            assertionName   : 'firesOk',
                            sourceLine      : sourceLine,
                            descTpl         : R.get('observableFiredOk') + ' `' + eventName + '` ' + R.get('events'),
                            got             : actualNumber,
                            gotDesc         : R.get('actualNbrEvents'),
                            need            : expected,
                            needDesc        : R.get('expectedNbrEvents')
                        });
                })
            }
            
            if (timeOut) {
                var async               = this.beginAsync(timeOut + 100);
                
                var originalSetTimeout  = this.originalSetTimeout;
    
                originalSetTimeout(function () {
                    me.endAsync(async);
                    
                    stopRecording()
    
                    me.processCallbackFromTest(callback);
                }, timeOut);
            } else if (func) {
                func()
                
                stopRecording()
                
                me.processCallbackFromTest(callback)
            } else {
                this.on('beforetestfinalizeearly', stopRecording)
            }
        },


        /**
         * This assertion passes if the observable fires the specified event exactly (n) times during the test execution.
         *
         * @param {Ext.util.Observable/Ext.Element/HTMLElement} observable The observable instance
         * @param {String} event The name of event
         * @param {Number} n The expected number of events to be fired
         * @param {String} [desc] The description of the assertion.
         */
        willFireNTimes: function (observable, event, n, desc, isGreaterEqual) {
            this.firesOk(observable, event, isGreaterEqual ? '>=' + n : n, desc)
        },
        
        
        getObjectWithExpectedEvents : function (event, expected) {
            var events      = {}
            
            if (this.typeOf(event) == 'Array') 
                Joose.A.each(event, function (eventName) {
                    events[ eventName ] = expected
                })
            else
                events[ event ]         = expected
                
            return events
        },
        
        
        /**
         * This assertion passes if the observable does not fire the specified event(s) after calling this method.
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         */
        wontFire : function(observable, event, desc) {
            this.firesOk({
                observable      : observable,
                events          : this.getObjectWithExpectedEvents(event, 0), 
                desc            : desc
            });
        },

        /**
         * This assertion passes if the observable fires the specified event exactly once after calling this method.
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         */
        firesOnce : function(observable, event, desc) {
            this.firesOk({
                observable      : observable,
                events          : this.getObjectWithExpectedEvents(event, 1), 
                desc            : desc
            });
        },

        /**
         * Alias for {@link #wontFire} method
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         */
        isntFired : function() {
            this.wontFire.apply(this, arguments);
        },

        /**
         * This assertion passes if the observable fires the specified event at least `n` times after calling this method.
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String} event The name of event
         * @param {Number} n The minimum number of events to be fired
         * @param {String} [desc] The description of the assertion.
         */
        firesAtLeastNTimes : function(observable, event, n, desc) {
            this.firesOk(observable, event, '>=' + n, desc);
        },
        
        

        
        /**
         * This assertion will verify that the observable fires the specified event and supplies the correct parameters to the listener function.
         * A checker method should be supplied that verifies the arguments passed to the listener function, and then returns true or false depending on the result.
         * If the event was never fired, this assertion fails. If the event is fired multiple times, all events will be checked, but 
         * only one pass/fail message will be reported.
         * 
         * For example:
         * 

    t.isFiredWithSignature(store, 'add', function (store, records, index) {
        return (store instanceof Ext.data.Store) && (records instanceof Array) && t.typeOf(index) == 'Number'
    })
 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} event The name of event
         * @param {Function} checkerFn A method that should verify each argument, and return true or false depending on the result.
         * @param {String} [desc] The description of the assertion.
         */
        isFiredWithSignature : function(observable, event, checkerFn, description) {
            var eventFired;
            var me              = this;
            var sourceLine      = me.getSourceLine();
            var R               = Siesta.Resource('Siesta.Test.ExtJS.Observable');

            var verifyFiredFn = function () {
                me.removeListenerFromObservable(observable, event, listener)

                if (!eventFired) {
                    me.fail(event + " " + R.get('isFiredWithSignatureNotFired'));
                }
            };
            
            me.on('beforetestfinalizeearly', verifyFiredFn);

            var listener = function () { 
                me.un('beforetestfinalizeearly', verifyFiredFn);
                
                var result = checkerFn.apply(me, arguments);

                if (!eventFired && result) {
                    me.pass(description || R.get('observableFired') + ' ' + event + ' ' + R.get('correctSignature'), {
                        sourceLine  : sourceLine
                    });
                }

                if (!result) {
                    me.fail(description || R.get('observableFired') + ' ' + event + ' ' + R.get('incorrectSignature'), {
                        sourceLine  : sourceLine
                    });
                    
                    // Don't spam the assertion grid with failure, one failure is enough
                    me.removeListenerFromObservable(observable, event, listener)
                }
                eventFired = true 
            };
            
            me.addListenerToObservable(observable, event, listener)
        },


        // This method accepts actionTargets as input (Dom node, string, CQ etc) and does a first normalization pass to get a DOM element.
        // After initial normalization it also tries to locate, the 'top' DOM node at the center of the first pass resulting DOM node.
        // This is the only element we can truly interact with in a real browser.
        // returns an object containing the element plus coordinates
        getNormalizedTopElementInfo : function (actionTarget, skipWarning, actionName, offset) {
            var localXY, globalXY, el;

            actionTarget    = actionTarget || this.currentPosition;
            
            var targetIsPoint   = this.typeOf(actionTarget) == 'Array'

            // First lets get a normal DOM element to work with
            if (targetIsPoint) {
                globalXY    = actionTarget;
                
                var info    = this.elementFromPoint(actionTarget[ 0 ], actionTarget[ 1 ], false, null, true);
                
                el          = info.el
                localXY     = info.localXY
            } else {
                el          = this.normalizeElement(actionTarget, skipWarning);
            }

            if (!el && skipWarning) {
                return;
            }

            // 1. If this element is not visible, something is wrong
            // 2. If element is visible but not reachable (scrolled out of view) this is also an invalid scenario (this check is skipped for IE)
            //    TODO needs further investigation, conflicting with starting a drag operation on an element that isn't visible until the cursor is above it

            // we don't need to this check if target is a coordinate point, because in this case element is reachable by definition
            if (!targetIsPoint) {
                var R       = Siesta.Resource('Siesta.Test.Browser');
                var message = 'getNormalizedTopElementInfo: ' + (actionName ? R.get('targetElementOfAction') + " [" + actionName + "]" : R.get('targetElementOfSomeAction')) +
                    " " + R.get('isNotVisible') + ": " + (el.id ? '#' + el.id : el)
                
                if (!this.isElementVisible(el)){
                    this.fail(message)
                    return;
                }
                else if (!skipWarning && this.isOffsetInsideElementBox(el, offset) && !this.elementIsTop(el, true, offset)) {
                    this.warn(message)
                }
            }

            var isOption = el && el.nodeName.toLowerCase() === 'option';

            if (isOption) {
                localXY = this.currentPosition.slice();
                globalXY = this.currentPosition.slice();
            }
            else if (!targetIsPoint) {
                var doc     = el.ownerDocument;
                var R       = Siesta.Resource('Siesta.Test.Browser');

                localXY     = this.getTargetCoordinate(el, true, offset)
                globalXY    = this.getTargetCoordinate(el, false, offset)

                // trying 2 times for IE
                el          = doc.elementFromPoint(localXY[ 0 ], localXY[ 1 ]) || doc.elementFromPoint(localXY[ 0 ], localXY[ 1 ]) || doc.body;

                if (!el) {
                    this.fail('getNormalizedTopElementInfo: ' + R.get('noElementFound') + ' [' + localXY + ']');
                    return; // No point going further
                }
            }

            return {
                el          : el,
                localXY     : localXY,
                globalXY    : globalXY,
                offset      : isOption ? [0,0] : this.getOffsetRelativeToEl(el, localXY)
            }
        },

        getOffsetRelativeToEl : function(el, point) {
            var box = this.getElementPageRect(el);

            return [ point[0] - box.left, point[1] - box.top ];
        },

        /**
         * This method will wait for the presence of the passed string.
         *
         * @param {String} text The text to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTextPresent : function (text, callback, scope, timeout) {
            var R               = Siesta.Resource('Siesta.Test.Browser');

            return this.waitFor({
                method          : function () {
                    var body        = this.global.document.body
                    var selector    = ':contains(' + text + ')'
                    
                    return this.$(selector, body).length > 0 || this.$(body).is(selector); 
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTextPresent',
                description     : ' ' + R.get('text') + ' "' + text + '" ' + R.get('toBePresent')
            });
        },

        /**
         * This method will wait for the absence of the passed string.
         *
         * @param {String} text The text to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTextNotPresent : function (text, callback, scope, timeout) {
            var R               = Siesta.Resource('Siesta.Test.Browser');

            return this.waitFor({
                method          : function () { 
                    var body        = this.global.document.body
                    var selector    = ':contains(' + text + ')'
                    
                    return this.$(selector, body).length === 0 && !this.$(body).is(selector); 
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTextNotPresent',
                description     : ' ' + R.get('text') + ' "' + text + '" ' + R.get('toNotBePresent')
            });
        },

        /**
         * Waits until the passed action target is detected. This can be a string such as a component query, CSS query or a composite query.
         *
         * @param {String/Siesta.Test.ActionTarget} target The target presence to wait for
         * @param {Function} callback The callback to call after the target has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTarget : function(target, callback, scope, timeout, offset) {
            var me = this;
            var R  = Siesta.Resource('Siesta.Test.Browser');

            return this.waitFor({
                method          : function () {
                    var el      = me.normalizeElement(target, true, true, false, { offset : offset })

                    // If user is aiming outside the target, we'll *not* use the offset while
                    // detecting target presence since having a visible sized box will suffice
                    if (el && offset && me.isElementVisible(el) && !me.isOffsetInsideElementBox(el, offset)) {
                        return true;
                    }

                    return el && me.elementIsTop(el, true, offset)
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTarget',
                description     : ' ' + R.get('target') + ' "' + target + '" ' + R.get('toAppear')
            });
        },

        /**
         * Sets a new size for the test iframe
         *
         * @param {Int} width The new width
         * @param {Int} height The new height
         */
        setWindowSize : function(width, height, callback) {
            this.scopeProvider.setViewportSize(width, height);

            callback && callback.call(this);
        },
        
        
        getJUnitClass : function () {
            var browserInfo         = this.getBrowserInfo()
            
            browserInfo             = browserInfo.name + browserInfo.version
            
            return browserInfo + ':' + this.SUPER()
        },

        
        // Returns true if the scope was adjusted to another frame for the target string
        adjustScope : function(target) {

            if (this.typeOf(target) == 'String') {
                var mainParts  = target.split('->');

                if (mainParts.length === 2) {
                    var frameEl = this.$(this.trimString(mainParts[ 0 ]))[ 0 ];

                    if (!frameEl || !frameEl.contentWindow) {
                        return false;
                    }

                    this._global    = this.global;
                    this.global     = frameEl.contentWindow;
                    
                    return true;
                }
            }

            return false;
        },

        
        resetScope : function() {
            this.global     = this._global || this.global;
            
            this._global    = null
        },
        
        
        // a stub method for the Lite package
        screenshot : function (options, callback) {
            this.diag("Command: `screenshot` skipped - not running in Standard Package")
            
            this.processCallbackFromTest(callback, [ 'skipped' ], this)
        },

        // a stub method for the Lite package
        screenshotElement : function (target, fileName, callback) {
            this.diag("Command: `screenshot` skipped - not running in Standard Package")
            
            this.processCallbackFromTest(callback, [ 'skipped' ], this)
        },
        
        /**
         * setUrl Opens the url provided (make sure you use the {@link Siesta.Harness.Browser#separateContext} option on the Harness when using this API method)
         *
         * @param {String} url The new url for current page
         * @param {Function} callback The callback to call after the page has been loaded
         * @param {Object} scope The scope for the callback
         */
        setUrl : function(url, callback, scope) {
            if (!url) throw 'Must provide a valid URL';

            var me = this;

            if (me.global.location.href !== url) {
                var baseUrl = this.scopeProvider.sourceURL || this.harness.baseUrl;
                var absURl  = this.harness.absolutizeURL(url, baseUrl);

                me.waitForPageLoad(callback, scope);
                me.global.location.href = absURl;
            } else {
                callback.call(scope || me);
            }
        },
        
        /**
         * Expects an alert message with the specified text to be shown during the test. If no alert is called,
         * or the text doesn't match, a failed assertion will be added.
         *
         * @param {String/RegExp} message The expected alert message or a regular expression to match
         * @param callback Only used internally when this method is called in a t.chain command
         */
        expectAlertMessage : function (message, callback) {
            var me          = this
            var global      = this.global
            var prevAlert   = global.alert

            global.alert = function (msg) {
                var passed      = me.typeOf(message) == 'RegExp' ? message.test(msg) : message == msg
                
                if (passed)
                    me.pass("Expected alert message has been shown")
                else
                    me.fail("Wrong alert message has been shown", {
                        assertionName       : 'expectAlertMessage',
                        got                 : msg,
                        gotDesc             : "Message shown",
                        need                : message,
                        needDesc            : "Expected message"
                    })
                    
                global.alert = prevAlert
            };
            
            global.alert.__EXPECTED_ALERT__ = true

            this.processCallbackFromTest(callback, null, this)
        },

        /**
         * Sets the confirm dialog return value for the next window.confirm() call.
         *
         * @param {Boolean} value The confirm dialog return value (true or false)
         * @param callback Only used internally when this method is called in a t.chain command
         * */
        setNextConfirmReturnValue : function (value, callback) {
            this.nextConfirmValue = value;

            this.processCallbackFromTest(callback, null, this)
        },

        /**
         * Sets the prompt dialog return value for the next window.prompt() call.
         *
         * @param {String} value The confirm dialog return value
         * @param callback Only used internally when this method is called in a t.chain command
         */
        setNextPromptReturnValue : function (value, callback) {
            this.nextPromptReturnValue = value;

            this.processCallbackFromTest(callback, null, this)
        },
        

        waitForAnimations : function(callback) {
            callback.call(this);
        },
        
        
        popupHasStartedLoading : function (popup, initialUrl) {
            if (String(initialUrl).toLowerCase() != 'about:blank' && popup.location.href == 'about:blank') return false
            
            return true
        },
        
        
        /**
         * Switches the target of all Siesta interactive commands (like "click/type" etc) to a different
         * window (usually a popup). You can use {@link #switchToMain} method to switch back to main window.
         * 
         * @param {String/RegExp/Object/Window/HTMLIFrameElement} [win] A new window which should be a target for all interactive commands.
         * If this argument is specified as `null` a first opened popup is used.
         * Can be specified as the:
         * 
         * - Window - A global window instance
         * - Object - Object with the following properties
         *      - url   : String/RegExp - The first popup, opened with matching url will be used 
         *      - title : String/RegExp - The first popup, opened with matching title will be used
         * - String - corresponds to the `title` property of the Object branch
         * 
         * @param {Function} callback Function to call once the switch has complete (will also wait until the target page 
         * completes loading)
         * 
         * @return {Window} Previously active window reference
         */
        switchTo : function (win, callback) {
            var me          = this
            
            // In Chrome, when popup for some url is just created, it has "url" set to "about:blank"
            // after some time the url is set to the original value and load process begins
            // this opens a race condition - one can not reliably predict when the popup has completed loading
            // doing our best
            this.waitFor({
                method              : function () {
                    for (var i = 0; i < me.popups.length; i++)
                        if (!me.popupHasStartedLoading(me.popups[ i ].popup, me.popups[ i ].url)) return false
                        
                    return true
                },
                suppressAssertion   : true,
                
                callback            : function () {
                    var found
                    
                    if (!win) {
                        Joose.A.each(this.popups, function (handle) {
                            if (!handle.popup.closed) { found = handle.popup;  return false }
                        })
                        
                        win  = found
                    }
                    
                    if (this.typeOf(win) == 'String') win = { title : win }
                    
                    if (this.typeOf(win) == 'Object') {
                        found           = null
                        var regexp      = win.title || win.url
                        
                        if (this.typeOf(regexp) == 'String') regexp = new RegExp('^' + this.escapeRegExp(regexp) + '$')
                        
                        Joose.A.each(this.popups, function (handle) {
                            var popup       = handle.popup
                            
                            if (!popup.closed)
                                if (
                                    win.url && regexp.test(popup.location.href)
                                    ||
                                    win.title && regexp.test(popup.document && popup.document.title || '')
                                ) {
                                    found = popup
                                    return false
                                }
                        })
                        
                        win  = found
                    }
                    
                    if (!win || win.self != win) {
                        this.fail("Can't resolve target win: " + win)
                        
                        this.processCallbackFromTest(callback, null, this)
                        
                        return
                    }
                    
                    this.global                 = win
//                    This has to be revised properly in the "context" branch, idea is, that we switch to popup's implementation
//                    of `setTimeout` for waiting, asyncing etc, because thats what really user expect
//                    however in IE test just hangs
//                    this.originalSetTimeout     = win.setTimeout
//                    this.originalClearTimeout   = win.clearTimeout
                    
                    this.waitFor({
                        suppressAssertion   : true,
                        method      :  function () {
                            return win.document && win.document.readyState == 'complete'
                        },
                        callback    : callback
                    })
                }
            })
            
            return this.global
        },
        
        
        /**
         * Switches all interactive commands back to main test window.
         * 
         * @param {Function} callback Function to call once the switch has complete.
         */
        switchToMain : function (callback) {
            this.switchTo(this.scopeProvider.scope, callback)
        },

        setCursorPosition : function(x, y, callback) {
            this.moveMouse(this.currentPosition, [x,y], null, null, 100000, false);

            callback && callback.call(this);
        },

        /**
         * Only useful along with {@link Siesta.Harness.Browser.separateContext separateContext} option
         *
         * Wait for the page load to occur and runs the callback. The callback will receive a "window" object.
         * Should be used when you are doing a redirect / refresh of the test page:
         *
         *      t.waitForPageLoad(function (window) {
         *          ...
         *      })
         *
         * Note, that method obviously must be called before the new page has completed loading, otherwise it will
         * wait indefinitely and fail (since there will be no page load). So, to avoid the race conditions, one
         * should always start waiting for page load *before* the action, that causes it.
         *
         * Consider the following example (where click on the `>> #loginPanel button` trigger a page redirect):

         // this code does not reliably - it contains a race condition
         // in Chrome, page refresh may happen too fast (even synchronously),
         // so, by the time the `waitForPageLoad` action will start, the page load event will already happen
         // and `waitForPageLoad` will wait indefinitely
         { click : '>> #loginPanel button' },
         { waitFor : 'PageLoad'}
         * &nbsp;

         // Need to start waiting first, and only then - click
         // we'll use "trigger" config of the `wait` action for that
         {
             waitFor     : 'PageLoad',
             trigger     : {
                 click : '>> #loginPanel button'
             }
         }
         // or, same action using function step:
         function (next) {
        t.waitForPageLoad(next)

        t.click('>> #loginPanel button', function () {})
    }

         *
         * @method
         * @member Siesta.Test.Browser
         */
        waitForPageLoad : function (callback, scope) {
            var me              = this

            var global          = this.global
            var unloaded        = false
            var description     = Siesta.Resource('Siesta.Test.More').get('pageToLoad');
            var onUnloadHandler = function () {
                global.removeEventListener('unload', onUnloadHandler)

                unloaded        = true
            }

            global.addEventListener('unload', onUnloadHandler)

            this.chain(
                {
                    description    : description,
                    waitFor : function () {
                        return unloaded || me.global.document.readyState != 'complete'
                    }},
                function (next) {
                    global.removeEventListener('unload', onUnloadHandler)

                    global          = null
                    onUnloadHandler = null

                    next()
                },
                {
                    description    : description,
                    waitFor : function () {
                        return me.global.document.readyState == 'complete'
                    }
                },
                { waitFor : 50 },
                function () {
                    me.processCallbackFromTest(callback, [ me.global ], scope || me)
                }
            )
        },


        /**
         * This method will just call the `setTimeout` method from the scope of the test page.
         *
         * Usually you don't need to use it - you can just call `setTimeout`, but if your test scripts resides in the
         * separate context, you need to use this method for `setTimeout` functionality. See documentation for {@link Siesta.Harness.Browser#separateContext separateContext}
         * option and <a href="#!/guide/cross_page_testing">Cross page testing</a> guide.
         *
         * @param {Function} func The function to call after specified `delay`
         * @param {Number} delay The time to wait (in ms) before calling the `func`
         * @return {Number} timeoutId The id of the timeout, can be passed to {@link #clearTimeout} to cancel the function execution.
         *
         * @method
         * @member Siesta.Test.Browser
         */
        setTimeout : function (func, delay) {
            var pageSetTimeout = this.global.setTimeout

            pageSetTimeout(func, delay)
        },


        /**
         * This method will just call the `clearTimeout` method from the scope of the test page.
         *
         * Usually you don't need to use it - you can just call `clearTimeout`, but if your test scripts resides in the
         * separate context, you need to use this method for `clearTimeout` functionality. See documentation for {@link Siesta.Harness.Browser#separateContext separateContext}
         * option and <a href="#!/guide/cross_page_testing">Cross page testing</a> guide.
         *
         * @param {Number} timeoutId The id of the timeout, recevied from the {@link #setTimeout} call
         *
         * @method
         * @member Siesta.Test.Browser
         */
        clearTimeout : function (id) {
            var pageClearTimeout = this.global.clearTimeout

            pageClearTimeout(id)
        }
    }
});
;
/**
 *
@class Siesta.Test.ExtJS
@extends Siesta.Test.Browser
@mixin Siesta.Test.ExtJSCore
@mixin Siesta.Test.ExtJS.Ajax
@mixin Siesta.Test.ExtJS.Observable
@mixin Siesta.Test.ExtJS.FormField
@mixin Siesta.Test.ExtJS.Component
@mixin Siesta.Test.ExtJS.Element
@mixin Siesta.Test.ExtJS.Store
@mixin Siesta.Test.ExtJS.DataView
@mixin Siesta.Test.ExtJS.Grid

A base class for testing browser and ExtJS applications. It inherit from {@link Siesta.Test.Browser}
and adds various ExtJS specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

*/
Class('Siesta.Test.ExtJS', {

    isa         : Siesta.Test.Browser,

    does        :  [
        Siesta.Test.ExtJSCore,
        Siesta.Test.ExtJS.Component,
        Siesta.Test.ExtJS.Element,
        Siesta.Test.ExtJS.FormField,
        Siesta.Test.ExtJS.Observable,
        Siesta.Test.ExtJS.Store,
        Siesta.Test.ExtJS.Grid,
        Siesta.Test.ExtJS.DataView,
		Siesta.Test.ExtJS.Ajax
    ],

    
    has : {
        globalExtOverrides      : null,

        extPathRegex1           : /(.*ext(?:js)?(?:-\d\.\d+\.\d+)?.*?)\/(?:build\/)?ext(?:-all)?(?:-debug|-dev)?\.js/,
        extPathRegex2           : /(.*ext(?:js)?-\d\.\d+(?:\.\d+)?.*?)\/ext-all(?:-debug|-dev)?\.js/,
        extPathRegex3           : /(.*ext(?:js)?\/gpl\/\d\.\d+(?:\.\d+)?.*?)\/ext-all(?:-debug|-dev)?\.js/
    },
    
    methods : {

        getExtBundlePath : function() {
            var path
            var testDescriptor      = this.harness.getScriptDescriptor(this.url)
            var me                  = this

            while (testDescriptor && !path) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        if (url.match && (url.match(me.extPathRegex1) || url.match(me.extPathRegex2) || me.extPathRegex3.exec(url))) {
                            path    = url;
                            return false;
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return path;
        },


        getExtBundleFolder : function() {
            var folder;
            var testDescriptor      = this.harness.getScriptDescriptor(this.url)
            var me                  = this

            while (testDescriptor && !folder) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        var match = me.extPathRegex1.exec(url) || me.extPathRegex2.exec(url) || me.extPathRegex3.exec(url);

                        if (match) folder = match[1];
                        
                        return false
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return folder;
        },
        
        
        getNumberOfGlobalExtOverrides : function (callback) {
            var globalExtOverrides  = this.globalExtOverrides;
            
            if (globalExtOverrides != null) 
                callback && callback.call(this, globalExtOverrides.length, globalExtOverrides)
            else {
                var me              = this;
                var Ext             = this.getExt();
                var extjsBundleURL  = me.getExtBundlePath()
    
                if (!extjsBundleURL) {
                    me.fail(Siesta.Resource('Siesta.Test.ExtJS', 'bundleUrlNotFound'));
                    callback && callback.call(me, null, null)
                    return;
                }

                // For IE
                this.expectGlobal('0');

                var frame           = Ext.core.DomHelper.append(Ext.getBody(), {
                    tag     : "iframe",
                    style   : 'width:1024px;height:768px;position:absolute;left:-10000px;top:-10000px',
                    src     : 'about:blank'
                }, false);

                var freshWin        = frame.contentWindow;
    
                freshWin.document.open();

                freshWin.document.write(
                    '<!DOCTYPE html>' + 
                    '<html>' + 
                        '<head>' +
                            '<script type="text/javascript" src="' + extjsBundleURL + '"></script>' + 
                        '</head>' + 
                        '<body></body>' + 
                    '</html>'
                );
    
                freshWin.document.close();
                
                var resolveObject   = function (hostObj, nameSpace) {
                    var parts   = nameSpace.split('.');
                    var p       = hostObj
    
                    for (var i = 0; i < parts.length; i++) {
                        p       = p[ parts[ i ] ];
                    };
    
                    return p;
                }
    
                var ignoreRegexp    = [
                    /Ext\.data\.Store\.ImplicitModel|collectorThreadId|Ext\.dom\.GarbageCollector\.lastTime/,
                    /Ext.globalEvents.cur/i,
                    /Ext\.dd\.(DragDropManager|DragDropMgr|DDM)\.(currentPoint|offsetX|offsetY)/
                ]
                
                var ignore          = function (name) {
                    for (var i = 0; i < ignoreRegexp.length; i++)
                        if (ignoreRegexp[ i ].test(name)) return true
                        
                    return false
                }
                
                var getObjectDifferences    = function (cleanObj, dirtyObj, ns) {
                    var diff    = []

                    for (var p in dirtyObj) {
                        try {
                            if (dirtyObj.hasOwnProperty(p)) {
                                var dirtyValue  = dirtyObj[ p ]
                                var cleanValue  = cleanObj[ p ]
                                
                                // Check if the object exists on the clean window and also do a string comparison
                                // in case a builtin method has been overridden
                                if (
                                    (!cleanObj.hasOwnProperty(p) && typeof cleanValue == 'undefined' ) 
                                        ||
                                    (
                                        String(cleanValue) != String(dirtyValue)
                                            && 
                                        (typeof dirtyValue == 'function' || Ext.isPrimitive(dirtyValue))
                                    )
                                ) {
                                    if (!ignore(ns + '.' + p)) diff.push(ns + '.' + p)
                                }
                            }
                        } catch (e) {
                            // Just continue
                        }
                    }
                    return diff;
                }
                
                me.waitFor(
                    function () { return freshWin.Ext && freshWin.Ext.isReady; }, 
                    function () {
                        var dirtyWin    = me.global,
                            overrides   = [];
        
                        // Check for native class augmentations
                        Ext.iterate(Ext.ClassManager.classes, function (item) {
                            if (!item.match(/^Ext\./)) return;

                            var freshItem   = resolveObject(freshWin, item);
                            var dirtyItem   = resolveObject(dirtyWin, item);
        
                            if (freshItem && typeof dirtyItem !== 'undefined') {
                                var staticDiff = getObjectDifferences(freshItem,  dirtyItem, item);
                                    
                                overrides.push.apply(overrides, staticDiff);
        
                                // Prototype properties
                                if (dirtyItem.prototype) {
                                    var prototypeDiff = getObjectDifferences(freshItem.prototype, dirtyItem.prototype, item + '.prototype');
                                    
                                    overrides.push.apply(overrides, prototypeDiff);
                                }
                            }
                        });
                        
                        me.globalExtOverrides   = overrides

                        Ext.destroy(frame);

                        callback && callback.call(me, overrides.length, overrides)
                    }
                )
                // eof waitFor
            }
        },
        

        /**
         * This assertion passes if no global Ext JS overrides exist. It creates a fresh iframe window where a new, fresh copy
         * of Ext JS w/o any overrides is loaded and then a comparison is made against the copy of Ext JS loaded in the test.
         * 
         * A global ExtJS override is some change, made in the core class, for example like this:
         * 

    Ext.data.Store.override({
        removeAll       : function () {
            // my fix
            ...
        }
    })

         * While such overrides are often seems as the only possible solution (usually for some bug in Ext) they should be 
         * avoided as much as possible, because it a very bad practice. For example, in the previous case, a better approach
         * would be to create a new subclass of the Ext.data.Store with the desired changed.
         * 
         * See also {@link #assertMaxNumberOfGlobalExtOverrides} assertion. 
         *
         * @param {String} [description] The description for the assertion
         */
        assertNoGlobalExtOverrides : function (description, cb) {
            this.getNumberOfGlobalExtOverrides(function (length, overrides) {
                var R = Siesta.Resource('Siesta.Test.ExtJS');

                if (length == null) {
                    this.fail(R.get('assertNoGlobalExtOverridesInvalid'))
                } else {

                    if (length) {
                        this.fail(description, {
                            assertionName   : 'assertNoGlobalExtOverrides',
                            descTpl         : R.get('assertNoGlobalExtOverridesPassTpl'),

                            got             : length,
                            gotDesc         : R.get('assertNoGlobalExtOverridesGotDesc'),

                            annotation      : R.get('foundOverridesFor') + ': `' + overrides.join('`, `') + '`'
                        })
                    } else {
                        this.pass(description, {
                            descTpl             : R.get('assertNoGlobalExtOverridesPassTpl')
                        })
                    }

                    // For testing only
                    cb && cb.call(this);
                }

            })
        },

        
        /**
         * This assertion passes if the number of global overrides does not exceed the given number.
         * 
         * For example, you can add this assertion in your existing codebase (assuming you have 3 overrides your application
         * cannot function without):
         * 
         *      t.assertMaxNumberOfGlobalExtOverrides(3, "Ideally should be none of these")
         *      
         * and catch all the cases when someone adds a new global override.
         * 
         * @param {Number} maxNumber The maximum number of Ext JS overrides allowed
         * @param {String} [description] The description for the assertion
         */
        assertMaxNumberOfGlobalExtOverrides : function (maxNumber, description, cb) {
            var R   = Siesta.Resource('Siesta.Test.ExtJS');

            this.getNumberOfGlobalExtOverrides(function (length, overrides) {
                if (length == null) {
                    this.fail(R.get("extOverridesInvalid"));
                } else {

                    if (length > maxNumber) {
                        this.fail(description, {
                            assertionName   : 'assertNoGlobalExtOverrides',
                            descTpl         : R.get('foundLessOrEqualThan') + ' ' + maxNumber + ' ' + R.get('globalOverrides'),

                            got             : length,
                            gotDesc         : R.get('nbrOverridesFound'),

                            annotation      : R.get('foundOverridesFor') + ': `' + overrides.join('`, `') + '`'
                        })
                    } else {
                        this.pass(description, {
                            descTpl             : R.get('foundLessOrEqualThan') + ' ' + maxNumber + ' ' + R.get('globalOverrides'),
                            annotation          : R.get('nbrOverridesFound') + ': ' + length
                        })
                    }

                    // For testing only
                    cb && cb.call(this)
                }

            })
        },

        /**
         * A helper method returning the total number of Ext JS container layouts that have been performed since the beginning of the page lifecycle.
         * @return {Int} The number of layouts
         */
        getTotalLayoutCounter : function () {
            var count       = 0

            this.Ext().each(this.cq('container'), function(c) { count += c.layoutCounter });

            return count;
        },

        /**
         * This assertion passes if no Ext JS layout cycles are performed as a result of running the passed function. This
         * function will query all containers on the page and measure the number of layouts performed before and after the function call.
         *
         * @param {Function} fn The function to call
         * @param {Object} scope The 'thisObject' to use for the function call
         * @param {String} [description] The description for the assertion
         */
        assertNoLayoutTriggered : function(fn, scope, description) {
            var countBefore = this.getTotalLayoutCounter();

            fn.call(scope || this);

            this.is(this.getTotalLayoutCounter(), countBefore, description);
        },

        areAnimationsRunning : function() {
            var Ext = this.Ext();

            return Ext && Ext.fx && Ext.fx.Manager && Ext.fx.Manager.items && Ext.fx.Manager.items.getCount() > 0;
        }
    }
})
;
/**
@class Siesta.Test.SenchaTouch
@extends Siesta.Test.Browser
@mixin Siesta.Test.ExtJSCore
@mixin Siesta.Test.ExtJS.Observable
@mixin Siesta.Test.ExtJS.FormField
@mixin Siesta.Test.ExtJS.Component
@mixin Siesta.Test.ExtJS.Element 
@mixin Siesta.Test.ExtJS.Store 

A base class for testing Sencha Touch applications. It inherits from {@link Siesta.Test.Browser} 
and adds various ST specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

*/
Class('Siesta.Test.SenchaTouch', {
    
    isa         : Siesta.Test.Browser,
        
    does        :  [ 
        Siesta.Test.ExtJSCore, 
        Siesta.Test.ExtJS.Component, 
        Siesta.Test.ExtJS.Element, 
        Siesta.Test.ExtJS.Observable, 
        Siesta.Test.ExtJS.Store,
		Siesta.Test.ExtJS.Ajax,
        Siesta.Test.ExtJS.FormField
    ],
    
    has         : {
        performSetup        : true,
        isSTSetupDone       : false,

        moveCursorBetweenPoints : false
    },
    
    override : {
        
        isReady : function () {
            var result  = this.SUPERARG(arguments);
            var R       = Siesta.Resource('Siesta.Test.SenchaTouch');

            if (!result.ready) return result;

            if (!this.parent && this.performSetup && !this.isSTSetupDone) return {
                ready       : false,
                reason      : R.get('STSetupFailed')
            }
            
            return {
                ready       : true
            }
        },

        
        start : function () {
            var me      = this;
            var Ext     = this.getExt();
            
            if (!Ext) return
            
            // calling SUPER to setup the loader paths, Ext.setup() will already do Ext.require
            this.SUPERARG(arguments)
            
            // execute "Ext.setup()" for top-level tests only 
            if (this.performSetup && !this.parent) Ext.setup({
                onReady : function () {
                    me.isSTSetupDone    = true
                }
            })
        }
    },
    
    methods : {
        // one of these methods feels redundant
        getTouchBundlePath : function() {
            var path;
            var testDescriptor      = this.harness.getScriptDescriptor(this.url)
            
            while (testDescriptor && !path) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        if (url.match && url.match(/(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch(.*)\.js/)) {
                            path = url;
                            return false;
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return path;
        },


        getTouchBundleFolder : function() {
            var folder;
            var testDescriptor      = this.harness.getScriptDescriptor(this.url)

            while (testDescriptor && !folder) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        var regex = /(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch(.*)\.js/;
                        var match = regex.exec(url);
                
                        if (match) {
                           folder = match[1];
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return folder;
        },
        
        
        getExtBundleFolder : function() {
            var folder;

            this.harness.mainPreset.eachResource(function (resource) {
                var desc = resource.asDescriptor();
                
                var regex = /(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch-all(?:-debug)?\.js/;
                var match = regex.exec(desc.url);
                
                if (match) {
                   folder = match[1];
                }
            });

            return folder;
        },
        

        /**
        * This method will simulate a finger move to an xy-coordinate or an element (the center of it)
        * 
        * @param {Siesta.Test.ActionTarget} target Target point to move the finger to.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        moveFingerTo : function(target, callback, scope, offset) {
            this.moveCursorTo.apply(this, arguments);
        },

        /**
        * This method will simulate a finger move from current position relative by the x and y distances provided.
        * 
        * @param {Array} delta The delta offset to move the finger by.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        */
        moveFingerBy : function(delta, callback, scope) {
            if (!delta) {
                var R = Siesta.Resource('Siesta.Test.SenchaTouch');
                throw R.get('moveFingerByInvalidInput');
            }

            this.moveCursorBy.apply(this, arguments);
        },

        
        scrollUntil : function(target, direction, checkerFn, callback, scope) {
            var me          = this,
                startDate   = new Date(),
                dir         = direction;

            var R = Siesta.Resource('Siesta.Test.SenchaTouch');

            // Invert direction, Scroll up => Swipe down
            switch(dir) {
                case 'u':
                case 'up':
                    direction = 'down';
                break;

                case 'd':
                case 'down':
                    direction = 'up';
                break;

                case 'l':
                case 'left':
                    direction = 'right';
                break;

                case 'r':
                case 'right':
                    direction = 'left';
                break;

                default: 
                    throw R.get('invalidSwipeDir') + ': ' + direction;
            }

            var inner = function() {
                if (checkerFn.call(scope || me, target)) {
                    // We're done
                    me.processCallbackFromTest(callback, null, scope || me)
                } else {
                    me.swipe(target, direction, function() { 

                        if (new Date() - startDate < this.waitForTimeout) {
                            var as = me.beginAsync();
                            setTimeout(function() {
                                me.endAsync(as); 
                                inner(); 
                            }, 1000); 
                        } else {
                            me.fail(R.get('scrollUntilFailed'));
                        }
                    });
                }
            };

            inner();
        },

        /**
         * Waits until the supplied x&y scroll property has the passed value. You can test for either x or y, or both.
         *
         * @param {Ext.scroller.Scroller} scrollable The scroller instance
         * @param {String} direction 'up', 'down', 'left' or 'right'
         * @param {Siesta.Test.ActionTarget} actionTarget The target, either an element or a CSS selector normally.
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         */
        scrollUntilElementVisible : function(scrollable, direction, actionTarget, callback, scope) {
            var me = this;

            if (!actionTarget || !scrollable) {
                var R = Siesta.Resource('Siesta.Test.SenchaTouch');
                this.fail(R.get('scrollUntilElementVisibleInvalid'));

                return;
            }

            this.scrollUntil(scrollable, direction, function() {
                var element = me.normalizeElement(actionTarget, true);
                return me.elementIsInView(element);
            },
            callback, scope);
        },

        
        /**
         * Waits until the supplied x&y scroll property has the passed value. You can test for either x or y, or both.
         * 
         * @param {Ext.scroller.Scroller} scroller The scroller instance
         * @param {Object} position An object with an x, y, or x&y values. Ex. { x : 0 } or { x : 0, y : 200 }.
         * @param {Int} value
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForScrollerPosition: function(scroller, pos, callback, scope, timeout) {
            return this.waitFor({
                method          : function() { 
                    return (!('x' in pos) || pos.x === scroller.position.x) && (!('y' in pos) || pos.y === scroller.position.y);
                }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForScrollerPosition',
                description     : ' ' + Siesta.Resource('Siesta.Test.SenchaTouch', 'scrollerReachPos') + ' '+ Siesta.Util.Serializer.stringify(pos)
            });
        },

        areAnimationsRunning : function() {
            var Ext = this.Ext();

            return Ext && Ext.AnimationQueue.isRunning;
        }
    }
})
;
/**
 * 
@class Siesta.Test.jQuery
@extends Siesta.Test.Browser

A base class for testing jQuery applications. It inherit from {@link Siesta.Test.Browser} and adds various jQuery specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

*/
Class('Siesta.Test.jQuery', {
    
    isa         : Siesta.Test.Browser,
        
    methods : {
        
        initialize : function() {
            // Since this test is preloading jQuery, we should let Siesta know what to 'expect'
            this.expectGlobals('$', 'jQuery');
            this.SUPER();
        },
     

        /**
         * This method returns the jQuery object from the scope of the test. When creating your own assertions for jQuery code, you need
         * to make sure you are using this method to get the `jQuery` instance. 
         * @return {Object} The `$` object from the scope of test
         */
        get$ : function () {
            return this.global.$;
        },

        normalizeElement : function (el) {
            return el.jquery ? el.get(0) : this.SUPERARG(arguments);
        }
    }
})
;
Class('Siesta.Content.Manager.Browser', {
    
    isa     : Siesta.Content.Manager,
    
    has : {
        baseHost            : function () { return window.location.host },
        baseProtocol        : function () { return window.location.protocol }
    },
    
    
    methods : {
        
        load : function (url, onsuccess, onerror) {
            var match       = /^((?:https?|file):)?\/\/([^/]*)/i.exec(url)
            
            if (match && (match[ 1 ] && match[ 1 ] != this.baseProtocol || match[ 2 ] != this.baseHost)) {
                onerror('cross-domain access')
                
                return
            }
            
            var req = new JooseX.SimpleRequest()
            
            try {
                req.getText(url, true, function (success, text) {
                    
                    if (!success) { 
                        onerror(this + " not found") 
                        return 
                    }
                    
                    onsuccess(text)
                })
            } catch (e) {
                onerror(e)
            }
        }
    }
})

;
Class('Siesta.Content.Manager.Browser.ExtJSCore', {
    isa     : Siesta.Content.Manager.Browser
})

;
/**
@class Siesta.Harness.Browser
@extends Siesta.Harness 

Class, representing the browser harness. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.Browser}, which contains
only generic browser-related assertions. So, use this harness class, when testing a generic web page.

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.


Synopsys
========

    var harness = new Siesta.Harness.Browser();
    
    harness.configure({
        title     : 'Awesome Test Suite',
        
        transparentEx       : true,
        
        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],
        
        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })
    
    
    harness.start(
        // simple string - url relative to harness file
        'sanity.t.js',
        
        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',
            
            // replace `preload` option of harness
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },
        
        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',
            
            autoCheckGlobals    : false,
            
            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )



*/

Class('Siesta.Harness.Browser', {
    
    isa         : Siesta.Harness,
    
    has : {
        id                  : null,
        
        /**
         * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.Browser}.
         * You can subclass {@link Siesta.Test.Browser} and provide a new class. 
         * 
         * This option can be also specified in the test file descriptor. 
         */
        testClass           : Siesta.Test.Browser,
        
        viewportClass       : "Siesta.Harness.Browser.UI.Viewport",

        viewport            : null,
        
        /**
         * @cfg {Boolean} autoRun When set to `true`, harness will automatically launch the execution either of the checked test files or the whole suite.
         * Default value is `false`
         */
        autoRun             : false,
        
        /**
         * @cfg {Boolean} viewDOM When set to `true`, harness will expand the panel with the `<iframe>` of the test file, so you can examine the content of DOM.
         * Default value is `false`
         */
        viewDOM             : false,
        
        /**
         * @cfg {String} domContainerRegion Should be exactly one of `east/west/south/north`. Controls the position of the dom container
         * panel. Set it to `south` to create a "portrait" mode of the results panel with the assertions grid at the top and DOM container
         * at the bottom.
         */
        domContainerRegion  : 'east',
        
        /**
         * @cfg {Boolean} speedRun When set to `true`, harness will reduce the quality or completely remove the visual effects for events simulation,
         * improving the speed of test. Default value is `true`.
         * 
         * This option can be also specified in the test file descriptor.
         */
        speedRun            : true,
        
        
        /**
         * @cfg {Integer} mouseMovePrecision 
         * 
         * Defines how precisely to follow the path between two points when simulating a drag or mouse move. 
         * Value 1 indicates that "mouseover/mouseout" events are simulated for every point along the path (which is 
         * often not required at all).
         * Value 2 indicates every other point will be used. In general, low value = slow dragging, high value = fast dragging.
         * 
         * Setting this option to some big number (like 100000) will cause Siesta to only simulate events for the 
         * initial and final points in the path, which provides significant performance boost. However, if you need
         * to verify some behaviour, triggered by mouse events from the element somewhere in the middle of the path
         * you may need to use lower value for this option. 
         * 
         * This option can be also specified in the test file descriptor.
         */
        mouseMovePrecision      : 1,

        /**
         * @cfg {Boolean} breakOnFail When set to `true`, the harness will not start launching any further tests after detecting a failed assertion.
         * Default value is `false`.
         */
        breakOnFail             : false,
        
        /**
         * @cfg {Boolean} debuggerOnFail When set to `true`, the harness will issue a `debugger` statement after detecting a failed assertion, allowing you
         * to inspect the internal state of the test in the browser's debugger. Default value is `false`.   
         */
        debuggerOnFail          : false,

        /**
         * @cfg {Boolean} failOnResourceLoadError When set to `true`, test will try to detect the failures for loading of 
         * various resources (`script/link/img` tags) and report those as failed assertions. Only supported in modern browsers.
         * Default value is `false`.
         * 
         * This option can be also specified in the test file descriptor.
         */
        failOnResourceLoadError : false,
        
        contentManagerClass : Siesta.Content.Manager.Browser,
        scopeProvider       : 'Scope.Provider.IFrame',
        
        /**
         * @cfg {Boolean} disableCaching When set to `true`, harness will prevent the browser caching of files being preloaded and the test files, by appending
         * a query string to it.
         * Note, that in this case, debuggers may not understand that you are actually loading the same file, and breakpoints may not work. Default value is `false`
         */
        disableCaching      : false,
        
        baseUrl             : window.location.href.replace(/(\?|#).*$/, '').replace(/\/[^/]*$/, '/'),
        baseHost            : window.location.host,
        baseProtocol        : window.location.protocol,
        
        /**
         * @cfg {Boolean} forceDOMVisible When set to `true` the tests will be executed in "fullscreen" mode, with their iframes on top of all other elements.
         * This is required in IE if your test includes interaction with the DOM, because the `document.getElementFromPoint()` method 
         * does not work correctly in IE unless the element is visible.
         *
         * This option is enabled by default in IE and disabled in all other browsers.
         * This option can be also specified in the test file descriptor (usually you will create a group of "rendering" tests). Usually it's only relevant for IE,
         * so using this option should look like:
         *

    harness.start(
        {
            group       : 'Rendering',
            
            forceDOMVisible    : $.browser.msie,
            
            items       : [
                'rendering/01_grid.t.js',
                ...
            ]
        },
        ...
    )
        
         */
        forceDOMVisible     : $.browser.msie,
        
        /**
         * @cfg {Boolean} runInPopup Experimental. When set to `true` the tests will be executed in the popup, instead of iframe.
         * You will need to enable popups the host you are testing from.
         * 
         * Popups provides almost exactly the same environment as standalone page - notably the `window.top` property
         * reference the popup itself, making it easier to test hash-based navigation.
         * 
         * Note, that mouse cursor visualization does not work for tests in popups.
         * 
         * This option can be also specified in the test file descriptor.
         */
        runInPopup          : false,
        
        
        /**
         * @cfg {String} pageUrl The url of the HTML page which will be the target for the test(s) (the URL must be on the same domain the harness HTML page). This option is used for application level testing, Siesta will visit this URL and then launch
         * the test. See `/examples/021-extjs-drag-drop/index.js` for an example.
         * 
         * Note that with this option, the test descriptor will stop inheriting the {@link #preload} option from parent descriptors/harness
         * (to make sure you don't preload your dependencies twice). This is usually an expected behavior, and you still can specify the `preload` option
         * directly on such descriptor if needed.
         * 
         * This option can be also specified in the test file descriptor. This option has a deprecated synonym - "hostPageUrl"
         * 
         * For example, to define that a test should be executed on a page generated by some php script:

    harness.start(
        {
            pageUrl         : '../my_php_script?page=home',     // url of the html page for test
            url             : '020_home_page_drag_n_drop.t.js'  // url of the js file, containing actual test code
        },
        ...
    )
         *  
         * 
         */
        pageUrl             : null,
        
        
        /**
         * @cfg {Boolean} useStrictMode When set to `false` the test scopes will be created w/o strict mode `DOCTYPE`. Default value is `true`.
         * This option is not applicable for tests with `pageUrl` option. 
         * 
         * This option can be also specified in the test file descriptor.
         */
        useStrictMode       : true,
        
        
        /**
         * @cfg {String} innerHtmlHead
         * 
         * A string that will be placed into the `innerHTML` property of the &lt;head&gt; tag, before starting the preload process. 
         * No validity checks will be performed.
         * 
         * This option will not be inherited by the tests with {@link #pageUrl} option set, unless it is explicitly set to the
         * `inherit` value.
         * 
         * This option can be specified in the test file descriptor.
         * 
         * See also {@link #innerHtmlBody}
         */
        innerHtmlHead       : null,
        
        
        /**
         * @cfg {String} innerHtmlBody
         * 
         * A string that will be placed into the `innerHTML` property of the &lt;body&gt; tag, before starting the preload process. 
         * No validity checks will be performed.
         * 
         * This option will not be inherited by the tests with {@link #pageUrl} option set, unless it is explicitly set to the
         * `inherit` value.
         * 
         * This option can be specified in the test file descriptor.
         * 
         * See also {@link #innerHtmlHead}
         */
        innerHtmlBody       : null,
        
        
        /**
         * @cfg {Boolean} sandbox
         * 
         * This option controls whether the individual tests should be run in isolation from each other. By default it is enabled,
         * and every test file will be run inside of the newly created iframe, so that it can not interfere with
         * any other test. Such setup gives you predictable starting state for every test, removes the need for any kind of
         * cleanup at the end of the test and is more robust in general.
         * 
         * However, the setup of every iframe take some time (for preloading). If you are sure that your tests
         * do not modify any global state (like global variable that can affect the other test) you may want to run 
         * all of them in the same context, saving the setup time. In this case, you may want to disable this option.
         * 
         * Siesta collects all tests with this option disabled and split them into chunks. Every chunk will have exactly
         * the same values for the configs that influence the initial setup of the page: {@link #preload}, {@link #alsoPreload}, 
         * {@link #pageUrl}, {@link Siesta.Test.ExtJS#requires} and some others. The tests inside of every 
         * chunk will be run sequentially, in the same sandbox.
         * 
         * **Important**: The 1st test in every chunk will be run normally. Starting from the 2nd one, tests
         * will skip the {@link Siesta.Test#isReady} check and {@link Siesta.Test#setup} methods. This is because all the 
         * setup is supposed to be already done by the 1st test. This behavior may change (or made configurable) in the future. 
         * 
         * This option can be specified in the test file descriptor.
         * 
         * See also {@link #sandboxBoundaryByGroup}, {@link #sandboxCleanup}
         */
        sandbox                         : true,
        
        /**
         * @cfg {Boolean} sandboxBoundaryByGroup
         * 
         * Only applicable for tests with the {@link #sandbox} option *disabled*.
         * 
         * when this option is enabled, the tests to be run in the same context will be guaranteed to reside in the same group.
         * If a new test group starts (even with the same "preload" config) - a fresh context for that group will be created
         * by Siesta.
         * 
         * For example, in the following setup, both "Group 1" and "Group 2" have sandboxing disabled and the 
         * same "preload" config. If `sandboxBoundaryByGroup` will be disabled all 4 individual tests will be run 
         * in the same context. If `sandboxBoundaryByGroup` will be enabled, separate fresh context will be created
         * for the tests from each group.  
         * 

    harness.configure({
        preload     : [ ... ]
    });
    
    harness.start(
        {
            group       : 'Group 1',
            sandbox     : false,
            items       : [
                '010-basics/010_sanity.t.js',
                '010-basics/020_jshint.t.js'
            ]
        },
        {
            group       : 'Group 2',
            sandbox     : false,
            items       : [
                '020-basics/010_sanity.t.js',
                '020-basics/030_bdd.t.js'
            ]
        },
        ...
    )

         * 
         */
        sandboxBoundaryByGroup          : true,
        
        
        /**
         * @cfg {Boolean} sandboxCleanup
         * 
         * Only applicable for tests with the {@link #sandbox} option *disabled*. When enabled, test that runs
         * in shared sandbox (the sandbox in which another test just has been run) will perform a cleanup. 
         * 
         * By default it will remove any "unexpected" globals (see {@link #expectedGlobals}) and clear the DOM.
         * 
         * If you will disable this option, every new test in the "groups" will start from the state previous test
         * has finished the execution. This will allow you split one big test scenario into several files
         * 
         * This option can be specified in the test file descriptor.
         */
        sandboxCleanup                  : true,
        
        uniqueCounter                   : 0,
        valueToHashIndicies             : Joose.I.Object,
        
        // lazy attribute, should be accessed with "getSandboxHashStructure" method
        sandboxHashStructure            : {
            lazy    : 'this.buildSandboxHashStructure'
        },
        
        
        /**
         * @cfg {String} runCore Either `parallel` or `sequential`. Indicates how the individual tests should be run - several at once or one-by-one.
         * 
         * Default value is "parallel", except for IE 6, 7, 8 where it's set to `sequential`.
         * 
         * Set this option to `sequential` for tests, that uses some exclusive resources (like for example focus of the
         * text fields).
         * 

    harness.start(
        'some_test.t.js',
        {
            url         : 'test_that_relies_on_focus.t.js',
            runCore     : 'sequential'
        }
    )

         * 
         * This option can be also specified in the test file descriptor. 
         */
        runCore                 : 'parallel',
        
        // a `runCore` value, "forced" for all tests, private, used for automation
        forcedRunCore           : null,
        
        /**
         * @cfg {String} simulateEventsWith
         * 
         * This option is IE9-strict mode (and probably above) specific. It specifies how Siesta should simulate events.
         * The options are 'dispatchEvent' (W3C standard) or 'fireEvent' (MS interface) - both are available in IE9 strict mode
         * and each activates different set of event listeners. See this blog post for detailed explanations: 
         * <http://www.digitalenginesoftware.com/blog/archives/76-DOM-Event-Model-Compatibility-or-Why-fireEvent-Doesnt-Trigger-addEventListener.html>
         * 
         * Valid values are "dispatchEvent" and "fireEvent".
         * 
         * The framework specific adapters (like {@link Siesta.Test.ExtJS} and like {@link Siesta.Test.jQuery}) choose the most appropriate value
         * automatically (unless explicitly configured). 
         */
        simulateEventsWith  : {
            is      : 'rw',
            init    : 'dispatchEvent'
        },
        
        // the test with currently "forced" (by the "forceDOMVisible" option) iframe 
        testOfForcedIFrame          : null,
        
        /**
         * @cfg {Boolean} autoScrollElementsIntoView
         * 
         * With this option enabled Siesta will try to scroll invisible action targets into the view automatically, before performing an
         * action (such as click etc).
         * 
         * This option can also be specified in the test file descriptor.
         */
        autoScrollElementsIntoView  : true,
        
        /**
         * @cfg {Boolean} enableUnreachableClickWarning When this option is set to `true` (default) Siesta will generate warnings
         * when click happens in the unreachable point of some element. For example, imagine the following situation: you have
         * a 10x10px "div" element with "overflow : hidden", and inside of it, another inner "div" 10x50px. Then you ask Siesta
         * to click on the inner div (by default it clicks in the center). The center of inner div is hidden by the outer div,
         * so click will happen on some other element and a warning will be issued.
         * 
         * Usually this behaviour is what you want, since it protects you from various mistakes, but sometimes you may want
         * to disable it, for example if you want to write your clicks like this: `{ click : someEl, offset : [ "50%", "100%+10" ] }`
         * (which means - click 10px to the right from right edge of the `someEl`).
         * 
         * Note, that warning won't be issued if in the click point there's some child element of the target element.
         * 
         * This option can also be specified in the test file descriptor.
         */
        enableUnreachableClickWarning   : true,
        
        
        /**
         * @cfg {Boolean} maintainViewportSize
         * 
         * Enabling this option will cause Siesta to honor the {@link #viewportWidth} and {@link #viewportHeight} configuration options.
         * 
         * This option can also be specified in the test file descriptor.
         */
        maintainViewportSize        : true,
        
        /**
         * @cfg {Number} viewportWidth 
         * 
         * The width of the test iframe, default value is 1024
         */
        viewportWidth               : 1024,
        
        /**
         * @cfg {Number} viewportHeight
         * 
         * The height of the test iframe, default value is 768
         */
        viewportHeight              : 768,

        /**
         * @cfg {Object} recorderConfig A custom config object used to configure the {@link Siesta.Recorder.Recorder} instance
         */
        recorderConfig              : null,
        
        /**
         * @cfg {Boolean} jasmine This option can only be specified in the {@link Siesta.Harness#start test files descriptor}.
         * If its set to `true`, the `url` property of the descriptor should point to the Jasmine spec runner html page.
         * Siesta then will automatically import the results from the Jasmine suite.
         * 
         * Additionally, one need to add a special reporter to the spec runner page, which is available 
         * as `SIESTA_FOLDER/bin/jasmine-siesta-reporter.js`.
         * 
         * Currently Siesta can import the results from Jasmine 2.0 and above.
         * 
         * Typical setup will look like (see also `SIESTA_FOLDER/examples/1.unit-tests/jasmine_suite/SpecRunner.html` example):

    <head>
        ...
        <script src="lib/jasmine-2.2.0/jasmine.js"></script>
        <script src="lib/jasmine-2.2.0/jasmine-html.js"></script>
        <script src="lib/jasmine-2.2.0/boot.js"></script>
        
        <!-- Add Siesta reporter to your Jamsine spec runner (adjust the path) -->
        <script src="../../../bin/jasmine-siesta-reporter.js"></script>
        ....
    </head>
             * &nbsp;
 
    harness.start(
        // regular Siesta test
        '010_regular_test.t.js',
        
        // a Jasmine test suite 
        {
            jasmine         : true,
            expectedGlobals : [ 'Player', 'Song' ],
            // url should point to the specs runner html page in this case 
            url             : 'jasmine_suite/SpecRunner.html'
        }
    )

         */
        

        /**
         * @cfg {Boolean} needUI This option determines whether the Siesta UI should be rendered. By default, it is enabled
         * when running suite in the browser and disabled in automation launcher. You can explictly set it to `true`, to show the UI
         * even in automation mode:
         * 

    harness.configure({
        needUI      : true
    })

         */
        needUI                      : true,
        
        // will read the settings from cookies when started
        stateful                    : true,
        
        uiMask                      : null,
        uiMaskActive                : false,
        
        hostPageUrlStopsInheriting  : function () {
            return this.buildHostPageUrlStopsInheriting()
        },

        /**
         * @cfg {String} rerunHotKey The key to press together with CTRL to rerun the latest test
         */
        rerunHotKey      : 'E',
        
        /**
         * @cfg {Boolean} restartOnBlur
         * 
         * **Experimental**. When this option is enabled, Siesta will emit a warning when focus moves outside of the test window.
         * When running in automation mode Siesta will also restart the test.
         * 
         * This option can also be specified in the test file descriptor.
         */
        restartOnBlur           : false,
        
        focusChecker            : {
            lazy        : function () {
                var el      = document.createElement('input')
                el.setAttribute('style', 'position : absolute; left : -1000px; top : -1000px')
                el.type     = 'text'
                
                document.body.appendChild(el)
                
                return el
            }
        }
    },
    
    
    after : {
        
        onBeforeScopePreload : function (scopeProvider, url) {
            if (this.viewport) this.viewport.onBeforeScopePreload(scopeProvider, url)
        },
        
        
        onTestSuiteStart : function (descriptors, contentManager, launchState) {
            if (this.viewport) this.viewport.onTestSuiteStart(descriptors, contentManager)
        },
        
        
        onTestSuiteEnd : function (descriptors, contentManager) {
            if (this.viewport) this.viewport.onTestSuiteEnd(descriptors, contentManager)
            
            // remove the links to forced iframe / test in hope to ease the memory pressure
            delete this.testOfForcedIFrame
            
            if (this.uiMaskActive) this.hideUiMask()
        },
        
        
        onTestStart : function (test) {
            if (this.viewport) this.viewport.onTestStart(test)
            
            if (test.hasForcedIframe()) {
                if (this.testOfForcedIFrame) this.hideForcedIFrame(this.testOfForcedIFrame)
            
                this.showForcedIFrame(test)
            
                this.testOfForcedIFrame     = test
            } else {
                if (this.uiMaskActive) this.hideUiMask()
            }
        },
        
        
        onTestUpdate : function (test, result, parentResult) {
            if (this.viewport) this.viewport.onTestUpdate(test, result, parentResult)
            
            if ((result instanceof Siesta.Result.Diagnostic) && result.isWarning && this.needUI) { 
                if (typeof console != 'undefined' && console.warn) console.warn(result + '')
            }
        },
        
        
        onTestEnd : function (test) {
            if (test.hasForcedIframe())             this.hideForcedIFrame(test)
            
            if (test == this.testOfForcedIFrame)    this.testOfForcedIFrame = null
            
            if (this.viewport) this.viewport.onTestEnd(test)
            
            // when browser is simulating the event on the element that is not visible in the iframe
            // it will scroll that point into view, using the `scrollLeft` property of the parent element
            // this line fixes that displacement
            var wrapper     = test.scopeProvider.wrapper
            
            if (wrapper) {
                wrapper.scrollLeft      = wrapper.scrollTop = 0
            }
            document.body.scrollLeft    = document.body.scrollTop = 0
        },
        
        
        onTestFail : function (test, exception, stack) {
            if (this.viewport) this.viewport.onTestFail(test, exception, stack)
        }
    },
    
    
    methods : {
        
        buildHostPageUrlStopsInheriting : function () {
            return {
                preload         : true,
                innerHtmlHead   : true,
                innerHtmlBody   : true
            }
        },
        
        
        buildSandboxHashStructure : function () {
            return [
                'preload',
                'alsoPreload',
                'hostPageUrl',
                'pageUrl',
                'useStrictMode',
                'overrideSetTimeout'
            ]
        },
    
    
        createViewport       : function(config) {
            return Ext.create(this.viewportClass, config);
        },
        
        
        canShowCursorForTest : function (test) {
            // return false for test's running in popups (not iframes), since we can't show any visual accompaniment for them
            if (!(test.scopeProvider instanceof Scope.Provider.IFrame)) return false;
        
            // if there is a "forced to be on top" test then we only need to compare the tests instances
            if (this.testOfForcedIFrame) {
                return this.testOfForcedIFrame.isFromTheSameGeneration(test)
            }
            
            // finally we can only show cursor for tests with iframe wrapper
            // (since mouse visualizer puts the cursor in it)
            return Boolean(test.scopeProvider.wrapper)
        },
        
        
        configure : function() {
            this.SUPERARG(arguments);

            this.id = this.title || window.location.href;
        },

        
        start : function () {
            // Opera's global variables handling is weird
            if ($.browser.opera) {
                this.autoCheckGlobals = false;
            }
            
            if ($.browser.msie && $.browser.version !== "9.0") {
                if (!this.hasOwnProperty('runCore')) this.runCore = 'sequential'
            }
            
            this.SUPERARG(arguments)
        },
        
        
        populateCleanScopeGlobals : function (scopeProvider, callback) {
            if (this.disableGlobalsCheck || $.browser.msie && Number(/^(\d+)/.exec($.browser.version)[ 1 ]) < 9) {
                // do nothing for IE < 9 - testing leakage of globals is not supported
                // also IE8 often crashes on this stage
                this.disableGlobalsCheck = true
                
                callback()
                
                return
            }
            
            // always populate the globals from IFrame (even if user specified the Window provider)
            this.SUPER('Scope.Provider.IFrame', callback)
        },
        
        
        onUnload : function () {
            Joose.O.each(this.scopesByURL, function (scopeProvider, url) {
                // to close opened popups when harness page unloads
                scopeProvider.cleanup()
            })
        },
        
        
        setup : function (callback) {
            var me      = this
            var sup     = this.SUPER
            
            window.onunload     = function () { me.onUnload() }
            
            // required to bring the window to front in FF
            window.focus()

            $(function () {
                // init the singleton
                Siesta.Harness.Browser.FeatureSupport();
                
                var needUI      = me.hasOwnProperty('needUI') || !me.isAutomated ? me.needUI : false
                
                if (typeof Ext != 'undefined' && needUI) {
                    me.autoLaunchTests  = false
                    
                    Ext.onReady(function () {
                        sup.call(me, function () {
                            me.viewport = me.createViewport({
                                title           : me.title,
                                harness         : me
                            })
                            
                            callback && callback()
                        })
                    })
                } else {
                    sup.call(me, callback)
                }
            })
        },
        
        
        getDescriptorConfig : function (descriptor, configName, doNotLookAtRoot) {
            // for any "normal" config use regular parent implementation
            if (!(configName in this.hostPageUrlStopsInheriting)) return this.SUPERARG(arguments)
            
            var testConfig          = descriptor.testConfig
            
            var hasOwnValue         = testConfig && testConfig.hasOwnProperty(configName) || descriptor.hasOwnProperty(configName)
            // this will include lookup in the "testConfig"
            var configValue         = this.lookUpValueInDescriptorTree(descriptor, configName)
            
            var hasPageUrl          = Boolean(this.getDescriptorConfig(descriptor, 'pageUrl', true))
            
            // for host page url, if we found preload value which is not inherit, then return it if its own 
            // (defined on the descriptor) otherwise return empty array
            if (hasPageUrl && configValue != 'inherit') return hasOwnValue ? configValue : []
                    
            do {
                var testConfig      = descriptor.testConfig
                var testHasValue    = testConfig && testConfig.hasOwnProperty(configName)
                
                if (testHasValue || descriptor.hasOwnProperty(configName)) {
                    var value       = testHasValue ? testConfig[ configName ] : descriptor[ configName ]
                    
                    if (value != 'inherit') return value
                }
                
                descriptor          = descriptor.parent
                
            } while (descriptor && descriptor != this)
                
            if (doNotLookAtRoot) 
                return undefined
            else
                return this[ configName ]
        },
        
        
        normalizeScopeProvider : function (desc) {
            this.SUPERARG(arguments)
            
            if (this.getDescriptorConfig(desc, 'runInPopup')) desc.scopeProvider = 'Scope.Provider.Window'
        },
        
        
        getScopeProviderConfigFor : function (desc, launchId) {
            var me                          = this
            var config                      = this.SUPERARG(arguments)
            
            config.cleanupDelay             = 0
            config.name                     = desc.title || desc.url.replace(/(.*\/)?(.*)/, '$2')
            config.cls                      = 'tr-iframe'
            
            config.performWrap              = true
            
            var wrapper                     = document.createElement('div')
            
            wrapper.className               = 'tr-iframe-wrapper'
            wrapper.innerHTML               = "<div class='tr-close fa fa-close'>&nbsp;</div><div class='tr-iframe-wrapper-inner'></div>"
            
            wrapper.childNodes[ 0 ].onclick = function () {
                var test                    = me.getTestByURL(desc.url)
                
                if (test) {
                    me.hideForcedIFrame(test)
                    
                    if (me.viewport) me.viewport.onManualCloseOfForcedIframe(test)
                } else {
                    this.parentElement.style.left   = '-10000px'
                    this.parentElement.style.top    = '-10000px'
                }
            }
            
            config.wrapper                  = wrapper
            config.iframeParentEl           = wrapper.childNodes[ 1 ]
            
            config.sourceURL                = config.sourceURL || this.getDescriptorConfig(desc, 'pageUrl')
            config.minViewportSize          = config.minViewportSize || {
                width   : this.getDescriptorConfig(desc, 'viewportWidth'),
                height  : this.getDescriptorConfig(desc, 'viewportHeight')
            }
            
            config.innerHtmlHead            = this.getDescriptorConfig(desc, 'innerHtmlHead')
            config.innerHtmlBody            = this.getDescriptorConfig(desc, 'innerHtmlBody')
            
            config.failOnResourceLoadError  = this.getDescriptorConfig(desc, 'failOnResourceLoadError')
            
            if (!config.hasOwnProperty('useStrictMode')) config.useStrictMode = this.getDescriptorConfig(desc, 'useStrictMode')
            
            return config
        },
        
        
        getNewTestConfiguration : function (desc, scopeProvider, contentManager, launchState) {
            var me              = this
            var config          = this.SUPERARG(arguments)
            
            if (this.hasOwnProperty('simulateEventsWith')) config.simulateEventsWith = this.simulateEventsWith
            
            Joose.A.each([
                'forceDOMVisible',
                'mouseMovePrecision',
                'autoScrollElementsIntoView',
                'enableUnreachableClickWarning',
                'restartOnBlur'
            ], function (name) {
                config[ name ]  = me.getDescriptorConfig(desc, name)
            })
            
            if (this.getDescriptorConfig(desc, 'speedRun')) {
                Joose.O.extend(config, {
                    actionDelay         : 1,
                    dragDelay           : 10,
                    pathBatchSize       : 30
                })
            }
            
            return config
        },
        
        
        assignUniqueTag     : function (value, configName) {
            // has to be an Object-like value (object, array, function, etc)
            if (value == null) return ''
            
            if (value === Object(value)) {
                if (value.__UNIQUE__) return value.__UNIQUE__
                
                return value.__UNIQUE__ = (this.uniqueCounter++).toString(36)
            } else {
                value                   = value + ''
                
                var configIndex         = this.valueToHashIndicies[ configName ]
                
                if (!configIndex) configIndex = this.valueToHashIndicies[ configName ] = {}
                
                if (configIndex[ value ]) return configIndex[ value ]
                
                return configIndex[ value ] = (this.uniqueCounter++).toString(36)
            }
        },
        
        
        calculateSharedContextGroupHash : function (desc) {
            var me              = this
            var structure       = this.getSandboxHashStructure()
            
            var hash            = ''
            
            Joose.A.each(structure, function (configName) {
                hash            += me.assignUniqueTag(me.getDescriptorConfig(desc, configName), configName)
            })
            
            if (this.sandboxBoundaryByGroup) hash += this.assignUniqueTag(desc.parent)
                
            return hash
        },
        
        
        sortDescriptors : function (descriptors, forcedRunCore, idsOnly) {
            var me                  = this
            var canRunParallel      = []
            var mustRunSequential   = []
            
            // array of { groupHash : ..., items : [] } objects
            var sharedContextGroups = []
            var groupsByHash        = {}
            
            Joose.A.each(descriptors, function (desc) {
                if (!me.getDescriptorConfig(desc, 'sandbox')) {
                    var hash        = me.calculateSharedContextGroupHash(desc)
                    var group       = groupsByHash[ hash ]
                    
                    if (!group) {
                        group       = groupsByHash[ hash ] = { groupHash : hash, items : [] }
                        sharedContextGroups.push(group)
                    }
                    
                    group.items.push(idsOnly ? desc.id : desc)
                } else {
                    var runCore         = forcedRunCore || me.getDescriptorConfig(desc, 'runCore')
                    
                    if (runCore == 'sequential' || me.getDescriptorConfig(desc, 'forceDOMVisible'))
                        mustRunSequential.push(idsOnly ? desc.id : desc)
                    else
                        canRunParallel.push(idsOnly ? desc.id : desc)
                }
            })
            
            return {
                sharedContextGroups     : sharedContextGroups,
                mustRunSequential       : mustRunSequential,
                canRunParallel          : canRunParallel
            }
        },
        
        
        runCoreGeneral : function (descriptors, contentManager, launchState, callback) {
            var me          = this
            var sorted      = this.sortDescriptors(descriptors, this.forcedRunCore, false)
            
            me.runCoreSharedContext(sorted.sharedContextGroups, contentManager, launchState, function () {
                    
                me.runCoreParallel(sorted.canRunParallel, contentManager, launchState, function () {
                    
                    me.runCoreSequential(sorted.mustRunSequential, contentManager, launchState, callback)
                })
            })
        },
        
        
        runCoreSharedContext : function (sharedContextGroups, contentManager, launchState, callback) {
            var me                  = this
            
            var processDescriptor   = function (group, isFirst, scopeProvider, firstDesc) {
                var descriptors     = group.items
                
                if (!descriptors.length) { processGroup(sharedContextGroups); return }
                
                var desc            = descriptors.shift()
                
                // if there's a descriptor left after the shift do not cleanup the
                // scope provider at the end of the test (as its going to be re-used by the next test)
                var noCleanup       = descriptors.length > 0
                
                if (isFirst) {
                    // new context should be created for the 1st item in the group
                    me.processURL(desc, desc.index, contentManager, launchState, function () {
                        processDescriptor(group, false, me.scopesByURL[ desc.url ], desc)
                    }, noCleanup, group)
                } else {
                    // same context should be re-used
                    me.processUrlShared(desc, desc.index, contentManager, launchState, function () {
                        processDescriptor(group, false, scopeProvider, firstDesc)
                    }, noCleanup, group, scopeProvider, firstDesc)
                }
            }
                
            var processGroup        = function (sharedContextGroups) {
                if (!sharedContextGroups.length) { callback(); return }
                
                var group           = sharedContextGroups.shift()
                
                processDescriptor(group, true)
            }
            
            processGroup(sharedContextGroups)
        },
        
        
        processUrlShared : function (desc, index, contentManager, launchState, callback, noCleanup, sharedSandboxState, scopeProvider, firstDesc) {
            var me      = this
            var url     = desc.url
            
            // If first test in group is missing - behavior is undefined
            if (desc.isMissing) {
                callback()
                
                return
            }
            
            // a magical shared object, which will contain the `test` property with test instance, once the test will be created
            var testHolder      = {}
            // an array of errors occured during preload phase
            var preloadErrors   = []    
            
            var onErrorHandler  = this.getOnErrorHandler(testHolder, preloadErrors)
            var transparentEx   = this.getDescriptorConfig(desc, 'transparentEx')
            
            // trying to setup the `onerror` handler as early as possible - to detect each and every exception from the test
            scopeProvider.addOnErrorHandler(onErrorHandler, !transparentEx)
            
            if (desc.testCode || this.cachePreload && contentManager.hasContentOf(desc.url))
                scopeProvider.runCode(desc.testCode || contentManager.getContentOf(desc.url), cont)
            else
                scopeProvider.runScript(this.resolveURL(desc.url, scopeProvider, desc), cont)
                
            function cont() {
                // scope provider has been cleaned up while setting up? (may be user has restarted the test)
                // then do nothing
                if (!scopeProvider.scope) { callback(); return }
                
                var testClass       = me.getDescriptorConfig(desc, 'testClass')
                if (me.typeOf(testClass) == 'String') testClass = Joose.S.strToClass(testClass)
                
                var testConfig      = me.getNewTestConfiguration(desc, scopeProvider, contentManager, launchState, sharedSandboxState)
                
                // create the test instance early, so that one can perform some setup (as the test class method call)
                // even before the "pageUrl" starts loading
                var test            = testHolder.test = new testClass(testConfig)
                
                me.launchTest({
                    testHolder          : testHolder,
                    desc                : desc,
                    scopeProvider       : scopeProvider,
                    contentManager      : contentManager,
                    launchState         : launchState,
                    preloadErrors       : preloadErrors,
                    onErrorHandler      : onErrorHandler,
                    
                    startTestAnchor     : scopeProvider.scope.StartTest,
                    noCleanup           : noCleanup,
                    cleanupUrl          : firstDesc.url,
                    reusingSandbox      : true
                }, callback)
            }
        },
        
        
        normalizeURL : function (url) {
            // ref to JSAN module - DEPRECATED
            if (/^jsan:/.test(url)) url = '/jsan/' + url.replace(/^jsan:/, '').replace(/\./g, '/') + '.js'
            
            // ref to lib in current dist (no `/` and trailing `.js`) - DEPRECATED 
            if (!/\.js$/.test(url) && !/\//.test(url) && !/\.css(\?.*)?$/i.test(url)) url = '../lib/' + url.replace(/\./g, '/') + '.js'
            
            return url
        },
        
        
        normalizeDescriptor : function (desc, parent, index, level) {
            var desc        = this.SUPERARG(arguments)
            
            if (!desc.group && desc.jasmine) {
                desc.pageUrl            = desc.url
                desc.testCode           = this.getJasmineTestCode()
                // preloads will not be inherited anyway because "pageUrl" option presents
                // but we explicitly remove them one more time
                desc.preload            = []
            }
            
            return desc
        },

    
        resolveURL : function (url, scopeProvider, desc) {
            // if the `scopeProvider` is provided and it has a sourceURL - then absolutize the preloads relative to that url
            if (scopeProvider && scopeProvider.sourceURL) url = this.absolutizeURL(url)
            
            if (this.disableCaching)
                // if there's a ?param string in url - append new param
                if (/\?./.test(url))
                    url += '&disableCaching=' + new Date().getTime()
                else
                    if (!/\?$/.test(url)) 
                        url += '?disableCaching=' + new Date().getTime()
            
            // otherwise assumed to be a raw filename, relative or absolute
            return url
        },
        
        
        absolutizeURL : function (url, baseUrl) {
            // if the url is already absolute - just return it (perhaps with some normalization - 2nd case)
            // the url starting with // is also valid absolute url
            if (/^((https?|file):)?\/\//.test(url))  return url
            if (/^\//.test(url))    return this.baseProtocol + '//' + this.baseHost + url
            
            baseUrl             = baseUrl || this.baseUrl
            
            // strip the potential query and filename from baseURL, leaving only the "directory" part
            baseUrl             = baseUrl.replace(/\?.*$/,'').replace(/\/[^/]*$/, '/')
            
            // first absolutize the base url relative the harness page (which will be always global, so it won't recurse)
            var absBaseUrl      = this.absolutizeURL(baseUrl, this.baseUrl)
            
            // add a trailing "/" if missing
            absBaseUrl          = absBaseUrl.replace(/\/?$/, '/')
            
            return absBaseUrl + url
        },
        
        
        getUiMask : function () {
            if (this.uiMask) return this.uiMask
            
            var uiMask              = this.uiMask = document.createElement('div')
            
            uiMask.className        = 'tr-ui-mask'
            uiMask.style.display    = 'none'
            
            document.body.appendChild(uiMask)
            
            return uiMask
        },
        
        
        showUiMask  : function () {
            var mask            = this.getUiMask()
            
            mask.style.display  = 'block'
            
            this.uiMaskActive   = true
        },
        
        
        hideUiMask  : function () {
            var mask            = this.getUiMask()
            
            mask.style.display  = 'none'
            
            this.uiMaskActive   = false
        },
        
        
        showForcedIFrame : function (test) {
            $.rebindWindowContext(window);
            
            test.isDOMForced    = true
            
            var wrapper         = test.scopeProvider.wrapper
            
            $(wrapper).addClass('tr-iframe-forced')
            $(wrapper).removeClass('tr-iframe-hidden')
        
            $(wrapper).center()
            
            test.fireEvent('testframeshow')
        },
    
    
        hideForcedIFrame : function (test) {
            $.rebindWindowContext(window);
            
            // once hidden, forced iframe will be never be shown again as "forced", only as "normal"
            test.isDOMForced        = false
            test.forceDOMVisible    = false
            
            var wrapper         = test.scopeProvider.wrapper
            
            $(wrapper).removeClass('tr-iframe-forced')
            $(wrapper).addClass('tr-iframe-hidden')
            
            test.fireEvent('testframehide')
        },
        
        
        showForcedIFrameScreenshot : function (test) {
            this.showUiMask()
            
            $.rebindWindowContext(window);
            
            var wrapper         = test.scopeProvider.wrapper
            
            $(wrapper).addClass('tr-iframe-forced-screenshot')
            $(wrapper).removeClass('tr-iframe-forced')
            $(wrapper).removeClass('tr-iframe-hidden')
        },
    
    
        hideForcedIFrameScreenshot : function (test) {
            this.hideUiMask()
            
            $.rebindWindowContext(window);
            
            var wrapper         = test.scopeProvider.wrapper
            
            $(wrapper).removeClass('tr-iframe-forced-screenshot')
            
            if (test.isDOMForced) {
                $(wrapper).addClass('tr-iframe-forced')
                $(wrapper).center()
            }
        },
        
        
        getQueryParam : function (paramName) {
            return this.my.getQueryParam(paramName, true)
        },
        
        
        getJasmineTestCode : function () {
            return ';(' + (function () {
                
                StartTest(function (t) {
                    t.expectGlobals(
                        'getJasmineRequireObj', 'jasmineRequire', 'jasmine', 'xdescribe', 'describe', 'xdescribe', 'fdescribe',
                        'it', 'xit', 'fit', 'spyOn', 'fail', 'jsApiReporter', 'beforeEach', 'afterEach', 'beforeAll', 'afterAll',
                        'expect', 'pending'
                    )
                    
                    if (!window.jasmine) {
                        t.fail(t.resource('Siesta.Harness.Browser', 'noJasmine'))
                        
                        return
                    }
                    
                    if (!jasmine.SiestaReporter) {
                        t.fail(t.resource('Siesta.Harness.Browser', 'noJasmineSiestaReporter'))
                        
                        return
                    }
                    
                    jasmine.SiestaReporter.importResults(t)
                })
                
            }).toString() + ')();'
        },
        
        
        /**
         * This methos returns `true` if this harness is being run on the 
         * [Standard package](http://www.bryntum.com/products/siesta/) of Siesta, `false` otherwise.
         * 
         * @return {Boolean}
         */
        isStandardPackage : function () {
            return this.my.isStandardPackage(true)
        },
        
        
        // should only be used when no tests are running
        // does not work for IE
        // Safari webdriver has known problem of starting browser in the background, w/o focus
        browserWindowHasFocus : function () {
            window.focus()
            
            var el      = this.getFocusChecker()
            
            el.focus()
            
            $.rebindWindowContext(window);
            
            return $(el).is(':focus')    
        }
    },
    
    
    my : {
        
        methods : {
            
            isStandardPackage : function (calledFromInstance) {
                if (!calledFromInstance) this.staticDeprecationWarning('isStandardPackage')
                
                return Boolean(Siesta.Harness.Browser.Automation)
            },
            
            
            getQueryParam : function (paramName, calledFromInstance) {
                if (!calledFromInstance) this.staticDeprecationWarning('getQueryParam')
                
                var regex       = new RegExp('(?:\\?|&)' + paramName + '=(.*?)(?:\\?|&|$)', 'i')
            
                var match       = regex.exec(window.location.search)
            
                if (!match) return null
            
                return match[ 1 ]
            }
        }
    }
})
//eof Siesta.Harness.Browser;
Singleton('Siesta.Harness.Browser.FeatureSupport', {
    
    has     : {
        supports    : Joose.I.Object,
        
        simulator   : null,
        
        tests       : {
            init        : [
                // "fn"s are called as methods of the "Siesta.Harness.Browser.FeatureSupport" singleton
                {
                    id : "mouseEnterLeave",
                    fn : function() {
                        var el = document.createElement("div");
                        return 'onmouseenter' in el && 'onmouseleave' in el;
                    }
                },
        
                {
                    id : "enterOnAnchorTriggersClick",
                    fn : function() {
                        var sim     = this.simulator,
                            E       = Siesta.Test.Simulate.KeyCodes().keys.ENTER,
                            result  = false;
                            
                        var anchor = $('<a href="foo" style="display:none">test me</a>');
                        $('body').append(anchor);
        
                        anchor.focus();
                        anchor.click(function(e) {
                            result = true;
                            return false;
                        });
                
                        sim.simulateEvent(anchor, 'keypress', { keyCode : E, charCode : 0 }, true);
                 
                        anchor.remove();
                        return result;
                    }
                },
        
                {
                    id : "canSimulateKeyCharacters",
                    fn : function() {
                        var sim     = this.simulator;
                        
                        var input   = $('<input class="siesta-hidden" type="text" />'),
                            A       = Siesta.Test.Simulate.KeyCodes().keys.A;
                            
                        $('body').append(input);
                        
                        input.focus();
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A }, true);
                        sim.simulateEvent(input, 'textInput', { text : "A" }, true);
                
                        var result  = input.val() === 'A';
                        
                        input.remove();
                        
                        return result;
                    }
                },
        
                {
                    id : "canSimulateBackspace",
                    fn : function() {
                        var sim     = this.simulator;
                        
                        var input   = $('<input class="siesta-hidden" type="text" />'),
                            BS      = Siesta.Test.Simulate.KeyCodes().keys.BACKSPACE,
                            A       = Siesta.Test.Simulate.KeyCodes().keys.A;
                            
                        $('body').append(input);
                        
                        input.focus();
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A }, true);
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A }, true);
                        sim.simulateEvent(input, 'keypress', { keyCode : BS, charCode : BS }, true);
                        
                        var result  = input.val() === 'A';
                 
                        input.remove();
                        
                        return result;
                    }
                },

                {
                    id : "enterSubmitsForm",
                    fn : function() {
                        var sim     = this.simulator,
                            E       = Siesta.Test.Simulate.KeyCodes().keys.ENTER,
                            result  = false;

                        var form = $('<form method="post"><input type="text"/></form>');
                        var input = $(form).find('input');
                        $('body').append(form);

                        form[0].onsubmit = function(e) {
                            result = true;
                            return false;
                        };

                        input.focus();
                        sim.simulateEvent(input, 'keypress', { keyCode : E, charCode : 0 }, true);

                        form.remove();
                        return result;
                    }
                },
                // remove after https://bugzilla.mozilla.org/show_bug.cgi?id=959992 will be fixed
                {
                    id : "imageWithIdCreatesGlobalEnumerable",
                    fn : function () {
                        var img     = $('<img id="test_img_id"/>');
                        
                        $('body').append(img);
                        
                        var hasImgId    = false
                        
                        for (var i in window) {
                            if (i == 'test_img_id') hasImgId = true
                        }

                        img.remove();
                        
                        return hasImgId;
                    }
                },
                {
                    id  : 'TouchEvents',
                    fn  : function() {
                        return this.isEventSupported('touchend', window);
                    }
                },
                {
                    id  : 'PointerEvents',
                    fn  : function() {
                        return this.isEventSupported('pointerdown')
                    }
                },
                {
                    id  : 'MSPointerEvents',
                    fn  : function() {
                        return this.isEventSupported('mspointerdown')
                    }
                }
            ]
        }
        
    },
    
    methods     : {
        
        initialize : function() {
            var emptyFn = function() {},
                foo = Class({
                    does    : [
                        Siesta.Util.Role.CanGetType,
                        Siesta.Test.Simulate.Event,
                        Siesta.Test.Simulate.Mouse,
                        Siesta.Test.Simulate.Keyboard
                    ],
                
                    has     : {
                        global      : null
                    },
                
                    methods : {
                        focusOnClick        : emptyFn,
                        getElementAtCursor  : emptyFn,
                        fireEvent           : emptyFn,
                        addResult           : emptyFn,
                        isEventPrevented    : function() { return false; },
                        normalizeElement    : function(a) { return a[0]; },
                        findCenter          : function() { return [0,0]; },
                        valueIsArray        : function(arr) { return 'length' in arr; }
                    }
                });
            
            this.simulator = new foo({ global : window });
    
            for (var i = 0; i < this.tests.length; i++) {
                var test            = this.tests[i];
                var testId          = test.id;
                var detectorFn      = test.fn;
                
                // also save the results to "results" property - we'll use this in out own test suite
                // where we copy the feature testing results from the outer scope to inner
                this.supports[ testId ] = detectorFn.call(this);
            }
        },
        
        
        // from Modernizr
        isEventSupported: function (eventName, element) {
            var isSupported;
            
            if (!eventName) return false
            if (!element || typeof element === 'string') element = document.createElement(element || 'div');
    
            // Testing via the `in` operator is sufficient for modern browsers and IE.
            // When using `setAttribute`, IE skips "unload", WebKit skips "unload" and
            // "resize", whereas `in` "catches" those.
            eventName       = 'on' + eventName;
            isSupported     = eventName in element;
    
            // Fallback technique for old Firefox - bit.ly/event-detection
            if (!isSupported) {
                if (!element.setAttribute) {
                    // Switch to generic element if it lacks `setAttribute`.
                    // It could be the `document`, `window`, or something else.
                    element = document.createElement('div');
                }
    
                element.setAttribute(eventName, '');
                isSupported = typeof element[ eventName ] === 'function';
        
                if (element[ eventName ] !== undefined ) {
                    // If property was created, "remove it" by setting value to `undefined`.
                    element[ eventName ] = undefined;
                }
                element.removeAttribute(eventName);
            }
    
            return isSupported;            
        }
        
    }
})
;
/**
@class Siesta.Harness.Browser.ExtJSCore

This is a role (mixin), representing the shared functionality between Ext JS and SenchaTouch harnesses.

*/
Role('Siesta.Harness.Browser.ExtJSCore', {
    
    has : {
        /**
         * @cfg {Object} loaderPath
         * 
         * The path used to configure the Ext.Loader 'paths' config to resolve JS namespaces to file paths, for dynamic loading of Ext JS classes.
         * For more information, please see the Ext docs: http://docs.sencha.com/extjs/apidocs/#!/api/Ext.Loader-cfg-paths
         * 
         * See also {@link #requires}.
         * 
         * By default the value will be set right before the test starts. If you need to set it earlier (during preloading phase),
         * use {@link #getLoaderPathHook} method. 
         *
         * This option can be also specified in the test file descriptor. 
         * 
         * **Note**, that the value of this config will not be inherited from the parent tests group, if test has {@link Siesta.Harness.Browser#pageUrl} option set.
         */
        loaderPath              : null,
        
        /**
         * @cfg {Array[String]} requires
         * 
         * The array of class names, to be dynamically loaded with `Ext.require` call, before the test starts. Naturally, requires 
         * the correct value for the {@link #loaderPath} to be set. 
         * 
         * This option can be also specified in the test file descriptor. 
         */
        requires                : null,
        
        /**
         * @cfg {Boolean} waitForExtComponentQueryReady
         * 
         * Setting this configuration option to "true" will cause Siesta to wait until the `Ext.ComponentQuery` class is loaded on the page,
         * before starting the test. 
         *   
         * This option can (and probably should) be also specified in the test file descriptor. 
         */
        waitForExtComponentQueryReady       : true,
        
        
        // Set to true to fail t.knownBugInStatements, useful when running against Ext JS nightly builds
        failKnownBugIn          : false
    },
    
    
    override : {
        
        getNewTestConfiguration : function (desc, scopeProvider, contentManager, launchState) {
            var config              = this.SUPERARG(arguments)
            
            config.loaderPath       = this.getDescriptorConfig(desc, 'loaderPath')
            config.requires         = this.getDescriptorConfig(desc, 'requires')
            
            config.waitForExtComponentQueryReady = this.getDescriptorConfig(desc, 'waitForExtComponentQueryReady')
            
            return config
        },
        
        
        buildSandboxHashStructure : function () {
            var structure           = this.SUPERARG(arguments)
            
            structure.push('loaderPath', 'requires')
            
            return structure
        },
        
        
        buildHostPageUrlStopsInheriting : function () {
            var res         = this.SUPER()
            
            res.loaderPath  = true
            
            return res
        }
    },
    
    
    methods : {
        
        createViewport       : function(config) {
           return Ext.create("Siesta.Harness.Browser.UI.Viewport", config);
        },
        
            
        generateLoaderPathHook : function () {
            // Such tedious check to allow setting the paths without crash for Ext JS versions < 4
            // (which may have own "Ext.Loader" object)
            return function (StartTest, Ext, loaderPath) {
                if (!loaderPath || StartTest.loaderPathHookInstalled || !Ext || !Ext.Loader || !Ext.Loader.setPath) return
                
                StartTest.loaderPathHookInstalled   = true
                
                Ext.Loader.setPath(loaderPath)
            }
        },
        
        
        /**
         * Returns a string presentation of the ExtJS/SenchaTouch hook for setting "Ext.Loader" paths, 
         * suitable to be used in the test's {@link Siesta.Harness#preload preloads}. 
         * This will allow you to install the hook at the earliest possible point, 
         * right after preloading Ext and before "requiring" any classes. 
         * 
         * The value for the paths should be provided in the {@link #loaderPath} config. 
         * The inheritance of the value from groups is supported as usually, except the tests with 
         * {@link Siesta.Harness.Browser#pageUrl} option set.   
         * 
         * Typical usage will be:
         * 
    
    var harness = new Siesta.Harness.Browser.ExtJS();

    harness.configure({
        loaderPath              : { 'My' : 'js', 'My.Namespace' : 'js/somepath' },
        
        preload                 : [
            'http://cdn.sencha.io/ext-4.2.0-gpl/ext-all.js',
            {
                // inject the loader paths right after ExtJS and before the application file
                text    : harness.getLoaderPathHook()
            },
            'app.js'
        ]
    });

         * 
         * @return {String}
         */
        getLoaderPathHook : function () {
            var hook     = function (installationHook) {
                var parentWindow        = window.opener || window.parent
                var harness             = parentWindow.Siesta.my.activeHarness
                
                eval('(' + installationHook + ')')(StartTest, Ext, harness.getDescriptorConfig(harness.getScriptDescriptor(StartTest.id), "loaderPath"))
            }
            
            return ';(' + hook.toString() + ')(' + JSON.stringify(this.generateLoaderPathHook().toString()) + ')'
        }
    }
});
/**
@class Siesta.Harness.Browser.ExtJS
@extends Siesta.Harness.Browser 
@mixin Siesta.Harness.Browser.ExtJSCore

Class, representing the browser harness. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.ExtJS}, which inherits from 
{@link Siesta.Test.Browser} and contains various ExtJS-specific assertions. So, use this harness class, when testing an ExtJS application.

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

Synopsys
========

    var harness = new Siesta.Harness.Browser.ExtJS();
    
    harness.configure({
        title     : 'Awesome ExtJS Application Test Suite',
        
        transparentEx       : true,
        
        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],
        
        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })
    
    
    harness.start(
        // simple string - url relative to harness file
        'sanity.t.js',
        
        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',
            
            // replace `preload` option of harness
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },
        
        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',
            
            autoCheckGlobals    : false,
            
            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/

Class('Siesta.Harness.Browser.ExtJS', {
    
    isa     : Siesta.Harness.Browser,
    
    does    : [
        Siesta.Harness.Browser.ExtJSCore
    ],
    
    has     : {
        /**
         * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.ExtJS}.
         * You can subclass {@link Siesta.Test.ExtJS} and provide a new class. 
         * 
         * This option can be also specified in the test file descriptor. 
         */
        testClass               : Siesta.Test.ExtJS,
        
        /**
         * @cfg {Boolean} waitForExtReady
         * 
         * By default the `StartTest` function will be executed after `Ext.onReady`. Set to `false` to launch `StartTest` immediately.  
         * 
         * This option can be also specified in the test file descriptor. 
         */
        waitForExtReady         : true,
        
        /**
         * @cfg {Boolean} waitForAppReady
         * 
         * Setting this configuration option to "true" will cause Siesta to wait until the ExtJS MVC application on the test page will become ready,
         * before starting the test. More precisely it will wait till the first "launch" event from any instance of `Ext.app.Application` class on the page.
         *   
         * This option can (and probably should) be also specified in the test file descriptor. 
         */
        waitForAppReady         : false,
        

        extVersion              : null,

        /**
         * @cfg {Boolean} failOnMultipleComponentMatches
         *
         * True to fail when providing a Component Query matching multiple components. False to warn only.
         * Component Queries should ideally always be unique to identify only one target in the DOM.
         */
        failOnMultipleComponentMatches   : false,
        
        extVersionRegExp        : /ext(?:js)?-(\d\.\d+\.\d+.*?)\//,
        
        contentManagerClass     : Siesta.Content.Manager.Browser.ExtJSCore,

        // Required by Ext JS 6
        innerHtmlHead           : '<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">'
    },
    
    
    methods : {
        
        setup : function (callback) {
            var me      = this
            
            /*
                This is to be able to pass "next" function form the chain step to the Ext as callback:
                    function (next) {
                        resourceStore.reload({
                            callback : next
                        })
                    }
                For some reason, Ext performs "isFunction" check on the callback value and only calls it if this check passes
                (assuming programmer does not know what he is doing)
                "isFunction" check in turn relies on the presence of this property in the Function prototype
                
                This line can be removed once "isFunction" in Ext will become cross-context or Ext will stop
                using "isFunction" check for callbacks
            */
            Function.prototype.$extIsFunction = true;
            
            this.SUPER(function () {
                callback()
            })
        },
        
    
        getNewTestConfiguration : function (desc, scopeProvider, contentManager, launchState) {
            var config          = this.SUPERARG(arguments)
            
            config.waitForExtReady  = this.getDescriptorConfig(desc, 'waitForExtReady')
            config.waitForAppReady  = this.getDescriptorConfig(desc, 'waitForAppReady')
            
            return config
        },
        
        
        findExtVersion : function () {
            var me      = this
            
            var found
            
            this.mainPreset.eachResource(function (resource) {
                var match   = me.extVersionRegExp.exec(resource.url)
                
                if (match) {
                    found   = match[ 1 ]
                    
                    return false
                }
            })
            
            return found
        }
    }
});
/**
@class Siesta.Harness.Browser.SenchaTouch
@extends Siesta.Harness.Browser 
@mixin Siesta.Harness.Browser.ExtJSCore

A Class representing the browser harness. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.SenchaTouch}, which inherits from 
{@link Siesta.Test.Browser} and contains various Sencha Touch-specific assertions. Use this harness class when testing Sencha Touch applications.

* **Note** Make sure, you've checked the {@link #performSetup} configuration option. 

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

Synopsys
========

    var harness = new Siesta.Harness.Browser.SenchaTouch();
        
    harness.configure({
        title           : 'Awesome Sencha Touch Application Test Suite',
                
        transparentEx   : true,
                
        preload         : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js"
        ]
    })
        
        
    harness.start(
        // simple string - url relative to harness file
        'sanity.t.js',
                
        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',
                        
            // replace `preload` option of harness
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },
                
        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',
                        
            autoCheckGlobals    : false,
                        
            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/

Class('Siesta.Harness.Browser.SenchaTouch', {

    isa: Siesta.Harness.Browser,

    does    : [
        Siesta.Harness.Browser.ExtJSCore
    ],
    
    has     : {
        /**
        * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.SenchaTouch}.
        * You can subclass {@link Siesta.Test.SenchaTouch} and provide a new class. 
        * 
        * This option can be also specified in the test file descriptor. 
        */
        testClass           : Siesta.Test.SenchaTouch,

        /**
         * @cfg {Boolean} transparentEx
         */
        transparentEx       : true,
        keepNLastResults    : 0,
        
        /**
         * @cfg {Boolean} performSetup When set to `true`, Siesta will perform a `Ext.setup()` call, so you can safely assume there's a viewport for example.
         * If, however your test code, performs `Ext.setup()` itself, you need to disable this option.
         * 
         * If this option is not explicitly specified in the test descritor, but instead inherited, it will be automatically disabled if test has {@link #pageUrl} value.
         * 
         * This option can be also specified in the test file descriptor.
         */
        performSetup        : true,
        
        forcedRunCore       : 'sequential',

        isRunningOnMobile   : true,
        
        contentManagerClass : Siesta.Content.Manager.Browser.ExtJSCore
    },


    methods: {
        
        setup : function () {
            // TODO fix proper mobile detection, since Ext may be absent in "no-ui" harness
            this.isRunningOnMobile = typeof Ext !== 'undefined' && Ext.getVersion && Ext.getVersion('touch')
            
            if (!this.isRunningOnMobile) this.keepNLastResults = 2
            
            this.SUPERARG(arguments)
        },


        getNewTestConfiguration: function (desc, scopeProvider, contentManager, launchState) {
            var config      = this.SUPERARG(arguments)
            var pageUrl     = this.getDescriptorConfig(desc, 'pageUrl');
            
            if (!desc.hasOwnProperty('performSetup') && pageUrl) {
                config.performSetup = false;
            } else {
                config.performSetup = this.getDescriptorConfig(desc, 'performSetup')
            }
            
            return config
        }
    }
})


;
;
Siesta.CurrentLocale = Siesta.CurrentLocale || {

    "Siesta.Harness" : {
        preloadHasFailed            : 'Preload of {url} has failed',
        preloadHasFailedForTest     : 'Preload of {url} has failed for test {test}',
        staticDeprecationWarning    : 'You are calling static method `{methodName}` of the harness class {harnessClass}. Such usage is deprecated now, please switch to creation of the harness class instance: `var harness = new {harnessClass}()`',
        resourceFailedToLoad        : 'Loading of a {nodeName} resource failed'
    },
    
    "Siesta.Harness.Browser.UI.AboutWindow" : {

        upgradeText : 'Upgrade to Siesta Standard',
        closeText   : 'Close',
        titleText   : 'ABOUT SIESTA (v. {VERSION})',

        bodyText    : '<img height="35" src="http://www.bryntum.com/bryntum-logo.png"/>\
             <p>Siesta is a JavaScript unit and functional test tool made by <a target="_blank" href="http://www.bryntum.com">Bryntum</a>. You can test any web page or JavaScript code, including Ext JS, jQuery or NodeJS. \
             Siesta comes in two versions: <strong>Lite</strong> and <strong>Standard</strong>. With Lite, you can launch your tests in the browser UI. \
             With the Standard version, you can also automate your tests and use the automation scripts together with tools like PhantomJS or Selenium WebDriver. </p>\
             Siesta would not be possible without these awesome products & libraries: <br>\
                     <ul style="padding:0 0 0 30px">\
                       <li><a href="http://sencha.com/extjs">Ext JS</a></li> \
                       <li><a href="http://jquery.com">jQuery</a></li> \
                       <li><a href="http://http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></li> \
                       <li><a href="http://joose.it/">Joose</a></li> \
                       <li><a href="https://github.com/gotwarlost/istanbul">Istanbul</a></li> \
                    </ul>'
    },

    "Siesta.Harness.Browser.UI.AssertionGrid" : {
        initializingText    : 'Initializing test...'
    },

    "Siesta.Harness.Browser.UI.CoverageReport" : {
        closeText               : 'Close',
        showText                : 'Show: ',
        lowText                 : 'Low',
        mediumText              : 'Med',
        highText                : 'High',
        statementsText          : 'Statements',
        branchesText            : 'Branches',
        functionsText           : 'Functions',
        linesText               : 'Lines',
        loadingText             : "Loading coverage data...",
        loadingErrorText        : 'Loading error',
        loadingErrorMessageText : 'Could not load the report data from this url: ',
        globalNamespaceText     : '[Global namespace]'
    },

    "Siesta.Harness.Browser.UI.DomContainer" : {
        title                   : 'DOM Panel',
        viewDocsText            : 'View documentation for ',
        docsUrlText             : 'http://docs.sencha.com/{0}/apidocs/#!/api/{1}'
    },

    "Siesta.Harness.Browser.UI.ResultPanel" : {
        rerunText               : 'Run test',
        toggleDomVisibleText    : 'Toggle DOM visible',
        viewSourceText          : 'View source',
        showFailedOnlyText      : 'Show failed only',
        componentInspectorText  : 'Toggle Ext Component Inspector',
        eventRecorderText       : 'Event Recorder',
        closeText               : 'Close'
    },

    "Siesta.Harness.Browser.UI.TestGrid" : {
        title                   : 'Test list',
        nameText                : 'Name',
        filterTestsText         : 'Filter tests',
        expandCollapseAllText   : 'Expand / Collapse all',
        runCheckedText          : 'Run checked',
        runFailedText           : 'Run failed',
        runAllText              : 'Run all',
        showCoverageReportText  : 'Show coverage report',
        passText                : 'Pass',
        failText                : 'Fail',
        optionsText             : 'Options...',
        todoPassedText          : 'todo assertion(s) passed',
        todoFailedText          : 'todo assertion(s) failed',
        viewDomText             : 'View DOM',
        transparentExText       : 'Transparent exceptions',
        cachePreloadsText       : 'Cache preloads',
        autoLaunchText          : 'Auto launch',
        speedRunText            : 'Speed run',
        breakOnFailText         : 'Break on fail',
        debuggerOnFailText      : 'Debugger on fail',
        aboutText               : 'About Siesta',
        documentationText       : 'Siesta Documentation',
        siestaDocsUrl           : 'http://bryntum.com/docs/siesta',
        filterFieldTooltip      : 'Supported formats for tests filtering:\n1) TERM1 TERM2 - both "TERM1" and "TERM2" should present in the test url\n' +
            '2) TERM1 TERM2 | TERM3 TERM4 | ... - both "TERM1" and "TERM2" should present in the test url, OR both TERM3 and TERM4, etc, can be ' +
            'repeated indefinitely\n' +
            '3) GROUP_TERM > TEST_TERM - filters only withing the specified `group`',
        landscape               : 'Landscape'
    },

    "Siesta.Harness.Browser.UI.VersionUpdateButton" : {

        newUpdateText           : 'New Update Available...',
        updateWindowTitleText   : 'New version available for download! Current version: ',
        cancelText              : 'Cancel',
        changelogLoadFailedText : 'Bummer! Failed to fetch changelog.',
        downloadText            : 'Download ',
        liteText                : ' (Lite)',
        standardText            : ' (Standard)',
        loadingChangelogText    : 'Loading changelog...'
    },

    "Siesta.Harness.Browser.UI.Viewport" : {
        apiLinkText       : 'API Documentation',
        apiLinkUrl        : 'http://bryntum.com/docs/siesta',
        uncheckOthersText : 'Uncheck others (and check this)',
        uncheckAllText    : 'Uncheck all',
        checkAllText      : 'Check all',
        runThisText       : 'Run this',
        expandAll           : 'Expand all',
        collapseAll         : 'Collapse all',
        filterToCurrentGroup    : 'Filter to current group',
        filterToFailed          : 'Filter to failed',
        httpWarningTitle  : 'You must use a web server',
        httpWarningDesc   : 'You must run Siesta in a web server context, and not using the file:/// protocol',
        viewSource        : 'View source'
    },


    "Siesta.Harness.Browser" : {
        codeCoverageWarningText : "Can not enable code coverage - did you forget to include the `siesta-coverage-all.js` on the harness page?",
        noJasmine               : "No `jasmine` object found on spec runner page",
        noJasmineSiestaReporter : "Can't find SiestaReporter in Jasmine. \nDid you add the `siesta/bin/jasmine-siesta-reporter.js` file to your spec runner page?"
    },

    "Siesta.Result.Assertion" : {
        todoText        : 'TODO: ',
        passText        : 'ok',
        failText        : 'fail'
    },

    "Siesta.Role.ConsoleReporter" : {
        passText            : 'PASS',
        failText            : 'FAIL',
        warnText            : 'WARN',
        errorText           : 'ERROR',
        missingFileText     : 'Test file [{URL}] not found.',
        allTestsPassedText  : 'All tests passed',
        failuresFoundText   : 'There are failures'
    },

    "Siesta.Test.Action.Drag" : {
        byOrToMissingText   : 'Either "to" or "by" configuration option is required for "drag" step',
        byAndToDefinedText  : 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
    },

    "Siesta.Test.Action.Eval" : {
        invalidMethodNameText : "Invalid method name: ",
        wrongFormatText       : "Wrong format of the action string: ",
        parseErrorText        : "Can't parse arguments: "
    },

    "Siesta.Test.Action.Wait" : {
        missingMethodText     : 'Could not find a waitFor method named '
    },

    "Siesta.Test.BDD.Expectation" : {
        expectText                  : 'Expect',
        needNotText                 : 'Need not',
        needText                    : 'Need',
        needMatchingText            : 'Need matching',
        needNotMatchingText         : 'Need not matching',
        needStringNotContainingText : 'Need string not containing',
        needStringContainingText    : 'Need string containing',
        needArrayNotContainingText  : 'Need array not containing',
        needArrayContainingText     : 'Need array containing',
        needGreaterEqualThanText    : 'Need value greater or equal than',
        needGreaterThanText         : 'Need value greater than',
        needLessThanText            : 'Need value less than',
        needLessEqualThanText       : 'Need value less or equal than',
        needValueNotCloseToText     : 'Need value not close to',
        needValueCloseToText        : 'Need value close to',
        toBeText                    : 'to be',
        toBeDefinedText             : 'to be defined',
        toBeUndefinedText           : 'to be undefined',
        toBeEqualToText             : 'to be equal to',
        toBeTruthyText              : 'to be truthy',
        toBeFalsyText               : 'to be falsy',
        toMatchText                 : 'to match',
        toContainText               : 'to contain',
        toBeLessThanText            : 'to be less than',
        toBeGreaterThanText         : 'to be greater than',
        toBeCloseToText             : 'to be close to',
        toThrowText                 : 'to throw exception',
        thresholdIsText             : 'Threshold is ',
        exactMatchText              : 'Exact match text',
        thrownExceptionText         : 'Thrown exception',
        noExceptionThrownText       : 'No exception thrown',
        wrongSpy                    : 'Incorrect spy instance',
        toHaveBeenCalledDescTpl     : 'Expect method {methodName} to have been called {need} times',
        actualNbrOfCalls            : 'Actual number of calls',
        expectedNbrOfCalls          : 'Expected number of calls',
        toHaveBeenCalledWithDescTpl : 'Expect method {methodName} to have been called at least once with the specified arguments'
    },

    "Siesta.Test.ExtJS.Ajax"        : {
        ajaxIsLoading               : 'An Ajax call is currently loading',
        allAjaxRequestsToComplete   : 'all ajax requests to complete',
        ajaxRequest                 : 'ajax request',
        toComplete                  : 'to complete'
    },

    "Siesta.Test.ExtJS.Component"   : {
        badInputText                : 'Expected an Ext.Component, got',
        toBeVisible                 : 'to be visible',
        toNotBeVisible              : 'to not be visible',
        component                   : 'component',
        Component                   : 'Component',
        componentQuery              : 'componentQuery',
        compositeQuery              : 'composite query',
        toReturnEmptyArray          : 'to return an empty array',
        toReturnEmpty               : 'to return empty',
        toReturnAVisibleComponent   : 'to return a visible component',
        toReturnHiddenCmp           : 'to return a hidden/missing component',
        invalidDestroysOkInput      : 'No components provided, or component query returned empty result',
        exception                   : 'Exception',
        exceptionAnnotation         : 'Exception thrown while calling "destroy" method of',
        destroyFailed               : 'was not destroyed (probably destroy was canceled in the `beforedestroy` listener)',
        destroyPassed               : 'All passed components were destroyed ok'
    },

    "Siesta.Test.ExtJS.DataView"    : {
        view                        : 'view',
        toRender                    : 'to render'
    },

    "Siesta.Test.ExtJS.Element"     : {
        top                         : 'top',
        left                        : 'left',
        bottom                      : 'bottom',
        right                       : 'right'
    },

    "Siesta.Test.ExtJS.Grid"     : {
        waitForRowsVisible          : 'rows to show for panel with id',
        waitForCellEmpty            : 'cell to be empty'
    },

    "Siesta.Test.ExtJS.Observable" : {
        hasListenerInvalid           : '1st argument for `t.hasListener` should be an observable instance',
        hasListenerPass              : 'Observable has listener for {eventName}',
        hasListenerFail              : 'Provided observable has no listeners for event',

        isFiredWithSignatureNotFired : 'event was not fired during the test"',
        observableFired              : 'Observable fired',
        correctSignature             : 'with correct signature',
        incorrectSignature           : 'with incorrect signature'
    },

    "Siesta.Test.ExtJS.Store"        : {
        storesToLoad                 : 'stores to load',
        failedToLoadStore            : 'Failed to load the store',
        URL                          : 'URL'
    },

    "Siesta.Test.Action"             : {
        missingTestAction            : 'Action [{0}] requires `{1}` method in your test class'
    },

    "Siesta.Test.BDD"                : {
        codeBodyMissing              : 'Code body is not provided for',
        codeBodyOf                   : 'Code body of',
        missingFirstArg              : 'does not declare a test instance as 1st argument',
        iitFound                     : 't.iit should only be used during debugging',
        noObject                     : 'No object to spy on'
    },

    "Siesta.Test.BDD.Spy"                : {
        spyingNotOnFunction          : 'Trying to create a spy over a non-function property'
    },
    
    "Siesta.Test.Browser"            : {
        popupsDisabled                  : 'Failed to open the popup for url: {url}. Enable the popups in the browser settings.',
        noDomElementFound            : 'No DOM element found for CSS selector',
        noActionTargetFound          : 'No action target found for',
        waitForEvent                 : 'observable to fire its',
        event                        : 'event',
        wrongFormat                  : 'Wrong format for expected number of events',
        unrecognizedSignature        : 'Unrecognized signature for `firesOk`',
        observableFired              : 'Observable fired',
        observableFiredOk            : 'Observable fired expected number of',
        actualNbrEvents              : 'Actual number of events',
        expectedNbrEvents            : 'Expected number of events',
        events                       : 'events',
        noElementFound               : 'Could not find any element at',
        targetElementOfAction        : 'Target element of action',
        targetElementOfSomeAction    : 'Target element of some action',
        isNotVisible                 : 'is not visible or not reachable',
        text                         : 'text',
        toBePresent                  : 'to be present',
        toNotBePresent               : 'to not be present',
        target                       : 'target',
        toAppear                     : 'to appear',
        targetMoved                  : 'Moving target detected, retargeting initiated',
        alertMethodNotCalled         : 'Expected a call to alert()',
        focusLostWarning             : 'Focus has left the test window {url}',
        focusLostWarningLauncher     : 'Focus has left the test window {url}, it will be restarted. This behavior is controled with the --restart-on-blur option.'
    },

    "Siesta.Test.Date"               :  {
        isEqualTo                    : 'is equal to',
        Got                          : 'Got'
    },

    "Siesta.Test.Element"            : {
        elementContent               : 'element content',
        toAppear                     : 'to appear',
        toDisappear                  : 'to disappear',
        toAppearAt                   : 'to appear at',
        monkeyException              : 'Monkey testing action did not complete properly - probably an exception was thrown',
        monkeyNoExceptions           : 'No exceptions thrown during monkey test',
        monkeyActionLog              : 'Monkey action log',
        elementHasClass              : 'Element has the CSS class',
        elementHasNoClass            : 'Element has no CSS class',
        elementClasses               : 'Classes of element',
        needClass                    : 'Need CSS class',

        hasStyleDescTpl              : 'Element has correct {value} for CSS style {property}',
        elementStyles                : 'Styles of element',
        needStyle                    : 'Need style',

        hasNotStyleDescTpl           : 'Element does not have: {value} for CSS style {property}',
        hasTheStyle                  : 'Element has the style',

        element                      : 'element',
        toBeTopEl                    : 'to be the top element at its position',
        toNotBeTopEl                 : 'to not be the top element at its position',

        selector                     : 'selector',
        selectors                    : 'selectors',
        noCssSelector                : 'A CSS selector must be supplied',

        waitForSelectorsBadInput     : 'An array of CSS selectors must be supplied',

        Position                     : 'Position',
        noElementAtPosition          : 'No element found at the specified position',
        elementIsAtDescTpl           : 'DOM element or its child is at [ {x}, {y} ] coordinates',
        topElement                   : 'Top element',
        elementIsAtPassTpl           : 'DOM element is at [ {x}, {y} ] coordinates',
        allowChildrenDesc            : 'Need exactly this or its child',
        allowChildrenAnnotation      : 'Passed element is not the top-most one and not the child of one',
        shouldBe                     : 'Should be',
        noChildrenFailAnnotation     : 'Passed element is not the top-most one',

        topLeft                      : '(t-l)',
        bottomLeft                   : '(b-l)',
        topRight                     : '(t-r)',
        bottomRight                  : '(b-r)',

        elementIsNotTopElementPassTpl: 'Element is not the top element on the screen',
        selectorIsAtPassTpl          : 'Found element matching CSS selector {selector} at [ {xy} ]',
        elementMatching              : 'Element matching',
        selectorIsAtFailAnnotation   : 'Passed selector does not match any selector at',
        selectorExistsFailTpl        : 'No element matching the passed selector found',
        selectorExistsPassTpl        : 'Found DOM element(s) matching CSS selector {selector}',

        selectorNotExistsFailTpl     : 'Elements found matching the passed selector',
        selectorNotExistsPassTpl     : 'Did not find any DOM element(s) matching CSS selector {selector}',

        toChangeForElement           : 'to change for element',

        selectorCountIsPassTpl       : 'Found exactly {count} elements matching {selector}',
        selectorCountIsFailTpl       : 'Found {got} elements matching the selector {selector}, expected {need}',
        isInViewPassTpl              : 'Passed element is within the visible viewport',

        toAppearInTheViewport        : 'to appear in the viewport',

        elementIsEmptyPassTpl        : 'Passed element is empty',
        elementIsNotEmptyPassTpl     : 'Passed element is not empty',
        elementToBeEmpty             : 'element to be empty',
        elementToNotBeEmpty          : 'element to not be empty'
    },

    "Siesta.Test.ExtJS"              : {
        bundleUrlNotFound                   : 'Cannot find Ext JS bundle url',
        assertNoGlobalExtOverridesInvalid   : 'Was not able to find the Ext JS bundle URL in the `assertNoGlobalExtOverrides` assertion',
        assertNoGlobalExtOverridesPassTpl   : 'No global Ext overrides found',
        assertNoGlobalExtOverridesGotDesc   : 'Number of overrides found',
        foundOverridesFor                   : 'Found overrides for',
        animationsToFinalize                : 'animations to finalize',
        extOverridesInvalid                 : 'Was not able to find the ExtJS bundle URL in the `assertMaxNumberOfGlobalExtOverrides` assertion)',
        foundLessOrEqualThan                : 'Found less or equal than',
        nbrOverridesFound                   : 'Number of overrides found',
        globalOverrides                     : 'Ext JS global overrides'
    },

    "Siesta.Test.ExtJSCore"          : {
        waitedForRequires           : 'Waiting for required classes took too long - \nCheck the `Net` tab in Firebug and the `loaderPath` config',
        waitedForExt                 : 'Waiting for Ext.onReady took too long - probably some dependency could not be loaded. \nCheck the `Net` tab in Firebug and the `loaderPath` config',
        waitedForApp                 : 'Waiting for MVC application launch took too long - no MVC application on test page? \nYou may need to disable the `waitForAppReady` config option',
        noComponentMatch             : 'Your component query: "{component}" returned no components',
        multipleComponentMatch       : 'Your component query: "{component}" returned more than 1 component',
        noComponentFound             : 'No component found for CQ',
        knownBugIn                   : 'Known bug in',
        Class                        : 'Class',
        wasLoaded                    : 'was loaded',
        wasNotLoaded                 : 'was not loaded',
        invalidCompositeQuery        : 'Invalid composite query selector',
        ComponentQuery               : 'ComponentQuery',
        CompositeQuery               : 'CompositeQuery',
        matchedNoCmp                 : 'matched no Ext.Component',
        messageBoxVisible            : 'Message box is visible',
        messageBoxHidden             : 'Message box is hidden',
        waitedForComponentQuery      : 'Waiting too long for Ext.ComponentQuery'
    },

    "Siesta.Test.Function"           : {
        Need                         : 'need',
        atLeast                      : 'at least',
        exactly                      : 'exactly',
        methodCalledExactly          : 'method was called exactly {n} times',
        exceptionEvalutingClass      : 'Exception [{e}] caught while evaluating the class name'
    },

    "Siesta.Test.More"               : {
        isGreaterPassTpl             : '`{value1}` is greater than `{value2}`',
        isLessPassTpl                : '`{value1}` is less than `{value2}`',
        isGreaterEqualPassTpl        : '`{value1}` is greater or equal to`{value2}`',
        isLessEqualPassTpl           : '`{value1}` is less or equal to`{value2}`',
        isApproxToPassTpl            : '`{value1}` is approximately equal to `{value2}`',

        needGreaterThan              : 'Need greater than',
        needGreaterEqualTo           : 'Need greater or equal to',
        needLessThan                 : 'Need less than',
        needLessEqualTo              : 'Need less or equal to',

        exactMatch                   : 'Exact match',
        withinThreshold              : 'Match within treshhold',
        needApprox                   : 'Need approx',
        thresholdIs                  : 'Threshold is',

        stringMatchesRe              : '`{string}` matches regexp {regex}',
        stringNotMatchesRe           : '`{string}` does not match regexp {regex}',
        needStringMatching           : 'Need string matching',
        needStringNotMatching        : 'Need string not matching',
        needStringContaining         : 'Need string containing',
        needStringNotContaining      : 'Need string not containing',
        stringHasSubstring           : '`{string}` has a substring: `{regex}`',
        stringHasNoSubstring         : '`{string}` does not have a substring: `{regex}`',

        throwsOkInvalid              : 'throws_ok accepts a function as 1st argument',
        didntThrow                   : 'Function did not throw an exception',
        exMatchesRe                  : 'Function throws exception matching to {expected}',
        exceptionStringifiesTo       : 'Exception stringifies to',
        exContainsSubstring          : 'Function throws exception containing a substring: {expected}',

        fnDoesntThrow                : 'Function does not throw any exceptions',
        fnThrew                      : 'Function threw an exception',

        isInstanceOfPass             : 'Object is an instance of the specified class',
        needInstanceOf               : 'Need instance of',
        isAString                    : '{value} is a string',
        aStringValue                 : 'AStringValue',
        isAnObject                   : '{value} is an object',
        anObject                     : 'An object value',
        isAnArray                    : '{value} is an array',
        anArrayValue                 : 'An array value',
        isANumber                    : '{value} is a number',
        aNumberValue                 : 'a number value',
        isABoolean                   : '{value} is a boolean',
        aBooleanValue                : 'a number value',
        isADate                      : '{value} is a date',
        aDateValue                   : 'a date value',
        isARe                        : '{value} is a regular expression',
        aReValue                     : 'a regular expression',
        isAFunction                  : '{value} is a function',
        aFunctionValue               : 'a function',
        isDeeplyPassTpl              : '{obj1} is deeply equal to {obj2}',
        isDeeplyStrictPassTpl        : '{obj1} is strictly deeply equal to {obj2}',
        globalCheckNotSupported      : 'Testing leakage of global variables is not supported on this platform',
        globalVariables              : 'Global Variables',
        noGlobalsFound               : 'No unexpected global variables found',
        globalFound                  : 'Unexpected global found',
        globalName                   : 'Global name',
        value                        : 'value',

        conditionToBeFulfilled       : 'condition to be fulfilled',
        pageToLoad                   : 'page to load',
        ms                           : 'ms',
        waitingFor                   : 'Waiting for',
        waitedTooLong                : 'Waited too long for',
        conditionNotFulfilled        : 'Condition was not fullfilled during',
        waitingAborted               : 'Waiting aborted',
        Waited                       : 'Waited',
        checkerException             : 'checker threw an exception',
        Exception                    : 'Exception',
        msFor                        : 'ms for',
        forcedWaitFinalization       : 'Forced finalization of waiting for',
        chainStepNotCompleted        : 'The step in `t.chain()` call did not complete within required timeframe, chain can not proceed',
        stepNumber                   : 'Step number',
        oneBased                     : '(1-based)',
        atLine                       : 'At line',
        chainStepEx                  : 'Chain step threw an exception',
        stepFn                       : 'Step function',
        notUsingNext                 : 'does not use the provided "next" function anywhere',
        calledMoreThanOnce           : 'The `next` callback of {num} step (1-based) of `t.chain()` call at line {line} is called more than once.',
        tooManyDifferences           : 'Showing {num} of {total} differences'
    },


    "Siesta.Test.SenchaTouch"               : {
        STSetupFailed                       : 'Waiting for Ext.setup took too long - some dependency could not be loaded? Check the `Net` tab in Firebug',
        invalidSwipeDir                     : 'Invalid swipe direction',
        moveFingerByInvalidInput            : 'Trying to call moveFingerBy without relative distances',
        scrollUntilFailed                   : 'scrollUntil failed to achieve its mission',
        scrollUntilElementVisibleInvalid    : 'scrollUntilElementVisible: target or scrollable not provided',
        scrollerReachPos                    : 'scroller to reach position'
    },

    "Siesta.Test"                           : {
        noCodeProvidedToTest                : 'No code provided to test',
        addingAssertionsAfterDone           : 'Adding assertions after the test has finished',
        testFailedAndAborted                : 'Assertion failed, test execution aborted',
        atLine                              : 'at line',
        of                                  : 'of',
        character                           : 'character',
        isTruthy                            : '`{value}` is a "truthy" value',
        needTruthy                          : 'Need "truthy" value',
        isFalsy                             : '`{value}` is a "falsy" value',
        needFalsy                           : 'Need "falsy" value',
        isEqualTo                           : '`{got}` is equal to `{expected}`',
        isNotEqualTo                        : '`{got}` is not equal to `{expected}`',
        needNot                             : 'Need not',
        isStrictlyEqual                     : '`{got}` is strictly equal to `{expected}`',
        needStrictly                        : 'Need strictly',
        isStrictlyNotEqual                  : '`{got}` is strictly not equal to `{expected}`',
        needStrictlyNot                     : 'Need strictly not',
        alreadyWaiting                      : 'Already waiting with title',
        noOngoingWait                       : 'There is no ongoing `wait` action with title',
        noMatchingEndAsync                  : 'No matching `endAsync` call within',
        endAsyncMisuse                      : 'Calls to endAsync without argument should only be performed if you have single beginAsync statement',
        codeBodyMissingForSubTest           : 'Code body is not provided for sub test',
        codeBodyMissingTestArg              : 'Code body of sub test [{name}] does not declare a test instance as 1st argument',
        Subtest                             : 'Subtest',
        Test                                : 'Test',
        failedToFinishWithin                : 'failed to finish within',
        threwException                      : 'threw an exception',
        testAlreadyStarted                  : 'Test has already been started',
        setupTookTooLong                    : '`setup` method took too long to complete',
        errorBeforeTestStarted              : 'Error happened before the test started',
        testStillRunning                    : 'Your test is still considered to be running, if this is unexpected please see console for more information',
        testNotFinalized                    : 'Your test [{url}] has not finalized, most likely since a timer (setTimeout) is still active. ' +
                                              'If this is the expected behavior, try setting "overrideSetTimeout : false" on your Harness configuration.',
        missingDoneCall                     : 'Test has completed, but there was no `t.done()` call. Add it at the bottom, or use `t.beginAsync()` for asynchronous code',
        allTestsPassed                      : 'All tests passed',
        
        'Snoozed until'                     : 'Snoozed until',
        testTearDownTimeout                 : "Test's tear down process has timeout out"
    },

    "Siesta.Recorder.UI.Editor.Code"           : {
        invalidSyntax                       : 'Invalid syntax'
    },

    "Siesta.Recorder.UI.Editor.DragTarget"     : {
        targetLabel                         : 'Target',
        toLabel                             : 'To',
        byLabel                             : 'By',
        cancelButtonText                    : 'Cancel',
        saveButtonText                      : 'Save',
        
        dragVariantTitle                    : 'Edit `drag` action',
        moveCursorVariantTitle              : 'Edit `moveCursor` action'
    },

    "Siesta.Recorder.UI.RecorderPanel"      : {
        actionColumnHeader                  : 'Action',
        offsetColumnHeader                  : 'Offset',
        queryMatchesNothing                 : 'Query matches no DOM elements or components',
        queryMatchesMultiple                : 'Query matches multiple components',
        noVisibleElsFound                   : 'No visible elements found for target',
        noTestDetected                      : 'No test detected',
        noTestStarted                       : 'You need to run a test first, or provide a Page URL',
        recordTooltip                       : 'Record',
        stopTooltip                         : 'Stop',
        playTooltip                         : 'Play',
        clearTooltip                        : 'Clear all',
        codeWindowTitle                     : 'Code',
        addNewTooltip                       : 'Add a new step',
        removeAllPromptTitle                : 'Remove all?',
        removeAllPromptMessage              : 'Do you want to clear the recorded events?',
        Error                               : 'Error',
        showSource                          : 'Show source',
        showSourceInNewWindow               : 'Show source in new window',
        newRecording                        : 'New recording...',
        pageUrl                             : 'Page URL'
    },

    "Siesta.Recorder.UI.TargetColumn"       : {
        headerText                          : 'Target / Value',
        by                                  : 'by',
        to                                  : 'to',
        coordinateTargetWarning             : 'Siesta was unable to find a stable selector for this target. Using coordinates as locator is not recommended.'
    }
};

;
// Localization helper
Siesta.Resource = (function () {
    
    var cacheByNamespace    = {}
    
    var Resource    = Class({
        does    : Siesta.Util.Role.CanFormatStrings,
        
        has     : {
            dict        : null
        },
        
        methods : {
            'get' : function (key, data) {
                var text = this.dict[ key ];
        
                if (text) return this.formatString(text, data);
        
                if (window.console && console.error) {
                    window.top.console.error('TEXT_NOT_DEFINED: ' + key);
                }
        
                return 'TEXT_NOT_DEFINED: ' + key;
            }
        }
    
    })
    

    return function (namespace, key, data) {
        var dictionary  = Siesta.CurrentLocale[ namespace ];

        if (!dictionary) {
            throw 'Missing dictionary for namespace: ' + namespace;
        }
        
        var resource    = cacheByNamespace[ namespace ]
        
        if (!resource) {
            resource    = cacheByNamespace[ namespace ] = new Resource({ dict : dictionary, serializeFormatingPlaceholders : false })
        }

        if (key) return resource.get(key, data)

        return resource
    }
})();
;
Class('Siesta.Recorder.Target', {
    
    has : {
        targets             : Joose.I.Array,
        activeTarget        : null
    },
    
    
    methods : {
        
        initialize : function () {
            if (!this.targets) this.targets = []
            
            var firstTarget     = this.targets[ 0 ]
            
            if (firstTarget && !this.activeTarget) this.activeTarget = firstTarget.type
        },
        
        
        clear : function () {
            this.targets = []
        },
        
        
        getTargets : function () {
            var target      = this.getTarget()
            
            return target && target.targets || null
        },
        
        
        // `getActiveTarget`
        getTarget : function () {
            return this.getTargetByType(this.activeTarget)
        },
        
        
        clearOffset : function () {
            this.setOffset(null)
        },
    
    
        setOffset : function (value) {
            var target                  = this.getTarget()
            
            if (target) 
                if (value) 
                    target.offset   = value
                else
                    delete target.offset
        },
    
    
        getOffset : function () {
            var target                  = this.getTarget()
            
            if (target) return target.offset
        },
        
        
        getTargetByType : function (type) {
            var targetByType
            
            Joose.A.each(this.targets, function (target) {
                if (target.type == type) { 
                    targetByType = target
                    return false
                }
            })
            
            return targetByType
        },
        
        
        setUserTarget : function (value, offset) {
            var userTarget          = this.getTargetByType('user')
            
            if (!userTarget) {
                var target          = { type : 'user', target : value }
                
                if (offset) target.offset   = offset
                
                this.targets.unshift(target)
            } else {
                userTarget.target   = value
                
                if (offset)
                    userTarget.offset   = offset
                else
                    delete userTarget.offset
            }
            
            this.activeTarget       = 'user'
        },
        
        
        // returns `true` if targeting the coordinates on the screen or <body> (which is the same thing)
        isTooGeneric : function () {
            var targets     = this.targets
            
            if (!targets || targets.length === 0) return true
            
            if (targets.length === 1 && targets[ 0 ].type == 'xy') return true
            
            if (targets.length === 2) {
                var xy      = this.getTargetByType('xy')
                var css     = this.getTargetByType('css')
                
                if (xy && css && css.target == 'body') return true
            }
            
            return false
        }
    }
});;
!function () {
    
var ID      = 1

Class('Siesta.Recorder.Event', {
    
    has : {
        id                  : function () { return ID++ },

        type                : null,

        timestamp           : null,

        // Alt, ctrl, meta, shift keys
        options             : null,
        
        x                   : null,
        y                   : null,
        
        target              : null,
        
        charCode            : null,
        keyCode             : null,
        
        button              : null
    },
    
    
    methods : {
    },
    
    
    my : {
        has : {
            ID              : 1,
            HOST            : null,
            isFirefox       : /firefox/i.test(navigator.userAgent)
        },
        
        methods : {
            
            fromDomEvent : function (e) {
                var options     = {}

                ;[ 'altKey', 'ctrlKey', 'metaKey', 'shiftKey' ].forEach(function (id) {
                    if (e[ id ]) options[ id ] = true;
                });
                
                var config          = {
                    type            : e.type,
                    target          : e.target,
                    timestamp       : Date.now && Date.now() || e.timeStamp, // Firefox / Chrome doesn't have stable timeStamp implementation https://bugzilla.mozilla.org/show_bug.cgi?id=1186218
                                                  // https://googlechrome.github.io/samples/event-timestamp/index.html
                    options         : options
                }
                
                if (e.type.match(/^key/)) {
                    config.charCode = e.charCode || e.keyCode;
                    config.keyCode  = e.keyCode;
                } else {
                    // Overcomplicated due to IE9
                    var bodyEl      = e.target && e.target.ownerDocument && e.target.ownerDocument.body;
                    var docEl       = e.target && e.target.ownerDocument.documentElement;
                                                            //Chrome              Firefox
                    var pageX       = bodyEl ? e.clientX + (bodyEl.scrollLeft || docEl.scrollLeft): e.pageX;
                    var pageY       = bodyEl ? e.clientY + (bodyEl.scrollTop || docEl.scrollTop): e.pageY;

                    config.x        = pageX;
                    config.y        = pageY;
    
                    config.button   = e.button;
                }
                
                return new this.HOST(config)
            }
        }
    }

});

}();;
!function () {
    
var ID      = 1

Class('Siesta.Recorder.Action', {
    
    has : {
        id                  : function () { return ID++ },
        action              : null,
        
        value               : null,
        
        /*
            Possible type of targets:
            - 'xy'      XY coordinates
            - 'css'     css selector
            - 'cq'      component query
            - 'csq'     composite query
            - 'user'    user-provided text
        */
        target              : null,
        
        toTarget            : null,
        by                  : null,
        waitForPageLoad     : false,
        options             : null,
        
        sourceEvent         : null
    },
    
    
    methods : {
        
        initialize : function () {
            var target      = this.target

            if (target && !(target instanceof Siesta.Recorder.Target)) {
                this.target = new Siesta.Recorder.Target({ targets : target })
            }
            
            var toTarget    = this.toTarget
            
            if (toTarget && !(toTarget instanceof Siesta.Recorder.Target)) 
                this.toTarget = new Siesta.Recorder.Target({ targets : toTarget })
        },
        
        
        setAction : function (newAction) {
            this.action     = newAction

            if (!this.hasTarget()) {
                this.target && this.target.clear()
                this.toTarget && this.toTarget.clear()
            }
        },
        
        
        hasTarget : function () {
            return this.isMouseAction()
        },
        
        
        getTarget : function (asInstance) {
            var target      = this.target
            
            return asInstance ? target : target && this.target.getTarget()
        },
        
        
        isMouseAction : function () {
            return (this.action || '').toLowerCase() in {
                click           : 1,
                contextmenu     : 1,
                dblclick        : 1,
                drag            : 1,
                mousedown       : 1,
                mouseup         : 1,
                movecursorto    : 1
            }
        },
        
        
        resetValues : function () {
            this.target         = null
            this.value          = null
            this.toTarget       = null
            this.by             = null
            this.options        = null
            this.sourceEvent    = null
        },
        
        
        parseOffset : function (offsetString) {
            var values  = offsetString.split(',');
    
            if (values.length < 2) return;
    
            if (!values[ 0 ].match('%')) {
                values[ 0 ] = parseInt(values[ 0 ], 10);
    
                if (isNaN(values[ 0 ])) return;
            }
    
            if (!values[ 1 ].match('%')) {
                values[ 1 ] = parseInt(values[ 1 ], 10);
    
                if (isNaN(values[ 1 ])) return;
            }
    
            return values;
        },
        
        
        clearTargetOffset : function () {
            this.setTargetOffset(null)
        },
    
    
        setTargetOffset : function (value) {
            var target  = this.target
            
            if (target) target.setOffset(value)
        },
    
    
        getTargetOffset : function () {
            var target  = this.target
            
            if (target) return target.getOffset()
        },
        
        
        objectToSource : function (obj) {
            var me = this;
            var result = '';
            var prependComma;
            var convertFn = function (key, value) {
                value = value || obj[key];

                if (value instanceof Array) {
                    return key + ' : [' + value.join(', ') + ']';
                } else if (typeof value === 'object') {
                    return key + ' : ' + me.objectToSource(value);
                } else {
                    return key + ' : ' + (typeof (value) === 'string' ? '"' + value + '"' : value);
                }
            };

            // Use brief action description, do this manually to make sure action + target is
            // the first item in the object descriptor
            if (obj.target) {
                result = convertFn(obj.action, obj.target);
                prependComma = true;

                delete obj.target;
                delete obj.action;
            }

            var keys = Object.keys(obj);

            if (keys.length > 0) {
                result = result + (prependComma ? ', ' : '') + keys.map(function(key) { return convertFn(key); }).join(', ');
            }

            return '{ ' + result + ' }';
        },


        asCode : function () {
            var step        = this.asStep()

            if (!step) return null

            return typeof step == 'function' ? step : this.objectToSource(step)
        },
        
        
        asStep : function (test) {

            var actionName      = this.action

            if (!actionName) return null
            
            var step            = { action : this.action };
            var target          = this.getTarget()
            var value           = this.value
            var hasTarget       = this.hasTarget()

            if (hasTarget) {
                if (!target) {
                    // If target is required but not filled in, just leave it blank
                    step.target = '';
                } else if (target.type == 'cq') {
                    var splitPos = target.target.indexOf('->');
                    step.target     = splitPos > 0 ? target.target.split('->').splice(1, 0, '>>').join() : '>>' + target.target
                } else {
                    step.target     = target.target
                }

                if (target && target.offset)
                    step.offset = target.offset.slice()
            }
    
    //        if (!actionName.match('waitFor') && target && typeof target !== "string" && !target.length) {
    //            throw 'Invalid target for ' + actionName + ' actionRecord: ' + target;
    //        }
    //
            if (this.options && !Joose.O.isEmpty(this.options)) {
                step.options    = this.options;
            }
    
            if (actionName.match(/^waitFor/)) {
                switch (actionName) {
                    case 'waitForFn':
                        // After this statement, t will be available in the evaled function below just as a regular local variable
                        if (test) var t   = test;
                        return { waitFor : eval("(function() {\n        " + value.replace(/\n/g, "\n        ") + "\n    })") };
    
                    case 'waitForMs':
                        var val = parseInt(value, 10);
    
                        return { waitForMs : val };
    
                    default:
                        var obj = {};

                        obj[actionName] = value || [];

                        return obj;
                }
            } else {
                switch (actionName) {
                    case 'click':
                    case 'dblclick':
                    case 'contextmenu':
                    case 'mousedown':
                    case 'mouseup':
                    case 'moveCursorTo':
                        break;

                    case 'screenshot':
                        step = { screenshot : value };
                        break;

                    case 'moveCursorBy':
                        var by = this.value.split(',');
                        by[0] = parseInt(by[0], 10);
                        by[1] = parseInt(by[1], 10);

                        step = { action : 'moveCursor', by : by};
                        break;

                    case 'type':
                        step.text   = value;
                        delete step.target;
    
                        break;
    
                    case 'drag':
                        var toTarget    = this.toTarget
                        
                        if (toTarget && !toTarget.isTooGeneric()) {
                            step.to                             = toTarget.target;
                            if (toTarget.offset) step.toOffset  = toTarget.offset;
                            
                            break;
                        }
                        
                        step.by = this.by;
    
                        break;
    
                    case 'fn':
                        // After this statement, t will be available in the evaled function below just as a regular local variable
                        if (test) var t   = test;
    
                        return eval("(function(next) {\n        " + value.replace(/\n/g, "\n        ") + "\n        next();\n    })");
    
                    default:
                        var step = {};
                        step[actionName] = value;
                        return step;
                }
            }
    
            return this.waitForPageLoad ? { waitForPageLoad : [], trigger : step } : step;
        }
        
    }
});

}();;
Ext.define('Siesta.Recorder.UI.Model.Action', {
    extend      : 'Ext.data.TreeModel',
    
    fields      : Object.keys ? Object.keys(Siesta.Recorder.Action.meta.getAttributes().properties) : [],
    
    actionClass : Siesta.Recorder.Action,
    $action     : null,


    constructor : function (data) {
        if (!data.children && !('leaf' in data) && !data.root) data.leaf = true;

        // surprisingly the change in "data" variable will be reflected in "arguments"
        this.callParent([data]);

        if (data && !data.root) {
            var action = data;
            if (!(action instanceof this.actionClass)) {
                action        = new this.actionClass(action)
            }

            //Siesta.Recorder.Action.meta.getAttributes().each(function(attr){ data[attr.name] = action[attr.name]; });
            this.$action = action;

            Ext.applyIf(action, this.data);
            this.data = action;
        }

    }
//    ,
    
    
//    setTargetByType : function (targetType, target) {
//        return this.$action.setTargetByType()
//    },


//    resetValues : function () {
//        this.$action.resetValues()
//        
//        this.afterEdit([ 'targets', 'value', '__offset__' ])
//    },
//
//    
//    clearTargetOffset : function () {
//        this.$action.clearTargetOffset()
//        
//        this.afterEdit([ 'targets' ])
//    },
//    
//    
//    setTargetOffset : function (value) {
//        this.$action.setTargetOffset(value)
//        
//        this.afterEdit([ '__offset__' ])
//    }
    
    
}, function () {
    var prototype   = this.prototype

    //var attributeNames  = [];
    //Siesta.Recorder.Action.meta.getAttributes().each(function(attr){ attributeNames.push(attr.name)});
    //
    //if (this.addFields) {
    //    this.addFields(attributeNames);
    //} else {
    //    var fields      = prototype.fields
    //    fields.addAll(attributeNames);
    //}

    Joose.A.each([ 
        'getTargetOffset', 'isMouseAction', 'parseOffset', 'getTarget', 'getTargets', 'hasTarget', 'asStep', 'asCode'
    ], function (methodName) {
        prototype[ methodName ] = function () {
            return this.$action[ methodName ].apply(this.$action, arguments)
        }
    })
    
    Joose.O.each({
        clearTargetOffset       : [ 'target' ],
        setTargetOffset         : [ 'target' ],
        resetValues             : [ 'target', 'value' ],
        setAction               : [ 'action', 'target' ]
    }, function (fields, methodName) {
        prototype[ methodName ] = function () {
            var res     = this.$action[ methodName ].apply(this.$action, arguments)

            // TODO not needed since we do refreshNode
            //this.afterEdit(fields)

            return res
        }
    })
});
;
Ext.define('Siesta.Recorder.UI.Store.Action', {
    extend : 'Ext.data.TreeStore',
    alias  : 'store.actionstore',
    model  : 'Siesta.Recorder.UI.Model.Action',
    alias  : 'store.actionstore',
    proxy  : 'memory',
    root   : {
        expanded : true
    },

    tabSize : 4,

    generateCode : function (name) {
        var root = this.getRootNode();
        var code = '';

        if (root.childNodes.length > 0) {
            if (root.firstChild.isLeaf()) {
                // Make a simple chain
                code = this.generateChain(root);
            } else {
                // Group assertions into "it" statements
                code = root.childNodes.map(this.generateCodeForNode, this).join('\n\n');
            }
        }

        return 'describe("' + name + '", function(t) {\n' + code + '\n});'
    },

    generateCodeForNode : function (node) {

        if (node.isLeaf()) {
            return this.getIndent(node.data.depth + 1) + node.asCode();
        }

        if (node.get('action') === 'group') {
            return this.generateIt(node);
        }
    },

    generateIt : function (node) {
        var indent = this.getIndent(node.data.depth);
        var itPre  = indent + 't.it("' + (node.get('value') || 'should...') + '", function(t) {\n';
        var itPost = '\n' + indent + '});';

        return itPre + this.generateChain(node) + itPost;
    },

    generateChain : function (node) {
        var me        = this;
        var indent    = this.getIndent(node.data.depth + 1);
        var chainPre  = indent + 't.chain(\n';
        var chainPost = '\n' + indent + ');';

        var codeForSteps = node.childNodes.map(function (step) {
            return me.generateCodeForNode(step);
        }).join(',\n\n');

        return chainPre + codeForSteps + chainPost;
    },

    getIndent : function (tabs) {
        return new Array((this.tabSize * tabs) + 1).join(' ');
    }
});
;
Ext.define('Siesta.Recorder.UI.Editor.ActionName', {
    extend          : 'Ext.form.field.ComboBox',
    alias           : 'widget.typeeditor',
    
    displayField    : 'id',
    valueField      : 'id',
    queryMode       : 'local',
    matchFieldWidth : false,
    forceSelection  : true,
    typeAhead       : true,
    selectOnFocus   : true,

    store : {
        fields : [ 'id', 'type' ]
    },

    // TODO move to test class autogenerate these (either during Siesta build or at Siesta runtime - via JsDuck?)
    // Not all commands can be edited either (like waitForStoresToLoad etc).
    actions         : [
        { id : 'group', type : 'group' },
        { id : 'click', type : 'mouseinput' },
        { id : 'dblclick', type : 'mouseinput' },
        { id : 'contextmenu', type : 'mouseinput' },

        { id : 'drag', type : 'mouseinput' },
        { id : 'fn', type : 'fn' },
        { id : 'moveCursorTo', type : 'mouseinput' },
        { id : 'moveCursorBy', type : 'mouseinput' },
        { id : 'mousedown', type : 'mouseinput' },
        { id : 'mouseup', type : 'mouseinput' },
        { id : 'type', type : 'keyinput' },
        { id : 'screenshot', type : 'screenshot' },
        { id : 'setUrl', type : 'navigate' }
    ],

    applyChanges : function (actionRecord) {
        var value = this.getValue();

        actionRecord.setAction(value)
        actionRecord.set('leaf', value !== 'group');
    },
    

    populate : function (test) {
        var waitActions = [];

        for (var o in test) {
            if (o.match(/waitFor.+/) && typeof test[ o ] === 'function') {
                waitActions.push({ id : o, type : 'wait' });
            }
        }

        var actions = this.actions.concat(waitActions).sort(function(a, b) { return a.id < b.id ? -1 : 1; });

        this.store.loadData(actions);
    }

});
;
Ext.define('Siesta.Recorder.UI.Editor.Array', {
    extend          : 'Ext.form.field.Text',
    alias           : 'widget.arrayeditor',

    getValue : function () {

        var value = this.callParent(arguments);

        if (typeof value === 'string' && value.match(/\d*,\d*/)) {
            value = value.split(',');
            value[0] = parseInt(value[0], 10);
            value[1] = parseInt(value[1], 10);
        }

        return value;
    }
});
;
Ext.define('Siesta.Recorder.UI.Editor.Target', {
    extend          : 'Ext.form.field.ComboBox',
    alias           : 'widget.targeteditor',

    enableKeyEvents : true,
    queryMode       : 'local',
    valueField      : 'type',
    displayField    : 'value',
    cls             : 'siesta-targeteditor',
    
    targetProperty  : 'target',

    store : {
        proxy   : 'memory',
        fields  : [ 'type', 'value', 'target' ]
    },

    getTarget : function () {
        var value       = this.getValue();
        
        if (value && /^!!(.+)/.exec(value)) {
            var record      = this.store.findRecord('type', value)

            // TODO also return 'offset'?
            return record ? record.get('target') : null
        }
        
        return value ? {
            type        : 'user',
            target      : value
        } : null
    },

    
    setValue : function (value) {
        // This method is called with an array of a single record
        if (value instanceof Siesta.Recorder.Target) {
            if (value.getTarget())
                this.callParent([ '!!' + value.getTarget().type ]);
            else
                this.callParent([ '' ])
        } else
            this.callParent(arguments)
    },
    
    
    getEditorValue : function (record) {
        return record.data[ this.targetProperty ]
    },
    
    
    applyChanges : function (actionRecord) {

        var value       = this.getValue()
        var match
        
        var target      = actionRecord.data[ this.targetProperty ]

        // Typing 100,200 should mean a coordinate
        if (typeof value === 'string' && value.match(/\d*,\d*/)) {
            value = value.split(',');
            value[0] = parseInt(value[0], 10);
            value[1] = parseInt(value[1], 10);
        }

        if (value && !target) {
            target      = actionRecord.data[ this.targetProperty ] = new Siesta.Recorder.Target({
                targets     : [ { type : 'user', target : value } ]
            })
        }

        if (target) {
            if (value && (match = /^!!(.+)/.exec(value)))
                target.activeTarget = match[ 1 ]
            else {
                target.setUserTarget(value)
            }

            // TODO
            //actionRecord.afterEdit(this.targetProperty)
        }
    },

    
    populate : function (target) {
        var storeData   = [];

        target && target.targets.forEach(function (target) {
            var type     = target.type
            value        = target.target;

            if (type === 'cq' ) {
                var splitPos = target.target.indexOf('->');
                value = splitPos > 0 ? target.target.split('->').splice(1, 0, '>>').join() : '>>' + target.target
            }

            storeData.push({
                // we add the "!!" before the type, so that "setValue(value)" can distinguish between the value as 
                // arbitrary string (user input) and value as type name (which should change only the "activeTarget")
                type    : '!!' + type, 
                value   : value,
                target  : target
            });
        });

        this.store.loadData(storeData);
    }
});
;
Ext.define('Siesta.Recorder.UI.Editor.DragTarget', {
    extend          : 'Ext.form.field.Picker',
    alias           : 'widget.drageditor',

    editable        : false,
    hideTrigger     : true,
    minWidth        : 300,
    sourceEditor    : null,
    targetEditor    : null,
    record          : null,
    onTargetChange  : null,

    listeners       : {
        focus : function (fld, e, opts) {
            fld.expand();
        }
    },

    
    cancelEdit : function () {
        var me = this;
        
        me.fireEvent('blur');
        me.collapse();
    },

    
    applyValues : function () {
        var me          = this,
            form        = me.picker,
            values      = form.getForm().getValues()
            
        var rec         = me.up('tablepanel').editing.activeRecord;
            
        this.sourceEditor.applyChanges(rec)
        this.targetEditor.applyChanges(rec)
        
        var by          = values.by;
        
        rec.set('by', (by && rec.parseOffset(by)) || by)

        me.fireEvent('blur');
        me.collapse();
    },
    
    
    applyChanges : function () {
    },

    
    collapseIf : function (e) {
        if (!e.getTarget('.x-layer')) return this.callParent(arguments)
    },
    
    
    mimicBlur : function (e) {
        if (!e.getTarget('.x-layer')) return this.callParent(arguments)
    },
    
    
    createPicker : function () {
        var R               = Siesta.Resource('Siesta.Recorder.UI.Editor.DragTarget');
        var me              = this;
        
        var targetListeners = {
            select  : this.onTargetChange,
            keyup   : this.onTargetChange,
            focus   : this.onTargetChange,
            buffer  : 50,
            scope   : this
        };

        return new Ext.form.Panel({
            floating    : true,
            bodyPadding : 5,
            title       : R.get('dragVariantTitle'),
            items       : [
                this.sourceEditor = new Siesta.Recorder.UI.Editor.Target({
                    fieldLabel  : R.get('targetLabel') + ':',
                    anchor      : '100%',
                    name        : 'target',
                    labelWidth  : 60,
                    listeners   : targetListeners
                }),
                this.targetEditor = new Siesta.Recorder.UI.Editor.Target({
                    targetProperty   : 'toTarget',
                    
                    fieldLabel  : R.get('toLabel') + ':',
                    name        : 'toTarget',
                    anchor      : '100%',
                    labelWidth  : 60,

                    listeners   : targetListeners
                }),
                {
                    xtype       : 'textfield',
                    name        : 'by',
                    fieldLabel  : R.get('byLabel') + ':',
                    labelWidth  : 60,
                    width       : 200
                }
            ],
            listeners: {
                afterrender: function (panel, opts) {
                    var rec     = me.record;

                    me.sourceEditor.populate(rec.get('target'))
                    me.targetEditor.populate(rec.get('toTarget'))

                    panel.getForm().setValues(rec.data);
                }
            },
            buttons : [
                {
                    name    : 'cancel',
                    text    : R.get('cancelButtonText'),
                    handler : function (btn, e, opts) {
                        me.cancelEdit();
                    }
                },
                '->',
                {
                    name    : 'save',
                    text    : R.get('saveButtonText'),
                    handler : function (btn, e, opts) {
                        me.applyValues();
                    }
                }
            ]
        });
    }

});;
Ext.define('Siesta.Recorder.UI.ActionIconColumn', {
    extend       : 'Ext.grid.Column',
    alias        : 'widget.recorderactioniconcolumn',
    dataIndex    : 'action',
    width        : 28,
    sortable     : false,
    menuDisabled : true,
    align        : 'center',
    tdCls        : 'siesta-recorderpanel-action-icon-column',

    constructor : function () {
        this.scope  = this;

        this.callParent(arguments);
    },

    renderer : function (value, meta, record) {
        if (value && record.get('leaf')) {
            var cls = this.getCssByActionType(value);

            return '<span class="action-icon fa ' + cls + '"></span>';
        }
    },

    getCssByActionType : function (type) {
        if (type.match('^wait')) return 'fa-clock-o';
        if (type.match('^move')) return 'fa-arrows';
        if (type === 'type' || type === 'setValue') return 'fa-keyboard-o';
        if (type === 'screenshot') return 'fa-camera';
        if (type === 'fn') return 'fa-code';

        return 'fa-mouse-pointer';
    }
});
;
Ext.define('Siesta.Recorder.UI.ActionColumn', {
    extend       : 'Ext.tree.Column',
    alias        : 'widget.recorderactioncolumn',
    dataIndex    : 'action',
    width        : 100,
    sortable     : false,
    menuDisabled : true,
    tdCls        : 'siesta-recorderpanel-typecolumn',
    editor       : 'typeeditor',

    constructor : function () {
        var R       = Siesta.Resource('Siesta.Recorder.UI.RecorderPanel');
        this.text   = R.get('actionColumnHeader');

        this.callParent(arguments);
    },

    renderer : function(value, meta, record) {
        meta.tdCls = ' action-level-' + (record.parentNode.data.root ? '0' : '1');

        return value;
    }
});
;
Ext.define('Siesta.Recorder.UI.TargetColumn', {
    extend       : 'Ext.grid.Column',
    alias        : 'widget.targetcolumn',

    header       : Siesta.Resource('Siesta.Recorder.UI.TargetColumn', 'headerText'),
    dataIndex    : 'target',
    flex         : 1,
    sortable     : false,
    menuDisabled : true,
    field        : {},
    tdCls        : 'eventview-targetcolumn',

    // API for highlighting typed target text, supplied by owner/creator
    highlightTarget : null,


    renderer : function (value, meta, record) {
        // we are not interested in the default value which is a "target" field value
        value               = ''

        var actionName      = (record.data.action || '').toLowerCase()

        if (record.hasTarget()) {
            var target      = record.getTarget()

            if (target) {
                var R           = Siesta.Resource('Siesta.Recorder.UI.TargetColumn');

                value               = target.target

                if (target && target.type == 'cq') value = '>>' + value

                if (actionName === 'drag') {

                    var toTarget    = record.data.toTarget
                    var by          = record.data.by

                    if (toTarget && toTarget.targets.length && (!toTarget.isTooGeneric() || !by))
                        value       += ' ' + R.get('to') + ': ' + toTarget.getTarget().target;
                    else if (by)
                        value       += ' ' + R.get('by') + ': [' + by + ']';
                }

                meta.tdCls = 'eventview-target-' + target.type

                if (target.type === 'xy') {
                    meta.tdAttr = "title='" + R.get('coordinateTargetWarning') + "'";
                }
            }
        } else {
            value           = record.get('value')
        }

        meta.tdAttr = 'title="' + Ext.String.htmlEncode(value) + '"';

        return value;
    },

    setTargetEditor : function (actionRecord) {
        var newField = this.getTargetEditor(actionRecord);

        // Not all actions have target editors
        if (!newField) {
            return false;
        }

        this.setEditor(newField);
    },


    getTargetEditor : function (record) {
        var me          = this;
        var action      = record.get('action');
        var editor;

        if (action.match(/^waitFor/)) {
            if (action === 'waitForAnimations') return null;

            if (action === 'waitForFn') {
                editor =  new Siesta.Recorder.UI.Editor.Code();
            } else {
                this.dataIndex = 'value';

                if (action === 'waitForMs') {
                    editor = new Ext.form.field.Number()
                } else {
                    // Default waitFor editor will just be a text field
                    editor = new Ext.form.field.Text();
                }
            }
        } else if (action === 'drag') {
            this.dataIndex = 'target';

            editor = new Siesta.Recorder.UI.Editor.DragTarget({
                onTargetChange : function () {
                    me.onTargetChange.apply(me, arguments);
                }
            });
        } else if (action === 'fn') {
            this.dataIndex = 'value';

            editor = new Siesta.Recorder.UI.Editor.Code();
        } else if (action === 'type' || action === 'moveCursorBy' || action === 'screenshot' || action === 'setUrl') {
            this.dataIndex = 'value';

            editor =  new Ext.form.field.Text();
        }else if (action === 'setWindowSize') {
            this.dataIndex = 'value';

            editor =  new Siesta.Recorder.UI.Editor.Array();
        }
        else {
            // Assume it's a target action
            this.dataIndex = 'target';

            editor = new Siesta.Recorder.UI.Editor.Target({
                listeners : {
                    select : this.onTargetChange,
                    keyup  : this.onTargetChange,
                    focus  : this.onTargetChange,
                    buffer : 50,
                    scope  : this
                }
            });
            editor.populate(record.data.target);
        }

        // Give editor access to the record
        editor.record = record;

        return editor;
    },


    onTargetChange : function (field) {
        var target      = field.getTarget();

        if (!target) return;

        var textTarget  = target.target

        if (target.type == 'cq') textTarget = '>>' + textTarget

        if (this.highlightTarget) {
            var result      = this.highlightTarget(textTarget, target.offset);

            if (result.success) {
                field.clearInvalid()
            } else {
                field.markInvalid(result.message);
            }
        }
    }
});
;
Ext.define('Siesta.Recorder.UI.RecorderPanel', {
    extend : 'Ext.tree.Panel',

    alias : 'widget.recorderpanel',

    requires : [
        'Ext.grid.plugin.CellEditing'
    ],

    buttonAlign : 'left',
    border      : false,
    cls         : 'siesta-recorderpanel',
    selModel    : {
        mode : 'MULTI'
    },

    store : {
        type : 'actionstore'
    },

    rootVisible : false,

    viewConfig : {
        markDirty  : false,
        stripeRows : false,
        allowCopy  : true,
        plugins    : {
            ptype : 'treeviewdragdrop'
        }
    },


    newActionDefaults : {
        action : 'click'
    },
    lines             : false,
    test              : null,
    recorder          : null,
    harness           : null,
    domContainer      : null,
    recorderConfig    : null,
    editing           : null,
    enableColumnMove  : false,
    bufferedRenderer  : false,
    recorderClass     : 'Siesta.Recorder.ExtJS',

    enableContextMenu : true,
    showToolbars      : true,
    enableEditing     : true,
    playbackOnly      : false,

    /**
     * @event startrecord
     * Fires when a recording is started
     * @param {Siesta.Recorder.UI.RecorderPanel} this
     * @param {Siesta.Test} test The test instance to which the recorder is attached
     */
    /**
     * @event stoprecord
     * Fires when a recording is stopped
     * @param {Siesta.Recorder.UI.RecorderPanel} this
     */
    /**
     * @event play
     * Fires when a recording is being played back
     * @param {Siesta.Recorder.UI.RecorderPanel} this
     */

    initComponent : function () {
        var me             = this;
        var R              = Siesta.Resource('Siesta.Recorder.UI.RecorderPanel');
        var recorderConfig = this.recorderConfig || {};

        if (this.enableEditing) {
            me.plugins = me.plugins ? [].concat(me.plugins) : [];

            me.editing = me.editing || new Ext.grid.plugin.CellEditing({
                clicksToEdit : 1
            });

            me.editing.on({
                beforeedit   : me.onBeforeEdit,
                validateedit : me.onValidateEdit,
                edit         : me.afterEdit,
                canceledit   : me.afterEdit,
                scope        : me
            });

            this.relayEvents(me.editing, ['beforeedit', 'afteredit', 'validateedit'])

            me.plugins.push(me.editing);

            this.on('hide', function () {
                if (this.editing) {
                    this.editing.completeEdit();
                }
            });

            this.on({
                afteredit    : this.onAfterEdit,
                validateedit : this.onAfterEdit,
                canceledit   : this.onAfterEdit,
                scope        : this,
                buffer       : 200
            });
        }

        Ext.applyIf(me, {

            columns : [
                {
                    xtype : 'recorderactioniconcolumn'
                },
                {
                    xtype : 'recorderactioncolumn'
                },
                {
                    xtype           : 'targetcolumn',
                    highlightTarget : this.highlightTarget.bind(this)
                }
            ].concat(
                recorderConfig.recordOffsets !== false ? {
                    header       : R.get('offsetColumnHeader'),
                    dataIndex    : '__offset__',
                    width        : 60,
                    sortable     : false,
                    menuDisabled : true,
                    tdCls        : 'siesta-recorderpanel-offsetcolumn',
                    renderer     : function (value, meta, record) {
                        var target = record.getTarget()

                        if (target && target.offset) {
                            return target.offset + '<div class="siesta-recorderpanel-clearoffset fa fa-close"></div>'
                        }
                    },
                    editor       : 'textfield'
                } : []
            ).concat({
                    xtype        : 'actioncolumn',
                    width        : 55,
                    align        : 'center',
                    sortable     : false,
                    menuDisabled : true,
                    tdCls        : 'siesta-recorderpanel-actioncolumn',

                    items : [
                        {
                            iconCls : 'step-icon fa fa-close icon-delete-row',
                            tooltip : 'Delete this action',
                            handler : this.onDeleteStepClick,
                            scope   : this
                        },
                        {
                            iconCls : 'step-icon fa fa-play icon-play-row',
                            tooltip : 'Play this action',
                            handler : this.onPlaySingleStepClick,
                            scope   : this
                        },
                        {
                            iconCls : 'step-icon fa fa-forward icon-play-from-row',
                            tooltip : 'Play from this action',
                            handler : this.onPlayFromStepClick,
                            scope   : this
                        }]
                })
        });

        if (this.showToolbars) {
            me.createToolbars();
        }

        if (!this.playbackOnly) {
            var recorder = me.recorder = me.recorder || new Siesta.Recorder.ExtJS(
                this.recorderConfig || {}
            );

            recorder.on("actionadd", this.onActionAdded, this)
            recorder.on("actionremove", this.onActionRemoved, this)
            recorder.on("actionupdate", this.onActionUpdated, this)
            recorder.on("clear", this.onRecorderClear, this)

            recorder.on("start", this.onRecorderStart, this)
            recorder.on("stop", this.onRecorderStop, this)
        }

        me.callParent();

        this.mon(Ext.getBody(), 'mousedown', this.onBodyMouseDown, this, { delegate : '.target-inspector-label' })

        if (this.enableContextMenu) {
            this.contextMenu = new Siesta.Recorder.UI.ContextMenu({
                panel : this
            });
        }
    },

    onAfterEdit : function () {
        if (!this.editing.editing) {
            this.hideHighlighter();
        }
    },

    onBodyMouseDown : function (e, t) {
        var focusedEl = document.activeElement;

        if (Ext.fly(focusedEl).up('.siesta-targeteditor')) {
            e.stopEvent();
            e.preventDefault();
            focusedEl.value = Ext.htmlDecode(t.innerHTML);
        }
    },


    onRecorderStart : function () {

        this.fireEvent('startrecord', this, this.test);

        this.addCls('recorder-recording');
    },


    onRecorderStop : function () {

        this.fireEvent('stoprecord', this);

        this.removeCls('recorder-recording');
    },


    hideHighlighter : function () {
        if (this.test && this.domContainer) {
            this.domContainer.clearHighlight();
        }
    },


    highlightTarget : function (target, offset) {
        if (!target) {
            // Pass no target => simply hide highlighter
            this.hideHighlighter();
            return;
        }

        var test = this.test;

        if (!test) {
            this.hideHighlighter();
            return { success : true }
        }

        var R = Siesta.Resource('Siesta.Recorder.UI.RecorderPanel');
        var resolved, el

        try {
            resolved = this.test.normalizeElement(target, true, true, true);

            el = resolved.el
        } catch (e) {
            // sizzle may break on various characters in the query (=, $, etc)
        } finally {
            if (!el) {
                return { success : false, warning : R.get('queryMatchesNothing') }
            }
        }

        var warning = resolved.matchingMultiple ? R.get('queryMatchesMultiple') : ''

        if (test.isElementVisible(el) && this.domContainer) {
            var pointToVisualize = Ext.isArray(target) ? target : (offset || ['50%', '50%']);

            this.domContainer.highlightTarget(el, '<span class="target-inspector-label">' + target + '</span>', pointToVisualize);
        } else {
            // If target was provided but no element could be located, return false so
            // caller can get a hint there is potential trouble
            warning = warning || R.get('noVisibleElsFound')
        }

        return {
            success : !warning,
            message : warning
        };
    },


    createToolbars : function () {
        var me = this;
        var R  = Siesta.Resource('Siesta.Recorder.UI.RecorderPanel');

        me.dockedItems = [
            {
                xtype   : 'toolbar',
                padding : '3 5',
                cls     : 'siesta-toolbar recorder-toolbar',
                dock    : 'top',
                height  : 45,
                style   : 'border-color:transparent',
                items   : [
                    {
                        xtype      : 'textfield',
                        itemId     : 'recording-name',
                        fieldLabel : 'Name',
                        height     : 30,
                        width      : 200,
                        labelWidth : 50,
                        value      : R.get('newRecording')
                    },
                    {
                        xtype           : 'textfield',
                        itemId          : 'pageUrl',
                        height          : 30,
                        flex            : 1,
                        labelWidth      : 70,
                        fieldLabel      : R.get('pageUrl'),
                        enableKeyEvents : true,
                        listeners       : {
                            keyup : function (field, e) {
                                if (e.getKey() == e.ENTER) {
                                    this.onPageUrlFieldEnterKey();
                                }
                            },
                            scope : this
                        }
                    }
                ]
            },
            {
                xtype    : 'toolbar',
                cls      : 'siesta-toolbar',
                style    : 'border-color:transparent',
                dock     : 'top',
                height   : 45,
                defaults : {
                    scale       : 'medium',
                    tooltipType : 'title',
                    scope       : me
                },
                items    : [
                    {
                        iconCls  : 'fa fa-circle icon-record',
                        action   : 'recorder-start',
                        cls      : 'recorder-tool',
                        whenIdle : true,
                        tooltip  : R.get('recordTooltip'),
                        handler  : me.onRecordClick
                    },
                    {
                        iconCls : 'fa fa-square',
                        cls     : 'recorder-tool',
                        action  : 'recorder-stop',
                        handler : me.stop,
                        tooltip : R.get('stopTooltip')
                    },
                    {
                        iconCls : 'fa fa-play',
                        action  : 'recorder-play',
                        cls     : 'recorder-tool',
                        handler : me.onPlayClick,
                        tooltip : R.get('playTooltip')
                    },
                    {
                        iconCls : 'fa fa-close',
                        action  : 'recorder-remove-all',
                        cls     : 'recorder-tool icon-clear',
                        handler : function () {
                            var me = this;

                            if (me.store.getCount() === 0) return;

                            Ext.Msg.confirm(R.get('removeAllPromptTitle'), R.get('removeAllPromptMessage'), function (btn) {
                                if (btn == 'yes') {
                                    // process text value and close...
                                    me.clear();
                                }
                            });
                        },
                        tooltip : R.get('clearTooltip')
                    },
                    {
                        iconCls     : 'fa fa-plus',
                        action      : 'recorder-add-step',
                        tooltip     : R.get('addNewTooltip'),
                        cls         : 'recorder-tool',
                        tooltipType : 'title',
                        scope       : me,
                        handler     : function () {
                            var store    = me.store;
                            var selected = me.getSelectionModel().selected.first();
                            var model    = new store.model(Ext.apply({}, this.newActionDefaults));

                            if (selected && selected.isVisible()) {
                                selected.parentNode.insertChild(selected.get('index') + 1, model);
                            } else {
                                store.getRootNode().appendChild(model);
                            }

                            me.editing.startEdit(model, 1);
                        }
                    },
                    '->',
                    {
                        xtype   : 'splitbutton',
                        text    : 'Show source',
                        cls     : 'recorder-tool',
                        action  : 'recorder-generate-code',
                        handler : this.onGenerateCodeClick,
                        scope   : this,
                        menu    : {
                            items : [
                                {
                                    text    : R.get('showSourceInNewWindow'),
                                    scope   : this,
                                    handler : function () {
                                        var win           = window.open(null);
                                        var body          = win.document.body;
                                        var recordingName = this.getRecordingName();
                                        var code          = this.store.generateCode(recordingName);

                                        body.innerHTML = '<pre>' + code + '</pre>';
                                    }
                                }
                            ]
                        }
                    },

                    me.closeButton
                ]
            }];

        me.bbar = {
            xtype  : 'component',
            cls    : 'cheatsheet',
            height : 70,
            html   : '<table><tr><td class="cheatsheet-type">CSS Query:</td><td class="cheatsheet-sample"> .x-btn</td></tr>' +
            '<tr><td class="cheatsheet-type">Component Query:</td><td class="cheatsheet-sample"> &gt;&gt;toolbar button</td></tr>' +
            '<tr><td class="cheatsheet-type">Composite Query:</td><td class="cheatsheet-sample"> toolbar =&gt; .x-btn</td></tr></table>'
        };
    },

    // Attach to a test (and optionally a specific iframe, only used for testing)
    attachTo : function (test, iframe) {
        var me       = this;
        var doClear  = me.test && me.test.url !== test.url;
        var recorder = this.recorder

        this.setTest(test);

        var recWindow = (iframe && iframe.contentWindow) || (test.scopeProvider && test.scopeProvider.scope);

        if (recWindow) {
            me.recorder.attach(recWindow);
        }

        if (doClear) me.clear();
    },

    onPageUrlFieldEnterKey : function () {
        var descriptor = this.getRecorderTestDescriptor();

        if (descriptor && (descriptor.hostPageUrl || descriptor.pageUrl)) {
            this.harness.startSingle(descriptor);

            this.harness.on('teststart', function (event, test) {

                if (test.url === descriptor.url) {

                    // To ensure test is visible
                    this.fireEvent('play', this, test, 0);
                }

            }, this, { single : true });
        }
    },

    onRecordClick : function () {
        var test = this.test;

        if (!this.test) return;

        var R          = Siesta.Resource('Siesta.Recorder.UI.RecorderPanel');
        var descriptor = this.getRecorderTestDescriptor();

        if (descriptor) {

            if (this.isRecording()) {
                this.stop();
            } else {
                var harness = this.harness;
                var pageUrl = this.down('#pageUrl').getValue();

                // Grab a new test reference from harness in case test was rerun while recorder was open
                test = harness.getTestByURL(test.url);

                this.setTest(test);

                var scopeProvider = harness.getTestByURL(test.url).scopeProvider;

                // If we're recording a new URL, or the test has no window (already was cleaned up) -
                // first launch the test to load the URL into the test iframe
                if (!scopeProvider || pageUrl && scopeProvider.sourceURL !== pageUrl) {
                    harness.on('teststart', function (event, test) {

                        if (test.url === descriptor.url) {
                            this.attachTo(test);
                            this.recorder.start();
                        }

                    }, this, { single : true });

                    harness.startSingle(descriptor);
                } else if (test && test.global) {
                    this.attachTo(test);
                    this.recorder.start();
                }
            }

        } else {
            Ext.Msg.alert('Error', R.get('noTestStarted'))
        }
    },


    onPlayClick : function () {
        var me         = this;
        var descriptor = this.getRecorderTestDescriptor();

        if (descriptor) {
            me.stop();

            var testStartListener = function (ev, runningTestInstance) {
                if (runningTestInstance.url === descriptor.url) {
                    me.fireEvent('play', this, runningTestInstance);

                    runningTestInstance.on('beforetestfinalizeearly', testFinalizeListener, null, { single : true });
                }
            };

            var testFinalizeListener = function (ev, test2) {
                // important, need to update our reference to the test
                me.setTest(test2);

                // Run test first, and before it ends - fire off the recorded steps
                test2.chain(me.generateSteps());
            };

            var harness = me.harness;

            harness.on('teststart', testStartListener, null, { single : true });

            if (this.store.getCount() > 0) {
                this.scrollRecordIntoView( this.store.getAt(0));
            }

            harness.startSingle(descriptor);
        }
    },


    stop : function () {
        this.recorder.stop();
    },


    clear : function () {
        this.recorder.clear();
    },


    onRecorderClear : function () {
        this.store.getRootNode().removeAll();
    },


    getRecorderTestDescriptor : function () {
        var harness     = this.harness;
        var pageUrl     = this.down('#pageUrl').getValue();
        var test        = this.test;
        var descriptor  = test && harness.getScriptDescriptor(test.url);
        var testHostUrl = descriptor && harness.getDescriptorConfig(descriptor, 'pageUrl');

        // If user changes target page URL - use an empty virtual test descriptor
        return pageUrl && testHostUrl !== pageUrl ? {
            url      : '/',
            testCode : 'StartTest(function(t) {})',
            pageUrl  : pageUrl
        } : (test ? descriptor : null);
    },


    setTest : function (test) {
        var harness = this.harness;
        var field   = this.down('#pageUrl');

        if (this.test) {
            this.test.un('beforechainstep', this.onBeforeActionExecute, this);
        }
        this.test = test;

        if (test) {
            test.on('beforechainstep', this.onBeforeActionExecute, this);
        }
        if (field && test.scopeProvider) {
            field.setValue(test.scopeProvider.sourceURL || '');
        }
    },


    generateSteps : function (events) {
        var me    = this;
        var t     = me.test;

        return (events || this.store.getRange()).map(function (action, index) {
            if (action.isLeaf()) {
                var step = action.asStep(t);
                // wait for targets when playing entire test,
                // and
                // when playing actions manually from a certain step, wait for all steps but the first one
                if (action.getTarget()) step.waitForTarget = !events || index > 0;

                return [
                    function(next) {
                        index = events ? me.store.indexOf(action) : index;
                        t.fireEvent('beforechainstep', t, index, step);
                        next();
                    },
                    step
                ]
            } else {
               return me.generateSteps(action.childNodes);
            }
        }).concat(function(next) {
            me.fireEvent('stop', t);
            next();
        });
    },

    onBeforeActionExecute : function(event, test, index, step) {
        var count = this.store.getCount();

        this.getSelectionModel().select(index);

        if (index < count - 2) {
            this.scrollRecordIntoView( this.store.getAt(index + 2));
        }
    },

    onActionAdded : function (event, action) {
        var root         = this.store.getRootNode();
        var targetParent = (root.lastChild && root.lastChild.parentNode) || root;

        var newRecord = targetParent.appendChild(action);

        this.scrollRecordIntoView(newRecord)
    },


    onActionRemoved : function (event, action) {
        this.store.getNodeById(action.id).remove();
    },


    onActionUpdated : function (event, action) {
        var model = this.store.getNodeById(action.id);
        model.callJoined('afterEdit', [['target', 'action', '__offset__']])
    },

    getActions : function (asJooseInstances) {
        var actionModels = this.store.getRange()

        return asJooseInstances ? Ext.Array.pluck(actionModels, 'data') : actionModels
    },


    onDestroy : function () {
        if (this.recorder) {
            this.recorder.stop();
        }

        this.callParent(arguments);
    },

    scrollRecordIntoView : function (record) {
        if (this.view.rendered) {
            this.ensureVisible(record, { animate : { duration : 100 } });
        }
    },


    onBeforeEdit : function (cellEditing, editingContext) {

        var column = editingContext.column;
        var editor;

        if (column.xtype === "targetcolumn") {
            cellEditing.completeEdit();

            column.setTargetEditor(editingContext.record);

            editingContext.value = editingContext.record.get(column.dataIndex);
        } else {
            editor = editingContext.column.getEditor();

            if (editor.xtype === 'typeeditor') {
                // Can't populate until we have a test bound
                editor.populate(this.test);
            }
        }

        if (editingContext.column.dataIndex === 'target' && this.domContainer) {
            this.domContainer.startInspection(false);
        }

        // Offset only relevant for mouseinput actions
        return editingContext.field !== '__offset__' || editingContext.record.isMouseAction();
    },


    afterEdit : function (plug, e) {

        if (e.field === 'action') {
            var store = e.column.field.store;
            store.clearFilter();

            if (store.getById(e.value).get('type') !== store.getById(e.originalValue).get('type')) {
                e.record.resetValues();
            }
        }
    },


    onValidateEdit : function (plug, e) {
        var value = e.value;

        if (e.field === 'action' && !value) return false;

        if (e.field === '__offset__') {
            e.cancel = true;

            if (value) {
                var parsed = e.record.parseOffset(value);

                if (parsed) {
                    e.record.setTargetOffset(parsed);
                }
            } else {
                e.record.clearTargetOffset();
            }
        } else if (e.column.getEditor().applyChanges) {
            e.cancel = true;

            e.column.getEditor().applyChanges(e.record);
        }

        // Trigger manual refresh of node when 'set' operation is more complex
        if (e.cancel) {
            this.afterEdit(plug, e);
            this.getView().refreshNode(e.record);
        }
    },


    afterRender : function () {
        this.callParent(arguments);

        var view = this.getView();

        view.el.on({
            mousedown : function (e, t) {
                var record = view.getRecord(view.findItemByChild(t));

                record.clearTargetOffset()
                view.refreshNode(record);

                e.stopEvent();
            },
            delegate  : '.siesta-recorderpanel-clearoffset'
        })
    },

    isRecording : function () {
        return this.recorder.active;
    },

    onGenerateCodeClick : function () {

        var R = Siesta.Resource('Siesta.Recorder.UI.RecorderPanel');

        var win = new Ext.Window({
            title       : R.get('codeWindowTitle'),
            layout      : 'fit',
            itemId      : 'codeWindow',
            height      : 400,
            width       : 600,
            autoScroll  : true,
            autoShow    : true,
            constrain   : true,
            closeAction : 'destroy',
            items       : {
                xtype : 'jseditor',
                mode  : 'text/javascript'
            }
        });

        var field         = win.items.first();
        var recordingName = this.getRecordingName();
        var code          = this.store.generateCode(recordingName);

        field.setValue(code);
        field.editor.focus();
    },

    getRecordingName : function () {
        return this.down('#recording-name').getValue();
    },

    onDeleteStepClick : function (grid, rowIndex, colIndex, item, e, record) {
        this.editing && this.editing.completeEdit();

        record.remove();
    },

    onPlaySingleStepClick : function (cmp, rowIndex) {
        this.playSingle(rowIndex);
    },

    onPlayFromStepClick : function (cmp, rowIndex) {
        this.playFromStep(rowIndex);
    },

    playSingle : function(index) {
        if (this.test) {
            var action = this.store.getAt(index);

            this.fireEvent('play', this, this.test, index);
            this.test.chain(this.generateSteps([action]));
        }
    },

    playFromStep : function (startIndex) {
        if (this.test) {
            this.playRange(startIndex);
        }
    },

    playRange : function (startIndex, endIndex) {
        if (this.test) {
            this.fireEvent('play', this, this.test, startIndex, endIndex);
            this.test.chain(this.generateSteps(this.store.getRange(startIndex, endIndex)));
        }
    },

    getRecorder : function () {
        return this.recorder;
    }
});
;
Ext.define('Siesta.Harness.Browser.UI.ComponentInspector', {
    extend : 'Ext.util.Observable',

    inspectedComponent      : null,
    inspectedComponentXType : null,
    boxIndicatorEl          : null,
    active                  : false,
    window                  : null,
    trackMouse              : true,
    showSelectorText        : true,
    bufferTime              : 30,
    injectIntoTestFrame     : false,

    getIndicatorEl : function () {
        return this.boxIndicatorEl;
    },

    getExt : function () {
        return this.window.Ext;
    },

    start : function (window, containerEl) {
        window = window || this.window;

        if (!window) throw 'Must provide a window context for the inspector';

        this.window = window;

        var _Ext = this.getExt();
        var me   = this;
        var wrap = this.injectIntoTestFrame ? window.document.body : (containerEl || window.document.body);
        var boxSizingStyle = 'box-sizing: border-box;-moz-box-sizing: border-box;-ms-box-sizing: border-box;-webkit-box-sizing: border-box;';

        me.boxIndicatorEl = me.boxIndicatorEl || Ext.fly(wrap).createChild({
            cls      : 'target-inspector-box',
            style    : 'position : absolute;left:0;top:0;pointer-events : none;z-index : 100001; border : 2px solid red;transition-property : transform;transition-duration : 0.3s;',
            children : [
                {
                    tag      : 'div',
                    style    : 'border:1px solid red;width : 13px; height : 13px;position : absolute;margin-top : -8px;margin-left : -8px;border-radius:19px;transition-property : transform;transition-duration : 0.3s;' + boxSizingStyle,
                    cls      : 'target-inspector-coordinate',
                    html     : '<div style="border-left: 1px solid red;position: absolute;top: -3px;left: 5px;height: 6px;' + boxSizingStyle +'"></div>' +
                               '<div style="border-left: 1px solid red;position: absolute;bottom: -3px;left: 5px;height: 6px;' + boxSizingStyle +'"></div>' +
                               '<div style="border-top: 1px solid red;position: absolute;top: 5px;left: -3px;width: 6px;' + boxSizingStyle +'"></div>' +
                               '<div style="border-top: 1px solid red;position: absolute;top: 5px;right: -3px;width: 6px;' + boxSizingStyle +'"></div>'
                }
            ].concat(this.showSelectorText ? {
                    tag    : 'a',
                    cls    : 'target-inspector-label',
                    target : '_blank'
                } : [])
        });

        if (this.trackMouse && _Ext && _Ext.getBody) {
            this.toggleMouseMoveListener(true);

            _Ext.getBody().on('click', this.onInspectionClick, { me : this });
        }

        this.fireEvent('start', this);

        this.active = true;
    },


    stop : function (suppressEvent) {
        if (!this.active) return;

        this.active = false;

        var _Ext            = this.getExt();

        Ext.destroy(this.boxIndicatorEl);
        this.boxIndicatorEl = null;

        if (!suppressEvent) {
            this.fireEvent('stop', this);
        }

        if (_Ext && _Ext.getBody) {
            this.toggleMouseMoveListener(false);
            _Ext.getBody().un('click', this.onInspectionClick, { me : this });
        }

        this.inspectedComponent = this.inspectedComponentXType = null;
    },


    // Listen for mousemove in the frame and any direct iframe children too
    toggleMouseMoveListener : function (enabled) {
        var _Ext = this.getExt();

        if (!_Ext) return;

        var frames = _Ext.getBody().select('iframe');
        var fn     = enabled ? 'on' : 'un';

        //                                                  Avoid using "this" directly due to Touch incompatibilities with Ext
        _Ext.getBody()[fn]('mousemove', this.onMouseMove, { me : this }, { buffer : this.bufferTime });

        for (var i = 0; i < frames.getCount(); i++) {
            var innerExt = frames.item(i).dom.contentWindow.Ext;

            //                                                                                     Avoid using "this" directly due to Touch incompatibilities with Ext
            innerExt && innerExt.getBody && innerExt.getBody()[fn]('mousemove', this.onMouseMove, { me : this }, { buffer : this.bufferTime });
        }
    },

    onInspectionClick : function (e, t) {
        if (!this.boxIndicatorEl) return;

        // Avoid using "this" directly due to Touch incompatibilities with Ext
        var me = this.me;

        me.toggleMouseMoveListener(false);

        // If user clicks on a non-component, or clicking outside currently selected component - we abort
        if (!me.inspectedComponent || me.findComponentByTarget(t) !== me.inspectedComponent) {
            me.stop();
        } else {
            me.fireEvent('targetselected', me, me.inspectedComponent, me.inspectedComponentXType);
        }
    },


    onMouseMove : function (e, t) {
        //Have to avoid using "this" directly due to Touch incompatibilities with Ext
        var me = this.me;

        if (!me.boxIndicatorEl) return;

        var cmp = me.findComponentByTarget(t);

        if (cmp) {
            if (cmp === me.inspectedComponent) return;

            var xtype = me.resolveComponentXtype(cmp);

            me.inspectedComponent      = cmp;
            me.inspectedComponentXType = xtype;

            me.highlightTarget(cmp.el.dom);
            me.updateHighlightContent(cmp, xtype);

            me.fireEvent('targethover', me, me.inspectedComponent, me.inspectedComponentXType);
        }
    },


    resolveComponentXtype : function (cmp) {
        var xtype = (cmp.getXType && cmp.getXType()) || cmp.xtype;

        // If the found component doesn't have an own xtype, look up the superclass chain to find one
        if (!xtype) {
            var cls = cmp;
            for (var i = 0; i < 10 && !xtype; i++) {
                cls   = cmp.superclass;
                xtype = cls.xtype;
            }
        }

        return xtype;
    },


    updateHighlightContent : function (cmp, xtype) {
        var html;

        var link = {
            tag  : 'a',
            cls  : 'target-inspector-label',
            href : '#'
        };

        if (typeof cmp === 'string') {
            html = cmp;
        } else if (Ext.ClassManager) {

            // If recorder is visible, let's add some targeting suggestions
            var recorderPanel = Ext.ComponentQuery.query('recorderpanel')[0];
            var targetWindow  = cmp.el.dom.ownerDocument.defaultView;
            var pageExtHasCQ  = targetWindow && targetWindow.Ext && targetWindow.Ext.ComponentQuery;

            if (recorderPanel && recorderPanel.isVisible()) {
                var cq;

                if (pageExtHasCQ) {
                    cq = recorderPanel.recorder.extractor.findComponentQueryFor(cmp);
                    cq = (cq && cq.query) || xtype;
                }
                html = '>>' + (cq || xtype);
            } else {
                var clsName = this.findExtAncestorClassName(cmp);

                if (clsName) {
                    var docsPath = Siesta.Resource('Siesta.Harness.Browser.UI.DomContainer', 'docsUrlText');
                    var framework;

                    if (Ext.versions.touch) {
                        framework = 'touch';
                    } else {
                        framework = 'extjs';
                    }

                    link.target = '_blank';
                    link.href   = Ext.String.format(docsPath, framework, clsName);
                    link.title  = Siesta.Resource('Siesta.Harness.Browser.UI.DomContainer', 'viewDocsText') + clsName;
                }

                html = xtype;
            }
        }

        if (html) {
            link.html  = html;
            var linkEl = this.boxIndicatorEl.down('.target-inspector-label', true);

            linkEl.href      = link.href;
            linkEl.title     = link.title;
            linkEl.innerHTML = html;
        }
    },


    highlightTarget : function (node, content, point) {
        var boxStyle       = this.boxIndicatorEl.dom.style;

        if (!this.active) {
            this.start();
        }

        if (node) {
            var offsets = this.getOffsets(node);
            var left    = (Ext.fly(node).getX() - 1 + offsets[0]);
            var top     = (Ext.fly(node).getY() - 1 + offsets[1]);
            var width   = ((Ext.fly(node).getWidth() || (parseInt(node.style.width.substring(0, node.style.width.length - 2), 10))) + 2);
            var height  = ((Ext.fly(node).getHeight() || (parseInt(node.style.height.substring(0, node.style.height.length - 2), 10))) + 2);

            if (this.injectIntoTestFrame) {
                left += this.window.document.body.scrollLeft;
                top  += this.window.document.body.scrollTop;
            }

            var translateStyle = $.browser.opera ? ('translate(' + left + 'px,' + top + 'px)') :
                ('translate3d(' + left + 'px,' + top + 'px, 0)');

            // Regular getWidth/getHeight doesn't work if another iframe is on the page
            boxStyle.setProperty('transform', translateStyle)
            boxStyle.width     = width + 'px';
            boxStyle.height    = height + 'px';
            boxStyle['border-color']   = 'red';

            if (this.showSelectorText && content) {
                this.updateHighlightContent(content);
            }
        } else {
            boxStyle['border-color']   = 'transparent';
        }

        var crosshair = this.boxIndicatorEl.down('.target-inspector-coordinate', true);

        if (point) {
            translateStyle  = $.browser.opera ? ('translate(' + point[0] + 'px,' + point[1] + 'px)') :
                ('translate3d(' + point[0] + 'px, ' + point[1] + 'px, 0)');

            crosshair.style.setProperty('display', 'block');
            crosshair.style.setProperty('transform', translateStyle)
        } else {
            crosshair.style.setProperty('display', 'none');
        }
    },


    findComponentByTarget : function (target) {
        var Ext     = this.getExt();
        var testDoc = this.window.document;

        // Handle potentially having another Ext copy loaded in another frame
        if (target.ownerDocument !== testDoc) {
            var innerFrame = (target.ownerDocument.parentWindow || target.ownerDocument.defaultView).frameElement;
            Ext            = innerFrame.contentWindow.Ext;
        }

        var cmp

        while (!cmp && target && target.nodeName !== 'BODY') {
            cmp    = Ext.getCmp(target.id);
            target = target.parentNode;
        }

        return cmp;
    },


    getOffsets : function (node) {
        var targetDoc = this.window.document;
        var offsets   = [0, 0]

        if (node.ownerDocument !== targetDoc) {
            var innerFrame = (node.ownerDocument.parentWindow || node.ownerDocument.defaultView).frameElement;

            offsets = Ext.fly(innerFrame).getXY();
            offsets[0] -= node.ownerDocument.body.scrollLeft;
            offsets[1] -= node.ownerDocument.body.scrollTop;
        }

        return offsets;
    },


    findExtAncestorClassName : function (cmp) {
        while (cmp) {
            var name = Ext.ClassManager.getName(cmp);

            if (name.match(/^Ext./)) return name;

            cmp = cmp.superclass;
        }

        return '';
    }
});;
Ext.define('Siesta.Harness.Browser.UI.DomContainer', {
    extend : 'Ext.Panel',
    alias  : 'widget.domcontainer',

    cls                     : 'siesta-domcontainer',
    header                  : false,
    collapsible             : true,
    animCollapse            : false,
    padding                 : 10,

    test                    : null,
    testListeners           : null,
    maintainViewportSize    : true,
    canManageDOM            : true,
    suspendAfterLayoutAlign : false,
    inspector               : null,
    enableConsole           : true,
    trackMouse              : true,
    inspectorConfig         : null,

    initComponent : function () {
        var me = this;

        this.testListeners = []

        this.title = Siesta.Resource('Siesta.Harness.Browser.UI.DomContainer', 'title');

        //this.addEvents(
        //    'inspectionstart',
        //    'inspectionstop',
        //    'targethover',
        //    'targetselected'
        //)

        if (this.enableConsole) {

        Ext.apply(this, {
                dockedItems : this.consoleCt = {
                    xtype     : 'component',
                    dock      : 'bottom',
                    hidden    : true,
                    height    : 20,
                    cls       : 'domcontainer-console',
                    renderTpl : '<div><input type="text" /></div>'
                }
            });
        }

        this.callParent()

        this.on({
            afterlayout : this.onAfterLayout,
            expand      : this.onExpand,
            collapse    : this.onCollapse,

            scope : this
        });

        this.inspector = new Siesta.Harness.Browser.UI.ComponentInspector(this.inspectorConfig);

        if (this.trackMouse) {
            this.inspector.on({
                start : this.onInspectionStart,
                stop  : this.onInspectionStop,
                scope : this
            });
        }

        this.relayEvents(this.inspector, ['start', 'stop'], 'inspection')
    },

    afterRender : function () {
        this.callParent(arguments);

        if (this.enableConsole) {
            var input = this.consoleInput = this.el.down('.domcontainer-console input');

            this.inspector.on('targethover', function (dc, cmp) {
                input.dom.value = 'Ext.getCmp("' + cmp.id + '").';
            });

            this.inspector.on('targetselected', function (dc, cmp) {
                input.focus(true);
            });

            input.on({
                keyup : function (e, t) {
                    var val = input.dom.value;

                    if (e.getKey() === e.ENTER && val) {
                        var frame = this.getIFrame();

                        try {
                            var retVal = frame.contentWindow.eval(val);
                            if (window.console) {
                                console.log(retVal);
                            }
                        } catch (e) {
                            window.console && console.log(e.message);
                        }
                    }
                },
                scope : this
            });
        }
    },

    setCanManageDOM : function (value) {
        this.canManageDOM = value

        if (value && !this.hidden) this.alignIFrame()
    },


    getIFrameWrapper : function (force) {
        var test = this.test;

        if (test)
            return (this.canManageDOM || force) && test.scopeProvider && test.scopeProvider.wrapper || null
        else
            return null;
    },


    getIFrame : function (force) {
        var test = this.test;

        if (test)
            return (this.canManageDOM || force) && test.scopeProvider && test.scopeProvider.iframe || null
        else
            return null;
    },


    onAfterLayout : function () {
        if (!this.suspendAfterLayoutAlign) this.alignIFrame();
    },


    alignIFrame : function (force) {
        var wrapper = this.getIFrameWrapper(force);

        if (!this.isFrameVisible() || !wrapper) return

        Ext.fly(wrapper).removeCls('tr-iframe-hidden')
        Ext.fly(wrapper).removeCls('tr-iframe-forced')

        var box = this.body.getBox()

        Ext.fly(wrapper).setBox(box)

        if (!this.maintainViewportSize) {
            Ext.fly(this.getIFrame(force)).setSize(this.body.getSize())
        }

        var test = this.test

        test && test.fireEvent('testframeshow')
    },


    onCollapse : function () {
        this.hideIFrame();
    },


    onExpand : function () {
        this.alignIFrame();
    },


    hideIFrame : function () {
        var iframe = this.getIFrameWrapper()

        iframe && Ext.fly(iframe).setStyle({
            left : '-10000px',
            top  : '-10000px'
        })

        var test = this.test

        test && test.fireEvent('testframehide')
    },


    isFrameVisible : function () {
        return !(this.hidden || this.collapsed)
    },


    showTest : function (test) {
        this.stopInspection();

        if (this.test) {
            Joose.A.each(this.testListeners, function (listener) {
                listener.remove()
            })

            this.testListeners = []

            this.hideIFrame()
        }

        this.test = test

        this.testListeners = [
            test.on('testfinalize', this.onTestFinalize, this)
        ]
        
        // when starting the test with forcedIframe - do not allow the assertion grid to change the location of the iframe
        // (canManageDOM is set to false)
        this.setCanManageDOM(!test.hasForcedIframe())

        this.alignIFrame();
    },


    onTestFinalize : function (event, test) {
        this.setCanManageDOM(true)

        // this prevents harness from hiding the iframe, because "test.hasForcedIframe()" will return null
        // we've moved the iframe to the correct position, and it can never be "forced" again anyway
        if (this.isFrameVisible()) {
            test.forceDOMVisible    = false
            test.isDOMForced        = false
        }
    },


    destroy                 : function () {
        Ext.destroy(this.boxIndicator);
        this.boxIndicator = null;

        // just in case
        this.hideIFrame()

        Joose.A.each(this.testListeners, function (listener) {
            listener.remove()
        })

        this.test = null

        this.callParent(arguments)
    },

    // BEGIN Inspection related code
    // -----------------------------
    inspectedComponent      : null,
    inspectedComponentXType : null,
    boxIndicator            : null,

    inspecting : false,

    toggleInspectionMode : function (on) {
        if (!this.test) return;

        if (on) {
            this.startInspection();

        } else {
            this.stopInspection();
        }
    },

    startInspection : function (showConsole) {
        if (!this.test || !this.test.global) return;

        var wrap = Ext.get(this.getIFrameWrapper());

        this.inspector.start(this.test.global, wrap.child('.tr-iframe-wrapper-inner', true));

        if (this.trackMouse) {
            wrap.un('mouseout', this.onMouseLeave, this);
            wrap.on('mouseout', this.onMouseLeave, this);
        }

        if (this.enableConsole && showConsole !== false) {
            if (!(this.consoleCt instanceof Ext.Component)) {
                this.consoleCt = Ext.widget(this.consoleCt);
            }
            this.consoleCt.show();
        }
        this.addCls('inspection-mode');
    },

    stopInspection : function () {
        this.inspector.stop();

        this.removeCls('inspection-mode');

        if (this.enableConsole && this.consoleCt.rendered) {
            this.consoleCt.hide();
        }
    },

    onMouseLeave : function (e, t) {
        if (!this.el.contains(e.relatedTarget) && !Ext.fly(this.getIFrameWrapper()).contains(e.relatedTarget)) {
            this.stopInspection();
        }
    },

    onInspectionStart : function () {
        var wrap = Ext.get(this.getIFrameWrapper());

        if (wrap) {
            wrap.on('mouseout', this.onMouseLeave, this);
        }
    },

    onInspectionStop : function () {
        var wrap = Ext.get(this.getIFrameWrapper());

        if (wrap) {
            wrap.un('mouseout', this.onMouseLeave, this);
        }
    },

    clearHighlight : function () {
        this.stopInspection();
    },

    highlightTarget : function (target, content, offset) {
        var targetIsPoint = target instanceof Array;

        if (!this.inspector.active) {
            this.startInspection();
        }

        if (targetIsPoint) {
            offset = target;
            target = null;
        } else {
            target = this.test.normalizeElement(target, true, true, false);

            if (target && offset) {
                offset = this.test.normalizeOffset(offset, $(target));
            }
        }

        this.inspector.highlightTarget(target, content, offset);
    }
});;
// Internal class visualizing the cursor position, only used in good browsers (!== IE)
Class('Siesta.Harness.Browser.UI.MouseVisualizer', {

    has : {

        cursorEl                 : null,
        onEventSimulatedListener : null,
        onTestFinishedListener   : null,
        harness                  : null,
        currentTest              : null,
        currentContainer         : null,

        clickEvents : function () {
            return {
                click       : 0,
                dblclick    : 0,
                touchstart  : 0,
                touchend    : 0,
                mousedown   : 0,
                contextmenu : 0
            }
        }
    },

    methods : {
        initialize : function (config) {

            config = config || {}

            for (var o in config) {
                config.hasOwnProperty(o) && (this[o] = config[o]);
            }

            delete this.harness

            this.setHarness(config.harness)
        },

        getCursorEl : function () {
            if (this.cursorEl) return this.cursorEl

            var currentContainer = this.currentContainer

            if (!currentContainer) throw "Need container for cursor"

            var cursor = currentContainer.querySelector('.ghost-cursor');

            if (!cursor) {
                var el       = document.createElement('div');
                el.className = 'ghost-cursor fa fa-mouse-pointer';

                cursor = currentContainer.appendChild(el);
            }

            return this.cursorEl = cursor;
        },


        setHarness : function (harness) {
            if (this.harness) {
                this.harness.un('testframeshow', this.onTestFrameShow, this);
                this.harness.un('testframehide', this.onTestFrameHide, this);
            }

            this.harness = harness

            if (harness) {
                harness.on('testframeshow', this.onTestFrameShow, this);
                harness.on('testframehide', this.onTestFrameHide, this);
                harness.on('recorderplay', this.onRecorderPlay, this);
            }
        },


        reset : function () {
            if (this.onEventSimulatedListener) {
                this.onEventSimulatedListener.remove()
                this.onEventSimulatedListener = null
            }

            if (this.onTestFinishedListener) {
                this.onTestFinishedListener.remove()
                this.onTestFinishedListener = null
            }

            this.cursorEl         = null
            this.currentTest      = null
            this.currentContainer = null
        },


        onTestFrameShow : function (event) {
            var test = event.source;

            this.beginCursorVisualization(test);
        },

        onRecorderPlay : function (recorder, test) {
            this.beginCursorVisualization(test);
        },

        beginCursorVisualization : function (test) {
            // do not react on re-positions of the same running test
            if (test == this.currentTest) return

            this.reset()

            this.currentTest = test

            if (this.harness.canShowCursorForTest(test)) {
                this.currentContainer = test.scopeProvider.wrapper.childNodes[1]

                this.onEventSimulatedListener = test.on('eventsimulated', this.onEventSimulated, this);
                this.onTestFinishedListener   = test.on('testfinalize', this.onTestFinished, this);
            }
        },


        onTestFrameHide : function (event) {
            // ideally, instead of this cleanup, we need to keep listening for the
            // `testfinalize` event on all tests visualizer has been "attached" to
            // and cleanup only in that event
            this.cleanupCursor()
            this.reset()
        },


        // this method can be called already after the test has been finalized and cursor element fade out
        // during that time, current test may change, so it needs to work in 2 modes
        // 1) "sync" mode, when its "attached" to the "this.currentTest"
        // 2) "async" mode, when it cleans up the cursor of the "old" test
        cleanupCursor : function (cursorEl, currentContainer) {
            cursorEl         = cursorEl || this.cursorEl
            currentContainer = currentContainer || this.currentContainer

            if (currentContainer) {
                try {
                    cursorEl.parentNode.removeChild(cursorEl);
                } catch (e) {
                    // catch potential exceptions for example
                    // if iframe of test has been already removed
                }

                try {
                    var els = currentContainer.querySelectorAll('.ghost-cursor-click-indicator-big');
                    for (var i = els.length; i >= 0; --i) {
                        var el = els.item(i);
                        el.parentNode.remove(el);
                    }
                } catch (e) {
                    // catch potential exceptions for example
                    // if iframe of test has been already removed
                }
            }
        },


        onTestFinished : function (event, test) {
            var cursorEl         = this.cursorEl
            var currentContainer = this.currentContainer

            this.reset()

            // if test was using cursor at all
            if (cursorEl) {
                var me = this;

                cursorEl.classList.add('ghost-cursor-hidden');

                setTimeout(function () {
                    me.cleanupCursor(cursorEl, currentContainer);
                }, 2000);
            }
        },


        onEventSimulated : function (event, test, el, type, evt) {
            if (type.match(/touch|mouse|click|contextmenu/) && typeof evt.clientX === 'number' && typeof evt.clientY === 'number') {
                // this should never happen, but still happens sometimes
                if (!this.currentContainer) return

                var x = test.currentPosition[0],
                    y = test.currentPosition[1];

                this.updateGhostCursor(type, x, y);

                if (type in this.clickEvents) {
                    this.showClickIndicator(type, x, y);
                }
            }
        },

        // This method shows a fading growing circle at the xy position
        showClickIndicator : function (type, x, y) {
            var clickEl = document.createElement('div');

            clickEl.className = 'ghost-cursor-click-indicator ';
            clickEl.style.setProperty('left', x + 'px');
            clickEl.style.setProperty('top', +y + 'px');

            clickEl.addEventListener("animationend", this.afterAnimation);
            clickEl.addEventListener("webkitAnimationEnd", this.afterAnimation);

            this.currentContainer.appendChild(clickEl);
        },

        afterAnimation : function() {
            this.parentNode.removeChild(this);
        },

        // Updates the ghost cursor position and appearance
        updateGhostCursor : function (type, x, y) {
            var cursorEl        = this.getCursorEl(),
                translateStyle  = $.browser.opera ? ('translate(' + x + 'px,' + y + 'px)') :
                                 ('translate3d(' + x + 'px, ' + y + 'px, 0)');

            cursorEl.style.setProperty('-webkit-transform', translateStyle)
            cursorEl.style.setProperty('transform', translateStyle)
        }
    }
});
;
